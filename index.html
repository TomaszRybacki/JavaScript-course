<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <meta name="author" content="Tomasz Rybacki">
  <meta name="description" content="Responsive Web Design Projects - Build a Technical Documentation Page">

  <title>Technical Documentation Page</title>
  <link rel="icon" type="image/png" sizes="96x96" href="img/favicon96x96.png">

  <link href="https://fonts.googleapis.com/css?family=Muli:400,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="stylesheet" href="css/main.css">

</head>

<body class="body">

  <button class="menu" id="menu-button">
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
  </button>

  <nav id="navbar" class="navigation">
    <header class="navigation__header">
      <h1 class="header__title">Kurs JavaScript</h1>
    </header>
    <ol class="navigation__list">
      <li class="nav-item"><a class="nav-link" href="#Czym_jest_javaScript">01. Czym jest javaScript ?</a></li>
      <li class="nav-item"><a class="nav-link" href="#Debugowanie_cz1">02. Debugowanie cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Debugowanie_cz2">03. Debugowanie cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Typy_wartosci">04. Typy wartoÅ›ci</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zmienne_cz1">05. Zmienne cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zmienne_cz2">06. Zmienne cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Operatory">07. Operatory</a></li>
      <li class="nav-item"><a class="nav-link" href="#Konwersja_typow">08. Konwersja typÃ³w</a></li>
      <li class="nav-item"><a class="nav-link" href="#Instrukcje_warunkowe">09. Instrukcje warunkowe</a></li>
      <li class="nav-item"><a class="nav-link" href="#Tablice">10. Tablice</a></li>
      <li class="nav-item"><a class="nav-link" href="#Podstawowe_petle">11. Podstawowe pÄ™tle</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz1">12. Funkcje cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz2">13. Funkcje cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz3">14. Funkcje cz.3</a></li>
      <li class="nav-item"><a class="nav-link" href="#Objekty_cz1">15. Objekty cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Objekty_cz2">16. Objekty cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Klasy">17. Klasy</a></li>
      <li class="nav-item"><a class="nav-link" href="#Obiekty_opakowujace">18. Obiekty opakowujÄ…ce</a></li>
      <li class="nav-item"><a class="nav-link" href="#Obiekty_wbudowane">19. Obiekty wbudowane</a></li>
      <li class="nav-item"><a class="nav-link" href="#DOM">20. DOM</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zdarzenia">21. Zdarzenia</a></li>
      <li class="nav-item"><a class="nav-link" href="#JSON">22. JSON</a></li>
      <li class="nav-item"><a class="nav-link" href="#HTTP">23. HTTP</a></li>
      <li class="nav-item"><a class="nav-link" href="#REST_API">24. REST API</a></li>
    </ol>
  </nav>

  <div class="push"></div>

  <main id="main-doc" class="documentation">

    <header class="documentation__header">
      <img class="header__banner" src="img/JavaScript-banner.jpg" alt="banner javaScript">
      <span class="header__txt">Kurs ten powstaÅ‚ w ramach mojego <a class="blog-link" href="http://blog.tomasz-rybacki.pl">bloga</a>.<br> ZachÄ™cam CiÄ™ do jego odwiedzenia oraz Å¼yczÄ™ owocnej nauki programowania w JavaScript.</span>
    </header>


    <!-- Article 01 -->


    <article class="article">

      <header id="Czym_jest_javaScript" class="article__header">
        <div class="decor">01</div>
        <h2 class="article__title">Czym jest javaScript ?</h2>
      </header>

      <p class="article__paragraph">W wikipedii czytamy, Å¼e jest to skryptowy jÄ™zyk programowania. WyjaÅ›nijmy sobie co to oznacza.</p>

      <p class="article__paragraph">Programy napisane w tym jÄ™zyku nie wymagajÄ… kompilacji do kodu maszynowego, ktÃ³ry jest zapisywany w postaci binarnej (same zera i jedynki). Kod ten jest bezpoÅ›rednio wykonywany przez procesor komputera. Zamiast tego nasze skrypty sÄ… wykonywane za pomocÄ… interpretera, ktÃ³ry analizuje kaÅ¼de wyraÅ¼enie przed jego wykonaniem.</p>

      <p class="article__paragraph">JavaScript jest jÄ™zykiem wysokiego poziomu co oznacza, Å¼e piszÄ…c w nim nie przejmujemy siÄ™ wszystkim tym co dzieje siÄ™ â€pod maskÄ…â€ jak: zarzÄ…dzanie pamiÄ™ciÄ…, przechowywanie danych, wewnÄ™trzne typy danych. DziÄ™ki temu moÅ¼na dosyÄ‡ szybko poznaÄ‡ jego podstawy i zaczÄ…Ä‡ samodzielnie pisaÄ‡ skrypty. UÅ¼ywamy w nim abstrakcji do ukrycia technicznych detali. Kod piszemy przy pomocy angielskich sÅ‚Ã³w, dziÄ™ki temu odczytywanie go jest proste, niczym czytanie instrukcji obsÅ‚ugi nowo zakupionego urzÄ…dzenia AGD ğŸ™‚</p>

      <p class="article__paragraph">Skrypty, ktÃ³re w nim piszemy sÄ… wykonywane w caÅ‚oÅ›ci od poczÄ…tku do koÅ„ca. Z gÃ³ry na dÃ³Å‚, od lewej do prawej. SÄ… to zasady, ktÃ³re wszyscy dobrze znamy i z ktÃ³rych korzystamy na co dzieÅ„ podczas czytania. Nasz kod JavaScript dziaÅ‚a w pewnym Å›rodowisku. MoÅ¼e byÄ‡ to przeglÄ…darka internetowa (na tym Å›rodowisku skupimy siÄ™ w tym kursie) lub np. Node.js, w ktÃ³rym to moÅ¼emy uruchamiaÄ‡ kod JavaScript po stronie serwera lub w wierszu poleceÅ„ naszego komputera. Od naszego Å›rodowiska zaleÅ¼y do jakich obiektÃ³w globalnych bÄ™dziemy mieli dostÄ™p. Z niego wynika zastosowanie naszego kodu. MogÄ… byÄ‡ to wszystkie interakcje uÅ¼ytkownika ze stronÄ… internetowÄ… lub logika wykonywana po stronie serwera.</p>

      <p class="article__paragraph">WspÃ³Å‚czesne narzÄ™dzia jak silnik JavaScript V8 w Google Chrome, kompilujÄ… nasz kod w chwili wykonania. Pozwala to na jeszcze szybsze dziaÅ‚anie naszych programÃ³w.</p>

      <p class="article__paragraph">CiekawostkÄ… jest sama nazwa tego jÄ™zyka programowania. PoczÄ…tkowo nazywaÅ‚ siÄ™ LiveScript, jednak na fali rosnÄ…cej popularnoÅ›ci i sukcesu jakim cieszyÅ‚ siÄ™ jÄ™zyk Java. ZostaÅ‚ przemianowany na JavaScript. ZostaÅ‚ wiÄ™c jego mÅ‚odszym bratem i przedmiotem Å¼artÃ³w. PoniewaÅ¼ osoby kompletnie zielone czÄ™sto utoÅ¼samiajÄ… te dwa rÃ³Å¼ne jÄ™zyki programowania ze sobÄ…. MyÅ›lÄ…c, Å¼e sÄ… tym samym.</p>

    </article>


    <!-- Article 02 -->


    <article class="article">

      <header id="Debugowanie_cz1" class="article__header">
        <div class="decor">02</div>
        <h2 class="article__title">Debugowanie cz.1</h2>
      </header>


      <p class="article__paragraph">Dzisiaj skonfigurujemy nasz projekt, w ktÃ³rym bÄ™dziemy uczyÄ‡ siÄ™ kolejnych zagadnieÅ„ zwiÄ…zanych z JavaScript. Powiemy sobie rÃ³wnieÅ¼ na temat bÅ‚Ä™dÃ³w i sposobÃ³w radzenia sobie z nimi. ZakÅ‚adam, Å¼e masz juÅ¼ zainstalowanego Bracketsa oraz przeglÄ…darkÄ™ Chrome.</p>

      <section class="article__section">
        <h3 class="article__section__title">Projekt</h3>
        <p class="article__paragraph">Tworzymy nowy folder do przechowywania naszych plikÃ³w. Ja nazwaÅ‚em swÃ³j <strong class="bold">Kurs.</strong> WewnÄ…trz tworzymy nowy folder scripts, w ktÃ³rym bÄ™dÄ… znajdowaÄ‡ siÄ™ wszystkie nasze skrypty. Tworzymy tam nowy plik o nazwie <strong class="bold">code.js.</strong> Teraz potrzebujemy utworzyÄ‡ podstawowy plik html o nazwie <strong class="bold">index.html</strong> w folderze gÅ‚Ã³wnym.</p>

        <pre class="article__code">
        <code>
    &lt;!DOCTYPE html&gt;
    &lt;html lang="pl"&gt;

      &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;

        &lt;meta name="author" content="Tomasz Rybacki"&gt;
        &lt;meta name="description" content="Kurs JavaScript dla poczÄ…tkujÄ…cych."&gt;

        &lt;title&gt;Kurs JavaScript&lt;/title&gt;
      &lt;/head&gt;

      &lt;body&gt;

        &lt;script src="scripts/code.js"&gt;&lt;/script&gt;
      &lt;/body&gt;

    &lt;/html&gt;
        </code>
      </pre>

        <p class="article__paragraph">WewnÄ…trz znacznika <strong class="bold">&lt;script&gt;</strong> umieszczamy Å›cieÅ¼kÄ™ dostÄ™pu do naszego pliku z kodem js. Znacznik ten umieszczamy zawsze na koÅ„cu naszego body tuÅ¼ przed znacznikiem zamykajÄ…cym <strong class="bold">&lt;/body&gt;</strong>. Robimy tak poniewaÅ¼ nie chcemy Å¼eby podczas wczytywania strony, Å‚adujÄ…cy siÄ™ kod JavaScript blokowaÅ‚ wyÅ›wietlanie pozostaÅ‚ej czÄ™Å›ci strony. SprawiajÄ…c wraÅ¼enie wolnego dziaÅ‚ania strony i pozostawiajÄ…c uÅ¼ytkownika z biaÅ‚ym ekranem.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">ESLint</h3>
        <p class="article__paragraph">Pierwszym narzÄ™dziem jakie wykorzystamy do pisania kodu dobrej jakoÅ›ci bÄ™dzie <a class="article__link" href="https://eslint.org" target="_blank">ESLint</a> ze zbiorem zasad airbnb-base. NarzÄ™dzie to pokazuje nam bÅ‚Ä™dy jakie popeÅ‚niliÅ›my oraz daje pomocne wskazÃ³wki, jeszcze przed uruchomieniem naszego kodu w przeglÄ…darce.</p>

        <p class="article__paragraph">Å»eby je zainstalowaÄ‡, najpierw potrzebujemy zainstalowaÄ‡ <a class="article__link" href="https://nodejs.org/en/" target="_blank">Node.js.</a> Pobieramy i instalujemy wersjÄ™ rekomendowanÄ… dla wiÄ™kszoÅ›ci uÅ¼ytkownikÃ³w, w chwili pisania tego postu jest to wersja 8.11.1 LTS.</p>

        <p class="article__paragraph">Teraz uruchamiamy wiersz poleceÅ„ i za jego pomocÄ… nawigujemy do folderu z naszym projektem. (Wszystkie moje polecenia sÄ… dla systemu operacyjnego Windows 10) W moim przypadku sÄ… to komendy:</p>

        <span class="article__command">E:</span>
        <span class="article__command">cd E:\11 Programowanie\Blog\Kurs</span>

        <p class="article__paragraph">Teraz inicjalizujemy plik package.json, za pomocÄ… komendy:</p>

        <span class="article__command">npm init</span>

        <p class="article__paragraph">Wszystkie opcje zatwierdzamy enterem. Nie musimy nic wpisywaÄ‡ i zmieniaÄ‡. NastÄ™pnie instalujemy ESLint wpisujÄ…c polecenie:</p>

        <span class="article__command">npm install â€“save-dev eslint eslint-config-airbnb eslint-plugin-import</span>

        <p class="article__paragraph">Teraz dodajemy plik o nazwie .eslintrc. Zawiera on ustawienia z jakich korzystamy w naszym projekcie.</p>

        <pre class="article__code">
        <code>
    {
        "extends": "airbnb-base",
        "parserOptions": {
        "ecmaVersion": 6
        },
        "env": {
        "node": true,
        "browser": true,
        "es6": true
        },
        "rules": {
        "comma-dangle": ["error", "never"],
        "no-unused-vars": ["error", {"vars": "local", "args": "none"}]
        }
    }
      </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e nasz zbiÃ³r zasad jest rozszerzeniem zasad opracowanych przez airbnb-base. DomyÅ›lnie ESLint wspiera tylko skÅ‚adniÄ™ ECMAScript 5, poniewaÅ¼ zamierzamy korzystaÄ‡ rÃ³wnieÅ¼ z wersji ECMAScript 6 dodajemy to moÅ¼liwoÅ›Ä‡ w parserOptions. Nie przejmuj siÄ™ jeÅ›li nie wiesz co to oznacza. Wszystko wyjaÅ›nimy w dalszej czÄ™Å›ci kursu.</p>

        <p class="article__paragraph">â€envâ€ przechowuje Å›rodowiska w jakich bÄ™dzie dziaÅ‚aÅ‚ nasz kod. Natomiast â€rulesâ€ zawiera nasze wÅ‚asne ustawienia obecnie obowiÄ…zujÄ…cych zasad. DodajÄ…c tu kolejne pozycje, moÅ¼emy wyÅ‚Ä…czyÄ‡ lub zmieniÄ‡ status zgÅ‚aszanego bÅ‚Ä™du na ostrzeÅ¼enie lub na odwrÃ³t. Wszystkie rodzaje bÅ‚Ä™dÃ³w i ich moÅ¼liwÄ… konfiguracje znajdziemy w dokumentacji ESLint.</p>

        <img class="article__img" src="img/Linter.jpg" alt="zrzut ekranu edytora Brackets">

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Nasze drzewko plikÃ³w w projekcie powinno wyglÄ…daÄ‡ tak.</li>
          <li class="ordered-list__item">PrzykÅ‚adowy kod, obok widzimy ikony wyÅ›wietlane przez ESLint zgÅ‚aszajÄ…ce ostrzeÅ¼enie i bÅ‚Ä…d w danej linijce kodu.</li>
          <li class="ordered-list__item">Za pomocÄ… tej ikony wÅ‚Ä…czamy i wyÅ‚Ä…czamy podglÄ…d zgÅ‚oszonych bÅ‚Ä™dÃ³w (okno nr 4)</li>
          <li class="ordered-list__item">Lista zgÅ‚oszonych bÅ‚Ä™dÃ³w. ZaczynajÄ…c od lewej mamy:
            <ul class="article__unordered-list">
              <li class="unordered-list__item">nr linii kodu z bÅ‚Ä™dem</li>
              <li class="unordered-list__item">typ bÅ‚Ä™du i informacjÄ™ na jego temat</li>
              <li class="unordered-list__item">nazwÄ™ zasady podanÄ… w nawiasie kwadratowym</li>
            </ul>
          </li>
        </ol>

        <p class="article__paragraph">Kod z tej lekcji moÅ¼na pobraÄ‡ z <a class="article__link" href="https://github.com/TomaszRybacki/Kurs" target="_blank">GitHuba</a>.</p>
      </section>

    </article>


    <!-- Article 03 -->


    <article class="article">

      <header id="Debugowanie_cz2" class="article__header">
        <div class="decor">03</div>
        <h2 class="article__title">Debugowanie cz.2</h2>
      </header>

      <p class="article__paragraph">Dzisiaj dokoÅ„czymy temat radzenia sobie z bÅ‚Ä™dami. OmÃ³wimy obiekt console, punkty kontrolne i typy pojawiajÄ…cych siÄ™ bÅ‚Ä™dÃ³w.</p>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt console</h3>
      </section>

      <p class="article__paragraph">PrzeglÄ…darka internetowa Chrome ma wbudowanÄ… konsolÄ™ JavaScript, moÅ¼emy w niej pisaÄ‡ bezpoÅ›rednio kod js. RÃ³wnieÅ¼ w niej bÄ™dÄ… siÄ™ nam wyÅ›wietlaÅ‚y wszystkie bÅ‚Ä™dy jakie napotka interpreter. BÄ™dziemy mieli podanÄ… nazwÄ™ bÅ‚Ä™du, jego opis i numer linii kodu, w ktÃ³rym wystÄ…piÅ‚. DziÄ™ki temu moÅ¼emy szybko zlokalizowaÄ‡ i poprawiÄ‡ wystÄ™pujÄ…ce bÅ‚Ä™dy.</p>

      <p class="article__paragraph">Aby jÄ… otworzyÄ‡ klikamy prawym przyciskiem myszy na stronie internetowej i wybieramy przycisk Zbadaj. NastÄ™pnie przechodzimy do zakÅ‚adki Console.</p>

      <img class="article__img" src="img/console.jpg" alt="zrzut ekranu konsoli w przeglÄ…darce Chrome">

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Pasek boczny konsoli. KlikajÄ…c odpowiednio kategoriÄ™ wyÅ›wietlamy tylko powiadomienia danego typu.</li>
        <li class="ordered-list__item">Konsola. To tutaj bÄ™dÄ… pojawiaÄ‡ siÄ™ informacje o bÅ‚Ä™dach z ich opisem. RÃ³wnieÅ¼ tutaj moÅ¼emy pisaÄ‡ nasz kod JS oraz wyÅ›wietlaÄ‡ informacje za pomocÄ… obiektu console.</li>
        <li class="ordered-list__item">Nazwa pliku oraz numer linii kodu z tego pliku, ktÃ³ry generuje danÄ… informacjÄ™.</li>
      </ol>

      <p class="article__paragraph">KonsolÄ™ wykorzystujemy rÃ³wnieÅ¼ do sprawdzania jakie wartoÅ›ci przyjmujÄ… nasze zmienne w danym fragmencie skryptu. Przyjrzyjmy siÄ™ teraz metodom jakie zapewnia obiekt console. NajwaÅ¼niejsze z nich to:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.log()</strong> â€“ sÅ‚uÅ¼Ä…ce do wyÅ›wietlania treÅ›ci w konsoli</li>
      </ul>

      <p class="article__paragraph">Metoda ta ma trzy bliÅºniacze metody, ktÃ³re rÃ³wnieÅ¼ wyÅ›wietlajÄ… nasz tekst w konsoli ale dodatkowo zapewniajÄ… stylowanie. DziÄ™ki czemu moÅ¼emy filtrowaÄ‡ wyÅ›wietlane informacje i wyÅ›wietlaÄ‡ tylko te, ktÃ³re w danym momencie sÄ… dla nas istotne.</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.info()</strong> â€“ wyÅ›wietla tekst jako informacjÄ™</li>
        <li class="unordered-list__item"><strong class="bold">console.warn()</strong> â€“ wyÅ›wietla tekst jako ostrzeÅ¼enie</li>
        <li class="unordered-list__item"><strong class="bold">console.error()</strong> â€“ wyÅ›wietla tekst jako bÅ‚Ä…d</li>
      </ul>

      <p class="article__paragraph">KolejnÄ… przydatnÄ… metodÄ… jest:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.group(), console.groupCollapsed()</strong> â€“ sÅ‚uÅ¼y do grupowania wyÅ›wietlanych informacji pod wspÃ³lnÄ… etykietÄ…, coÅ› w stylu rozpoczynajÄ…cego znacznika HTML</li>
        <li class="unordered-list__item"><strong class="bold">console.groupEnd()</strong> â€“ zamyka naszÄ… grupÄ™, coÅ› w stylu zamykajÄ…cego znacznika HTML</li>
      </ul>

      <p class="article__paragraph">OprÃ³cz tych podstawowych metod, mamy jeszcze kilka, ktÃ³re mogÄ… byÄ‡ przydatne, oto one:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.assert()</strong> â€“ sprawdza warunek, jeÅ›li nie jest speÅ‚niony, dopiero wtedy wyÅ›wietla wiadomoÅ›Ä‡ do konsoli</li>
        <li class="unordered-list__item"><strong class="bold">console.count()</strong> â€“ wyÅ›wietla ile razy zostaÅ‚o uÅ¼yte wywoÅ‚anie tej metody z danÄ… etykietÄ…. Taki zwykÅ‚y licznik.</li>
        <li class="unordered-list__item"><strong class="bold">console.time() </strong> â€“ rozpoczyna odliczanie czasu jaki minÄ…Å‚ od wywoÅ‚ania tej metody, dziÄ™ki temu moÅ¼emy sprawdziÄ‡ czas wykonania danego fragmentu naszego kodu</li>
        <li class="unordered-list__item"><strong class="bold">console.timeEnd()</strong> â€“ koÅ„czy odliczanie czasu i wyÅ›wietla ile czasu (milisekund) upÅ‚ynÄ™Å‚o od jego rozpoczÄ™cia</li>
      </ul>

      <strong class="bold">PrzykÅ‚ad</strong>

      <pre class="article__code">
        <code>
    // Obiekt console

    console.time('Timer');
    console.count('Counter');

    console.group('names');
    console.info('Tomasz');
    console.warn('Daniel');
    console.error('Marcin');
    console.log('Adam');
    console.groupEnd();

    console.count('Counter');

    console.groupCollapsed('age');
    console.log(28);
    console.log(25);
    console.log(32);
    console.log(32);
    console.groupEnd();

    console.count('Counter');

    const myName = 777;
    console.assert(typeof myName === 'string', 'Niepoprawny typ zmiennej, oczekiwano wartoÅ›ci typu "string".');

    console.timeEnd('Timer');
        </code>
      </pre>

      <section class="article__section">
        <h3 class="article__section__title">Punkty kontrolne</h3>

        <p class="article__paragraph">MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e bÄ™dziemy potrzebowaÄ‡ przeanalizowaÄ‡ jak dziaÅ‚a nasz skrypt kawaÅ‚ek po waÅ‚ku. W tym celu moÅ¼emy wstawiÄ‡ sÅ‚owo kluczowe debugger w kaÅ¼dym miejscu, w ktÃ³rym chcemy Å¼eby nastÄ…piÅ‚a pauza w wykonywaniu naszego skryptu. NastÄ™pnie w zakÅ‚adce Sources przeglÄ…darki moÅ¼emy przeÅ‚Ä…czaÄ‡ siÄ™ pomiÄ™dzy utworzonymi punktami kontrolnymi i obserwowaÄ‡ w jaki sposÃ³b jest wykonywany nasz skrypt, jakie wartoÅ›ci przyjmujÄ… zmienne w danym miejscu i jaki jest stos wywoÅ‚aÅ„.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Typy bÅ‚Ä™dÃ³w</h3>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">SyntaxError â€“ nieprawidÅ‚owa skÅ‚adnia np.: niedopasowane lub brakujÄ…ce znaki cytowania, brakujÄ…ce nawiasy, nieprawidÅ‚owe nazwy wÅ‚aÅ›ciwoÅ›ci lub zmiennych</li>
          <li class="unordered-list__item">ReferenceError â€“ zmienna nie istnieje np.: niezadeklarowana zmienna, niezdefiniowana nazwa funkcji</li>
          <li class="unordered-list__item">TypeError â€“ nieoczekiwany typ danych np.: metoda nie istnieje, nieprawidÅ‚owa wielkoÅ›Ä‡ znaku w nazwie metody</li>
          <li class="unordered-list__item">RangeError â€“ liczba spoza zakresu np.: nie moÅ¼na utworzyÄ‡ tablicy zawierajÄ…cej -x elementÃ³w</li>
          <li class="unordered-list__item">EvalError â€“ nieprawidÅ‚owe uÅ¼ycie funkcji eval()</li>
          <li class="unordered-list__item">URIError â€“ nieprawidÅ‚owe uÅ¼ycie funkcji URI</li>
        </ul>

        <p class="article__paragraph">Najbardziej interesujÄ… nas pierwsze cztery typy bÅ‚Ä™dÃ³w bo to wÅ‚aÅ›nie je bÄ™dziemy spotykaÄ‡ najczÄ™Å›ciej piszÄ…c nasze programy.</p>
      </section>

    </article>


    <!-- Article 04 -->


    <article class="article">

      <header id="Typy_wartosci" class="article__header">
        <div class="decor">04</div>
        <h2 class="article__title">Typy wartoÅ›ci</h2>
      </header>

      <p class="article__paragraph">W JavaScript mamy siedem typÃ³w wartoÅ›ci, sÄ… to:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">string</li>
        <li class="ordered-list__item">number</li>
        <li class="ordered-list__item">boolean</li>
        <li class="ordered-list__item">undefined</li>
        <li class="ordered-list__item">null</li>
        <li class="ordered-list__item">symbol</li>
        <li class="ordered-list__item">object</li>
      </ol>

      <p class="article__paragraph">Typ przechowywanej wartoÅ›ci moÅ¼emy sprawdziÄ‡ za pomocÄ… polecenia <strong class="bold">typeof()</strong>. JS jest jÄ™zykiem dynamicznym, zmienne nie sÄ… zwiÄ…zane z konkretnym typem danych jaki mogÄ… przechowywaÄ‡. To wartoÅ›ci przechowywane w zmiennych majÄ… swÃ³j typ i mogÄ… siÄ™ zmieniaÄ‡ w trakcje wykonywania naszego programu. DziÄ™ki czemu zmienna o nazwie <strong class="bold">name</strong> moÅ¼e przechowywaÄ‡ na poczÄ…tku liczbÄ™ (typ number), potem ciÄ…g znakÃ³w (typ string), Å¼eby ostatecznie zostaÄ‡ obiektem (typ object) na koÅ„cu dziaÅ‚ania naszego programu.</p>


      <section class="article__section">
        <h3 class="article__section__title">String</h3>
        <p class="article__paragraph">Jest to ciÄ…g znakÃ³w tekstowych, ktÃ³ry zapisujemy w cudzysÅ‚owie podwÃ³jnym lub pojedynczym lub za pomocÄ… znaku apostrof (tego na klawiszu pod Esc). Ten typ sÅ‚uÅ¼y do przechowywania informacji w postaci sÅ‚Ã³w np.: â€Å»ycie to sztuka wyborÃ³wâ€, â€šLubiÄ™ siÄ™ uczyÄ‡.â€™, `Kodowanie jest fajne.`. WybÃ³r <strong class="bold">â€œ â€</strong> lub <strong class="bold">â€˜ â€™</strong> naleÅ¼y do ciebie. Natomiast <strong class="bold">Â´ Â´</strong> daje dodatkowe moÅ¼liwoÅ›ci, o ktÃ³rych powiemy w dalszych lekcjach kursu JS.</p>

        <p class="article__paragraph">String w JS jest niezmienny co oznacza, Å¼e po jego utworzeniu nie moÅ¼emy go modyfikowaÄ‡. MoÅ¼emy jedynie tworzyÄ‡ nowe wartoÅ›ci typu string na podstawie utworzonej wczeÅ›niej wartoÅ›ci np. poprzez wyciÄ™cie jego czÄ™Å›ci. MajÄ…c sÅ‚owo â€šdomekâ€™, moÅ¼emy wyciÄ…Ä‡ pierwsze trzy litery tworzÄ…c sÅ‚owo â€šdomâ€™.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Number</h3>
        <p class="article__paragraph">Przechowuje liczby, pozwala przeprowadzaÄ‡ operacje matematyczne. Typ ten zawiera zarÃ³wno liczby caÅ‚kowite jak i uÅ‚amkowe liczby dziesiÄ™tne.</p>

        <p class="article__paragraph">W JS wykorzystuje siÄ™ 64-bitowy binarny format podwÃ³jnej precyzji oparty na standardzie IEEE 754. Oznacza to, Å¼e liczby sÄ… przechowywane w 64 bitach, gdzie 1 bit przechowuje znak liczby (+ lub -), 11 bitÃ³w przechowuje wykÅ‚adnik potÄ™gowy (dla 2Â³ = 2 * 2 * 2 wykÅ‚adnikiem jest liczba 3), natomiast pozostaÅ‚e 52 bity przechowujÄ… czÄ™Å›Ä‡ uÅ‚amkowÄ….</p>

        <p class="article__paragraph">Z tego powodu nie moÅ¼emy operowaÄ‡ na dowolnych liczbach, jesteÅ›my zmuszeni do ograniczenia siÄ™ do liczb caÅ‚kowitych z przedziaÅ‚u od 9007199254740991 do -9007199254740991. Dodatkowo uÅ‚amki dziesiÄ™tne nie sÄ… reprezentowane w sposÃ³b dokÅ‚adny i dziaÅ‚anie 0.1 + 0.2 = 0.30000000000000004. Z matematycznego punktu widzenia nie jest to wynik, ktÃ³rego byÅ›my siÄ™ spodziewali. Dlatego musimy zachowaÄ‡ ostroÅ¼noÅ›Ä‡ przy operacjach na uÅ‚amkach i stosowaÄ‡ zaokrÄ…glenia przy porÃ³wnywaniu wynikÃ³w z sobÄ…. KolejnÄ… ciekawostkÄ… jest teÅ¼ fakt istnienia zera dodatniego i zera ujemnego. Gdy podzielimy 2 / 0 otrzymamy nieskoÅ„czonoÅ›Ä‡, natomiast dla dziaÅ‚ania 2 / -0 otrzymamy minus nieskoÅ„czonoÅ›Ä‡.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Boolean</h3>
        <p class="article__paragraph">Typ ten pozwala na podejmowanie decyzji. Jest to typ logiczny, moÅ¼e przyjmowaÄ‡ tylko dwie wartoÅ›ci: true (prawda) i false (faÅ‚sz).</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Undefined</h3>
        <p class="article__paragraph">Typ undefined zawiera tylko jednÄ… wartoÅ›Ä‡, wartoÅ›Ä‡ undefined. WartoÅ›Ä‡ nie zdefiniowana zostaje automatycznie przypisana zmiennej, ktÃ³ra zostaÅ‚a tylko zadeklarowana przy pomocy sÅ‚owa kluczowego var lub let (powiemy na ten temat przy okazji omawiania zmiennych).</p>

        <p class="article__paragraph">Dodatkowo sprawdzajÄ…c typ zmiennej, ktÃ³ra nie zostaÅ‚a zadeklarowana rÃ³wnieÅ¼ otrzymamy wartoÅ›Ä‡ undefined np. console.log(typeof(c)); zwraca undefined gdy zmienna c nie wystÄ™puje w naszym kodzie.</p>

        <p class="article__paragraph">WartoÅ›Ä‡ undefined zwraca rÃ³wnieÅ¼:</p>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">funkcja, w ktÃ³rej nie zastosowano polecenia return</li>
          <li class="unordered-list__item">wÅ‚aÅ›ciwoÅ›Ä‡ obiektu, ktÃ³ra nie jest zadeklarowana</li>
        </ul>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Null</h3>
        <p class="article__paragraph">Typ null zawiera tylko jednÄ… wartoÅ›Ä‡. Jest niÄ… null. WartoÅ›Ä‡ ta reprezentuje celowy brak danej wartoÅ›ci w obiekcie. Wynika z tego, Å¼e musimy jÄ… przypisaÄ‡ do wÅ‚aÅ›ciwoÅ›ci danego obiektu.</p>
        <p class="article__paragraph">WaÅ¼nÄ… rzeczÄ…, o ktÃ³rej trzeba wiedzieÄ‡ to bÅ‚Ä…d jaki istnieje w JS od czasu powstania tego jÄ™zyka.</p>

        <pre class="article__code">
        <code>
    let a = null;
    console.log(typeof(a)); // zwraca typ object
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Symbol</h3>
        <p class="article__paragraph">Jest to nie powtarzalna wartoÅ›Ä‡ sÅ‚uÅ¼Ä…ca do identyfikacji wÅ‚aÅ›ciwoÅ›ci w obiekcie. Tworzymy go za pomocÄ… funkcji Symbol(â€šopisâ€™). Opis sÅ‚uÅ¼y wyÅ‚Ä…cznie do celÃ³w debugowania abyÅ›my my potrafili rozrÃ³Å¼niÄ‡ symbole od siebie. MoÅ¼emy nadaÄ‡ dwÃ³m symbolom takie same opisy. Nie sprawi to jednak, Å¼e oba symbole bÄ™dÄ… takie same i rÃ³wne sobie. Za kaÅ¼dym razem tworzÄ…c symbol tworzymy nowy unikatowy symbol.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Podsumowanie</h3>
        <p class="article__paragraph">OmÃ³wione do tej pory typy to wartoÅ›ci typu prostego, co oznacza, Å¼e sÄ… niezmienne. SÄ… to takie podstawowe klocki, z ktÃ³rych budujemy bardziej zÅ‚oÅ¼one konstrukcje.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Object</h3>
        <p class="article__paragraph">Object natomiast jest wartoÅ›ciÄ… zÅ‚oÅ¼onÄ… skÅ‚adajÄ…cÄ… siÄ™ z par klucz: wartoÅ›Ä‡. Gdzie kluczem moÅ¼e byÄ‡ string lub symbol. Natomiast wÅ‚aÅ›ciwoÅ›ciÄ… mogÄ… byÄ‡ wszystkie wyÅ¼ej wymienione typy. Object dodatkowo zawiera w sobie podtypy takie jak: function (funkcja â€“ obiekt, ktÃ³ry ma moÅ¼liwoÅ›Ä‡ wywoÅ‚ania), array (tablica â€“ obiekt, ktÃ³ry wykorzystuje liczby jako klucze oraz ma automatycznie uaktualnianÄ… wÅ‚aÅ›ciwoÅ›Ä‡ length, ktÃ³ra wskazuje wielkoÅ›Ä‡ tablicy).</p>

        <p class="article__paragraph">Gdy myÅ›limy o obiekcie moÅ¼emy go sobie wyobraziÄ‡ jako uproszczony model opisujÄ…cy coÅ› co znamy z rzeczywistoÅ›ci. WeÅºmy przykÅ‚ad czÅ‚owieka. KaÅ¼dy czÅ‚owiek ma imiÄ™, wzrost, wagÄ™, kolor oczu itp. SÄ… to wÅ‚aÅ›ciwoÅ›ci naszego obiektu. Dodatkowo kaÅ¼dy czÅ‚owiek potrafi robiÄ‡ rÃ³Å¼ne rzeczy, np. mÃ³wiÄ‡, chodziÄ‡ itp. CzynnoÅ›ci wykonywane przez obiekt nazywamy metodami tego obiektu. Oto przykÅ‚ad obiektu o nazwie person.</p>

        <pre class="article__code">
        <code>
    const person = {
        name: 'Tomasz',
        height: 174,
        weight: 70,
        eyeColor: 'gray',

        sayHello() {
          return 'Hello';
        },
        walk() {
          return 'I go for a walk to a park';
        }
    }

    console.log(person.name); // Tomasz
    console.log(person.walk()); // 'I go for a walk to a park'

    console.log(typeof(person.name)); // string
    console.log(typeof(person.walk)); // function
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WartoÅ›Ä‡ specjalna NaN</h3>
        <p class="article__paragraph">Typ number zawiera wartoÅ›Ä‡ NaN (not a number). Oznacza wartoÅ›Ä‡, ktÃ³ra nie jest poprawnÄ… liczbÄ…. Powstaje w wyniku operacji matematycznej, ktÃ³ra siÄ™ nie powiodÅ‚a np: 2 * 'ja'. Mamy typ number mnoÅ¼ony przez typ string. PoniewaÅ¼ JS nie ma pojÄ™cia w jaki sposÃ³b przeprowadziÄ‡ takÄ… operacjÄ™ otrzymamy NaN.</p>

        <p class="article__paragraph">Dodatkowo wartoÅ›Ä‡ NaN nie jest rÃ³wna innej wartoÅ›ci NaN. Dlatego Å¼eby sprawdziÄ‡ czy coÅ› jest wartoÅ›ciÄ… NaN musimy uÅ¼yÄ‡ metody <strong class="bold">Number.isNaN()</strong>.</p>
      </section>


    </article>


    <!-- Article 05 -->


    <article class="article">

      <header id="Zmienne_cz1" class="article__header">
        <div class="decor">05</div>
        <h2 class="article__title">Zmienne cz.1</h2>
      </header>

      <p class="article__paragraph">W kodzie JS istniejÄ… trzy sÅ‚owa kluczowe sÅ‚uÅ¼Ä…ce do deklarowania zmiennych. SÄ… to sÅ‚owa <strong class="bold">var, let, const</strong>. Dzisiaj przyjrzymy siÄ™ rÃ³Å¼nicom jakie wystÄ™pujÄ… pomiÄ™dzy nimi oraz powiemy sobie czym jest zakres i wynoszenie.</p>

      <p class="article__paragraph">NaleÅ¼y pamiÄ™taÄ‡, Å¼e w JS wystÄ™puje typowanie dynamiczne co oznacza, Å¼e to wartoÅ›ci przechowywane w zmiennych majÄ… swoje typy. Same zmienne nie wymuszajÄ… typu wartoÅ›ci jakie mogÄ… przechowywaÄ‡ i moÅ¼na w nich przechowywaÄ‡ wartoÅ›ci rÃ³Å¼nego typu.</p>

      <section class="article__section">
        <h3 class="article__section__title">var</h3>

        <p class="article__paragraph">Jest to najstarszy sposÃ³b deklarowania zmiennej. Poprzez zadeklarowanie zmiennej rozumiemy nastÄ™pujÄ…cÄ… linijkÄ™ kodu:</p>

        <pre class="article__code">
        <code>
    var myName;
        </code>
      </pre>

        <p class="article__paragraph">WÅ‚aÅ›nie utworzyliÅ›my zmiennÄ… o nazwie <strong class="bold">myName</strong>. W tym momencie przechowuje ona wartoÅ›Ä‡ undefined. Zmienne utworzone w ten sposÃ³b sÄ… dodawane do obiektu globalnego <strong class="bold">window</strong>. Przy pomocy polecenia:</p>

        <pre class="article__code">
        <code>
    console.log(window);
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy wyÅ›wietliÄ‡ jego wszystkie wstÄ™pnie zdefiniowane wÅ‚aÅ›ciwoÅ›ci. Zobaczymy, Å¼e nasza zmienna zostaÅ‚a dodana i moÅ¼emy jÄ… odszukaÄ‡ na tej liÅ›cie.</p>

        <p class="article__paragraph">Tutaj jako ciekawostkÄ™ napiszÄ™, Å¼e na poczÄ…tku zadeklarowaÅ‚em zmiennÄ… o nazwie <strong class="bold">name</strong> a nastÄ™pnie byÅ‚em zdziwiony, Å¼e jej wartoÅ›Ä‡ poczÄ…tkowa wynosiÅ‚a â€œâ€, czyli byÅ‚a pustym ciÄ…giem tekstowym (string). Jak moÅ¼emy zobaczyÄ‡ obiekt <strong class="bold">window</strong> posiada wstÄ™pnie zdefiniowanÄ… wÅ‚aÅ›ciwoÅ›Ä‡ o nazwie <strong class="bold">name</strong>. Zagadka rozwiÄ…zana, wszystko dziaÅ‚a jak naleÅ¼y.</p>

        <strong class="bold">Zasady nadawania nazw zmiennym:</strong>
        <ol class="article__ordered-list">
          <li class="ordered-list__item">nazwa nie moÅ¼e zaczynaÄ‡ siÄ™ od cyfry</li>
          <li class="ordered-list__item">nie moÅ¼e zawieraÄ‡ myÅ›lnika ani krpoki</li>
          <li class="ordered-list__item">nie wolno uÅ¼ywaÄ‡ sÅ‚Ã³w kluczowych jak np.: var, let, const</li>
          <li class="ordered-list__item">wielkoÅ›Ä‡ liter ma znaczenie, zmienna <strong class="bold">name</strong> nie rÃ³wna siÄ™ zmiennej <strong class="bold">Name</strong></li>
          <li class="ordered-list__item">gdy nazwa skÅ‚ada siÄ™ z kilku sÅ‚Ã³w zapisujemy je w notacji wielbÅ‚Ä…dziej (camelCase). Czyli kolejne wyrazy pisane sÄ… Å‚Ä…cznie, rozpoczynajÄ…c kaÅ¼dy nastÄ™pny wielkÄ… literÄ…. np. <strong class="bold">myName</strong></li>
          <li class="ordered-list__item">nazwa powinna wskazywaÄ‡ na rodzaj informacji jaki jest przechowywany w zmiennej</li>
        </ol>

        <p class="article__paragraph">WracajÄ…c do naszego przykÅ‚adu, jeÅ›li chcÄ™ zainicjowaÄ‡ zmiennÄ… myName i przypisaÄ‡ jej wartoÅ›Ä‡, mogÄ™ to zrobiÄ‡ za pomocÄ… znaku rÃ³wnoÅ›ci.</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">MogÄ™ wykonaÄ‡ obie te czynnoÅ›ci w tej samej linijce kodu. NaleÅ¼y jednak pamiÄ™taÄ‡, Å¼e interpreter JS, wykonuje te dwie czynnoÅ›ci oddzielnie najpierw deklaruje zmiennÄ… a dopiero potem przypisuje jej wartoÅ›Ä‡.</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    // ten kod zostanie wykonany jako:

    var myName;
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy przypisaÄ‡ wartoÅ›Ä‡ do zmiennej bez jej deklaracji. Jest to jednak bardzo zÅ‚y pomysÅ‚. W takim przypadku dochodzi bowiem do automatycznego utworzenia zmiennej globalnej w chwili wykonywania danej linii kodu przez interpreter.</p>
      </section>


      <section class="article__section">
        <h3 class="article__section__title">Zakres</h3>

        <p class="article__paragraph">Kolejnym pojÄ™ciem jakie musimy zrozumieÄ‡ jest zakres zmiennej. Zakres oznacza zasiÄ™g w jakim jest widoczna nasza zmienna. W przypadku var jest to zakres lokalny funkcji, w ktÃ³rej zostaÅ‚a zadeklarowana zmienna lub jest to zakres globalny dla zmiennych zadeklarowanych poza funkcjÄ….</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    function getMyFullName() {
      var mySurname = 'Rybacki';
      console.log(myName);
      console.log(mySurname);
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // ReferenceError
    getMyFullName(); // Tomasz Rybacki
        </code>
      </pre>

        <p class="article__paragraph">Zakres lokalny funkcji oznacza, Å¼e zmienna jest widoczna tylko wewnÄ…trz funkcji, w ktÃ³rej zostaÅ‚a zadeklarowana. Natomiast zmienne z zakresu globalnego sÄ… widoczne w caÅ‚ym naszym skrypcie. Dlatego w powyÅ¼szym przykÅ‚adzie funkcja getMyFullName wyÅ›wietli zarÃ³wno moje imiÄ™ jak i nazwisko.</p>

        <p class="article__paragraph">Jednak gdy sprÃ³bujÄ™ dostaÄ‡ siÄ™ do zmiennej mySurname poza funkcjÄ… otrzymam bÅ‚Ä…d ReferenceError. Dzieje siÄ™ tak poniewaÅ¼, reszta mojego skryptu nie widzi tej zmiennej i nie ma pojÄ™cia o jej istnieniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wynoszenie</h3>

        <p class="article__paragraph">Przed wykonaniem naszego kodu interpreter przeszukuje caÅ‚y nasz kod w poszukiwaniu deklaracji zmiennych i funkcji. Odnalezione deklaracje sÄ… nastÄ™pnie wynoszone na poczÄ…tek naszego skryptu, dziÄ™ki temu sÄ… widoczne w caÅ‚ym naszym skrypcie.</p>

        <pre class="article__code">
        <code>
    console.log(myName); // undefined

    // nie otrzymamy w tym momencie bÅ‚Ä™du ReferenceError
    // poniewaÅ¼ zmienna zostaÅ‚a wyniesiona na poczÄ…tek skryptu

    var myName = 'Tomasz';

    // zauwaÅ¼my, Å¼e dopiero w tym momencie zostaÅ‚a przypisana wartoÅ›Ä‡

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">PowyÅ¼szy kod zostanie wykonany przez interpreter w nastÄ™pujÄ…cy sposÃ³b:</p>

        <pre class="article__code">
        <code>
    var myName;

    console.log(myName); // undefined

    myName = 'Tomasz';

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Z tego teÅ¼ powodu powinniÅ›my deklarowaÄ‡ wszystkie nasze zmienne na poczÄ…tku naszego skryptu (zakres globalny) lub funkcji (zakres lokalny). DziÄ™ki temu nasz kod jest czytelniejszy, od razu widzimy, jakie zmienne majÄ… jaki zakres.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Dlaczego nie chcemy deklarowaÄ‡ wszystkich naszych zmiennych globalnie ?</h3>

        <p class="article__paragraph">Nasza aplikacja lub strona internetowa moÅ¼e wspÃ³Å‚pracowaÄ‡ z wieloma bibliotekami napisanymi w JS przez kogoÅ› innego. Wynika z tego, Å¼e ktoÅ› inny mÃ³gÅ‚ by nadaÄ‡ takie same nazwy swoim zmiennym jak zrobiliÅ›my to my w naszym skrypcie. PowstaÅ‚o by wtedy wiele zamieszania, a wyniki dziaÅ‚ania naszej aplikacji byÅ‚y by nieprzewidywalne. Dlatego staramy siÄ™ unikaÄ‡ wspÃ³Å‚dzielenia przestrzeni nazw i gdy tylko to moÅ¼liwe ukrywamy nasze zmienne.</p>
      </section>
    </article>


    <!-- Article 06 -->

    <article class="article">

      <header id="Zmienne_cz2" class="article__header">
        <div class="decor">06</div>
        <h2 class="article__title">Zmienne cz.2</h2>
      </header>

      <p class="article__paragraph">Kontynuujemy temat zmiennych. Dzisiaj przyjrzymy siÄ™ zmiennym wprowadzonym przez ECMAScript 6. SÄ… to sÅ‚owa kluczowe <strong class="bold">let</strong> i <strong class="bold">const</strong>. Dodatkowo zobaczymy w jaki sposÃ³b wartoÅ›ci sÄ… przechowywane w zmiennych.</p>

      <section class="article__section">
        <h3 class="article__section__title">let</h3>

        <p class="article__paragraph">Za pomocÄ… sÅ‚owa <strong class="bold">let</strong> deklarujemy zmiennÄ…, ktÃ³rej zakres jest ograniczony do bloku kodu. Blokiem kodu nazywamy wszystko co zawiera siÄ™ w nawiasach klamrowych { }, moÅ¼emy w ten sposÃ³b zgrupowaÄ‡ ze sobÄ… kilka wyraÅ¼eÅ„.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    var mySurname = 'Rybacki';

    {
      let myName = 'Marcin';
      var mySurname = 'Kazanowski'

      console.log(myName); // Marcin
      console.log(mySurname); // Kazanowski
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // Kazanowski
        </code>
      </pre>

        <p class="article__paragraph">let nie tworzy wÅ‚aÅ›ciwoÅ›ci na obiekcie globalnym</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';
    let mySurname = 'Rybacki';

    console.log(window.myName); // Tomasz
    console.log(window.mySurname); // undefined
        </code>
      </pre>

        <p class="article__paragraph">nie moÅ¼na ponownie zadeklarowaÄ‡ zmiennej o tej samej nazwie w danym zakresie</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myName = 'Marcin'; // SyntaxError
        </code>
      </pre>

        <p class="article__paragraph">nie ulega wynoszeniu â€“ tak zwana tymczasowa martwa strefa (Temporal Dead Zone)</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz'; // ReferenceError
    console.log(typeof(myName)); // ReferenceError
    let myName;
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">const</h3>

        <p class="article__paragraph">Przy uÅ¼yciu sÅ‚owa kluczowego <strong class="bold">const</strong> deklarujemy zmiennÄ…, ktÃ³ra jest staÅ‚Ä…. Co oznacza, Å¼e nie moÅ¼na jej przypisaÄ‡ nowej wartoÅ›ci. Dodatkowo musimy przypisaÄ‡ jej wartoÅ›Ä‡ w chwili deklaracji.</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"> PoniÅ¼sze prÃ³by zakoÅ„czÄ… siÄ™ bÅ‚Ä™dem</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
    const myName = 'Marcin'; // SyntaxError

    const myName; // SyntaxError
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">const</strong> tak samo jak <strong class="bold">let</strong> ma zakres bloku, nie tworzy wÅ‚aÅ›ciwoÅ›ci na obiekcie globalnym, nie moÅ¼na ponownie zadeklarowaÄ‡ zmiennej o tej samej nazwie w danym zakresie i nie ulega wynoszeniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Przechowywanie wartoÅ›ci w zmiennych</h3>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieÄ‡ w jaki sposÃ³b wartoÅ›ci sÄ… przechowywane w zmiennych. OtÃ³Å¼ wartoÅ›ci typu prostego sÄ… przechowywane bezpoÅ›rednio w danej zmiennej. MoÅ¼emy wiÄ™c kopiowaÄ‡ wartoÅ›ci jakie przechowujÄ… do innych zmiennych.</p>

        <pre class="article__code">
        <code>
    let a = 2;
    console.log(a); // 2

    let b = a;
    console.log(b); // 2

    b = b + 2;
    console.log(b); // 4
    console.log(a); // 2
        </code>
      </pre>

        <p class="article__paragraph"> WyobraÅºmy sobie, Å¼e zmienna <strong class="bold">a</strong> jest pudeÅ‚kiem, w ktÃ³rym znajduje siÄ™ cyfra <strong class="bold">2</strong>. W momencie zadeklarowania zmiennej <strong class="bold">b</strong> i przypisania jej wartoÅ›ci <strong class="bold">a</strong> powstaje nowe pudeÅ‚ko z nowÄ… cyfrÄ… <strong class="bold">2</strong>. W efekcie mamy dwa pudeÅ‚ka i dwie oddzielne cyfry <strong class="bold">2</strong>, ktÃ³re moÅ¼emy niezaleÅ¼nie od siebie modyfikowaÄ‡.</p>

        <p class="article__paragraph">Natomiast wartoÅ›ci typu zÅ‚oÅ¼onego sÄ… zapisywane w zmiennych jako referencja do miejsca w pamiÄ™ci, w ktÃ³rej sÄ… przechowywane dane informacje. MoÅ¼emy to sobie wyobraziÄ‡ jako jedno pudeÅ‚ko, w ktÃ³rym znajduje siÄ™ obiekt <strong class="bold">me</strong>. W chwili utworzenia obiektu <strong class="bold">myBrother</strong> nie nastÄ™puje skopiowanie obiektu <strong class="bold">me</strong> i przypisanie go do nowej zmiennej. Powstaje natomiast nowa referencja (czyli taka strzaÅ‚ka wskazujÄ…ca gdzie znajduje siÄ™ obiekt <strong class="bold">me</strong>). Mamy wiÄ™c dwie oddzielne strzaÅ‚ki, ktÃ³re wskazujÄ… te same pudeÅ‚ko. ModyfikujÄ…c wiÄ™c dowolnÄ… ze strzaÅ‚ek, tak naprawdÄ™ modyfikujemy ten sam pojemnik. Dlatego w poniÅ¼szym przykÅ‚adzie zmieniliÅ›my zarÃ³wno moje imiÄ™ jak i imiÄ™ mojego brata.</p>

        <pre class="article__code">
        <code>
    let me = {
      name: 'Tomasz',
      age: 28
    }

    let myBrother = me;

    myBrother.name = 'Daniel';

    console.log(myBrother.name); // Daniel
    console.log(me.name); // Daniel
        </code>
      </pre>

        <p class="article__paragraph">Gdy zadeklarujemy staÅ‚Ä…, ktÃ³ra przechowuje wartoÅ›Ä‡ typu zÅ‚oÅ¼onego jak np. obiekt. MoÅ¼emy zmieniÄ‡ wÅ‚aÅ›ciwoÅ›ci tego obiektu. Nie moÅ¼emy jednak przypisaÄ‡ jej nowej wartoÅ›ci.</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28
    }

    person.name = 'Daniel';
    person.age = 25;

    console.log(person); // {name: Daniel, age: 25}

    person = 'Daniel'; // TypeError
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 07 -->

    <article class="article">

      <header id="Operatory" class="article__header">
        <div class="decor">07</div>
        <h2 class="article__title">Operatory</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Operatory matematyczne</h3>

        <p class="article__paragraph">SÄ… nam dobrze znane z lekcji matematyki. SÄ… to:</p>

        <pre class="article__code">
        <code>
    // dodawanie (+)

    console.log(2 + 3); // 5

    // odejmowanie (-)

    console.log(5 - 4); // 1

    // mnoÅ¼enie (*)

    console.log(2 * 3); // 6

    // dzielenie (/)

    console.log(8 / 2); // 4

    // reszta z dzielenia (%)

    console.log(6 % 5); // 1
        </code>
      </pre>

        <p class="article__paragraph">NowoÅ›ciÄ… dla nas mogÄ… byÄ‡ operatory inkrementacji (++) i dekrementacji (--). Czyli odpowiednio zwiÄ™kszenia i zmniejszenia danej wartoÅ›ci o 1. MoÅ¼emy je stosowaÄ‡ za rÃ³wno z lewej strony jak i prawej strony naszej zmiennej. Gdy wystÄ™pujÄ… z lewej to zmiana wartoÅ›ci nastÄ…pi juÅ¼ w danej linijce kodu, gdy wystÄ™pujÄ… z prawej to zmiana wartoÅ›ci nastÄ…pi w nastÄ™pnej linijce kodu.</p>

        <pre class="article__code">
        <code>
    // inkrementacja (++) - czyli zwiÄ™kszenie wartoÅ›ci o 1

    let someNumber = 2;

    console.log(someNumber++); // 2
    console.log(someNumber); // 3

    someNumber = 2;

    console.log(++someNumber); // 3
    console.log(someNumber); // 3

    // dekrementacja (--) - czyli zmniejszenie wartoÅ›ci o 1

    let otherNumber = 6;

    console.log(otherNumber--); // 6
    console.log(otherNumber); // 5

    otherNumber = 6;

    console.log(--otherNumber); // 5
    console.log(otherNumber); // 5
        </code>
      </pre>

        <p class="article__paragraph">OsobiÅ›cie wolÄ™ ich nie stosowaÄ‡ i uÅ¼ywaÄ‡ operatorÃ³w przypisania <strong class="bold">someNumber += 1</strong> lub <strong class="bold">someNumber -=1</strong>, co wedÅ‚ug mnie jest o wiele bardziej czytelne.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory przypisania</h3>

        <p class="article__paragraph">Znamy juÅ¼ operator rÃ³wna siÄ™ (=) z poprzednich wpisÃ³w. Nie wiemy jednak, Å¼e ma on kilka wariantÃ³w, ktÃ³re pozwalajÄ… najpierw wykonaÄ‡ dziaÅ‚anie a nastÄ™pnie przypisaÄ‡ wynik tego dziaÅ‚ania np. <strong class="bold">someNumber += 1</strong> jest rÃ³wnoznaczne z <strong class="bold">someNumber = someNumber + 1</strong></p>

        <pre class="article__code">
        <code>
    let number = 6;

    // przypisanie dodawania (+=)

    console.log(number += 2); // 8

    // przypisanie odejmowania (-=)

    console.log(number -= 2); // 6

    // przypisanie mnoÅ¼enia

    console.log(number *= 2); // 12

    // przypisanie dzielenia (/=)

    console.log(number /= 2); // 6

    // przypisanie reszty z dzielenia

    console.log(number %= 2); // 0
        </code>
      </pre>
      </section>
      <section class="article__section">
        <h3 class="article__section__title">Operatory porÃ³wnania</h3>

        <p class="article__paragraph">SÅ‚uÅ¼Ä… do sprawdzenia czy obie strony rÃ³wnania sÄ… sobie rÃ³wne czy rÃ³Å¼ne.</p>

        <p class="article__paragraph"><strong class="bold">1 PorÃ³wnanie luÅºne (==)</strong></p>

        <p class="article__paragraph">Zezwala na konwersjÄ™ typÃ³w porÃ³wnywanych wartoÅ›ci. Czyli gdy porÃ³wnujemy ze sobÄ… dwie wartoÅ›ci rÃ³Å¼nych typÃ³w jak np. '2' == 2 otrzymamy wartoÅ›Ä‡ <strong class="bold">true</strong>. Czyli obie wartoÅ›ci sÄ… sobie rÃ³wne, poniewaÅ¼ typ string zostaÅ‚ zamieniony na typ number i dopiero wÃ³wczas dokonano porÃ³wnania 2 == 2, co jak wiemy jest prawdÄ….</p>

        <p class="article__paragraph"><strong class="bold">2 PorÃ³wnanie Å›cisÅ‚e (===)</strong></p>

        <p class="article__paragraph">Nie zezwala na konwersjÄ™ typÃ³w porÃ³wnywanych wartoÅ›ci. Czyli '2' === 2 da nam w wyniku <strong class="bold">false</strong>. DokÅ‚adnie na temat konwersji typÃ³w powiemy w kolejnym wpisie. PozostaÅ‚e operatory porÃ³wnania to:</p>

        <pre class="article__code">
        <code>
    // wiÄ™kszy od (&gt;)

    console.log(4 &gt; 2); // true

    // mniejszy od (&lt;)

    console.log(1 &lt; 3); // true

    // wiÄ™kszy rÃ³wny od (&gt;=)

    console.log(2 &gt;= 2); // true

    // mniejszy rÃ³wny od (&lt;=)

    console.log(6 &lt;= 9); // true

    // nie rÃ³wny - porÃ³wnanie luÅºne (!=)

    console.log(2 != 3); // true

    // nie rÃ³wny - porÃ³wnanie Å›cisÅ‚e (!==)

    console.log('3' !== 3); // true
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory logiczne</h3>

        <p class="article__paragraph">Gdy chcemy podjÄ…Ä‡ bardziej skomplikowanÄ… decyzjÄ™ stosujemy operatory logiczne, ktÃ³re pozwalajÄ… nam sprawdziÄ‡ kilka warunkÃ³w jednoczeÅ›nie.</p>

        <p class="article__paragraph">Warto wiedzieÄ‡, Å¼e operator <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong> zwraca jednÄ… ze sprawdzanych wartoÅ›ci, a poniewaÅ¼ najczÄ™Å›ciej jest stosowany w kontekÅ›cie sprawdzania wartoÅ›ci boolowskich jest nastÄ™pnie konwertowany do wartoÅ›ci <strong class="bold">true</strong> lub <strong class="bold">false</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myAge = 28;
    let isSleeping = true;

    // logiczne i (&amp;&amp;) - zwraca prawdÄ™ gdy oba warunki sÄ… speÅ‚nione

    console.log(myAge &gt;= 18 &amp;&amp; myName === 'Tomasz'); // true
    console.log(myAge &amp;&amp; myName); // Tomasz
    // logiczne lub (||) - zwraca prawdÄ™ gdy jeden z warunkÃ³w jest speÅ‚niony

    console.log(myName === 'Tomasz' || myName === 'Marcin'); // true

    // negacja (!) - odwraca wartoÅ›Ä‡ z prawdy na faÅ‚sz lub na odwrÃ³t

    console.log(!isSleeping); // false
        </code>
      </pre>

        <p class="article__paragraph">WyraÅ¼enia logiczne sÄ… sprawdzane od lewej do prawej strony. Staramy siÄ™ pisaÄ‡ je w taki sposÃ³b Å¼eby warunek, ktÃ³ry ma wiÄ™ksze prawdopodobieÅ„stwo oblaÄ‡ nasz test byÅ‚ umieszczony z lewej strony. PoniewaÅ¼ dalsza czÄ™Å›Ä‡ naszego wyraÅ¼enia nie jest wtedy sprawdzana, tylko od razu otrzymujemy nasz wynik np. dla <strong class="bold">warunek1 &amp;&amp; warunek2</strong> gdy <strong class="bold">warunek1</strong> zwrÃ³ci <strong class="bold">false</strong>, caÅ‚e nasze wyraÅ¼enie zwrÃ³ci wartoÅ›Ä‡ <strong class="bold">false</strong> bez sprawdzania <strong class="bold">warunek2</strong>. Analogicznie dla <strong class="bold">warunek1 || warunek2</strong>, gdy <strong class="bold">warunek1</strong> zwraca <strong class="bold">true</strong>, caÅ‚e wyraÅ¼enie zwraca wartoÅ›Ä‡ <strong class="bold">true</strong>.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Konkatenacja</h3>

        <p class="article__paragraph">Operator (+) ma dodatkowe dziaÅ‚anie w postaci Å‚Ä…czenia ze sobÄ… Å‚aÅ„cuchÃ³w znakÃ³w.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log('Mam na' + ' imiÄ™ ' + myName + '.'); // Mam na imiÄ™ Tomasz.
        </code>
      </pre>

        <p class="article__paragraph">Wraz z wprowadzeniem przez ES6 szablonÃ³w ciÄ…gÃ³w znakÃ³w, zamiast uÅ¼ywaÄ‡ plusa do Å‚Ä…czenia ze sobÄ… Å‚aÅ„cuchÃ³w znakÃ³w korzystamy ze znaku apostrofu (pod klawiszem Esc). Jest to o wiele bardziej czytelniejszy sposÃ³b na umieszczanie tekstu ze zmiennych w generowanych przez nas zdaniach. Zmienne umieszczamy w nawiasach klamrowych poprzedzonych znakiem dolara <strong class="bold">${}</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log(`Mam na imiÄ™ ${myName}.`); // Mam na imiÄ™ Tomasz.
        </code>
      </pre>
      </section>


    </article>


    <!-- Article 08 -->


    <article class="article">

      <header id="Konwersja_typow" class="article__header">
        <div class="decor">08</div>
        <h2 class="article__title">Konwersja typÃ³w</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Czym jest konwersja typÃ³w ?</h3>

        <p class="article__paragraph">Jest to zamiana typu jednej wartoÅ›ci na inny typ. Kyle Simpson uÅ¼ywa okreÅ›lenia <strong class="bold">jawnej konwersji typÃ³w</strong>, gdy w naszym kodzie widaÄ‡, Å¼e konwersja przeprowadzana jest celowo. Oraz okreÅ›lenia <strong class="bold">niejawnej konwersji typÃ³w</strong>, gdy nastÄ™puje ona jako efekt dodatkowy innej przeprowadzanej operacji.</p>

        <p class="article__paragraph">Nie bÄ™dÄ™ dokÅ‚adnie opisywaÅ‚ mechanizmu jej dziaÅ‚ania, Å¼eby nie komplikowaÄ‡. W koÅ„cu z zaÅ‚oÅ¼enia kurs ten jest przeznaczony dla osÃ³b poczÄ…tkujÄ…cych.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Jawna konwersja typÃ³w.</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczby (number) na ciÄ…g znakÃ³w (string) lub na odwrÃ³t.</strong></p>

        <p class="article__paragraph">Najbardziej przejrzystym sposobem dokonania tej konwersji jest uÅ¼ycie wbudowanych funkcji <strong class="bold">String()</strong> i <strong class="bold">Number()</strong>:</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(Number(age)); // 28
    console.log(typeof(Number(age))); // number

    console.log(String(birthday)); // '1989'
    console.log(typeof(String(birthday))); // string
        </code>
      </pre>

        <p class="article__paragraph">Kolejnym jawnym sposobem na zamianÄ™ ciÄ…gu znakÃ³w na liczbÄ™ jest uÅ¼ycie operatora +</p>

        <pre class="article__code">
        <code>
    let age = '28';

    console.log(+age); // 28
    console.log(typeof(+age)); // number
        </code>
      </pre>

        <p class="article__paragraph"> <strong class="bold">- zamiana na typ boolean</strong></p>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieÄ‡ na temat wartoÅ›ci prawdziwych (truthy) i faÅ‚szywych (falsy).</p>

        <p class="article__paragraph">WartoÅ›ciÄ… faÅ‚szywÄ… jest wszystko to co zostaje zamienione na wartoÅ›Ä‡ <strong class="bold">false</strong> podczas konwersji na typ boolean. Jest to krÃ³tka, Å›ciÅ›le okreÅ›lona lista wartoÅ›ci, ktÃ³rÄ… Å‚atwo zapamiÄ™taÄ‡.</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">undefined</li>
          <li class="ordered-list__item">null</li>
          <li class="ordered-list__item">0</li>
          <li class="ordered-list__item">NaN</li>
          <li class="ordered-list__item">'' pusty ciÄ…g znakÃ³w</li>
        </ol>

        <p class="article__paragraph">WartoÅ›ci prawdziwe moÅ¼emy zapamiÄ™taÄ‡ jeszcze proÅ›ciej, sÄ… to wszystkie wartoÅ›ci, ktÃ³re nie znajdujÄ… siÄ™ na powyÅ¼szej liÅ›cie.</p>

        <p class="article__paragraph">Tak samo jak wczeÅ›niej najbardziej czytelnym sposobem na konwersjÄ™ jest uÅ¼ycie wbudowanej funkcji <strong class="bold">Boolean()</strong></p>

        <pre class="article__code">
        <code>
    let object = {};
    console.log(Boolean(object)); // true

    let array = [];
    console.log(Boolean(array)); // true

    let string = '0';
    console.log(Boolean(string)); // true

    let number = 6;
    console.log(Boolean(number)); // true


    let zero = 0;
    console.log(Boolean(zero)); // false

    let something;
    console.log(Boolean(something)); // false

    let empty = null;
    console.log(Boolean(empty)); // false

    let emptyString = '';
    console.log(Boolean(emptyString)); // false

    let invalidNumber = NaN;
    console.log(Boolean(invalidNumber)); // false
        </code>
      </pre>

        <p class="article__paragraph"> Kolejnym sposobem na konwersjÄ™ jest uÅ¼ycie operatora podwÃ³jnej negacji !!</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(!!age); // true
    console.log(typeof(!!age)); // boolean

    console.log(!!birthday); // true
    console.log(typeof(!!birthday)); // boolean
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana wartoÅ›ci zÅ‚oÅ¼onych (obiektÃ³w) na wartoÅ›ci proste</strong></p>

        <p class="article__paragraph">W tym przypadku sprawa siÄ™ nieco komplikuje, poniewaÅ¼ sami musimy okreÅ›liÄ‡ w jaki sposÃ³b chcemy zamieniÄ‡ obiekt na liczbÄ™ lub ciÄ…g znakÃ³w. KaÅ¼dy obiekt dziedziczy metodÄ™ <strong class="bold">toString()</strong> i <strong class="bold">valueOf()</strong>, wÅ‚aÅ›nie te dwie metody okreÅ›lajÄ… w jaki sposÃ³b zostanie dokonana konwersja na <strong class="bold">string</strong> i <strong class="bold">number</strong>.</p>

        <pre class="article__code">
        <code>
    // zostanÄ… wykorzystane domyÅ›lne metody odziedziczone po prototypie

    const person = {
      name: 'Tomasz',
      age: 28
    };

    // funkcje wbudowane Number() i String() wywoÅ‚ujÄ… metody valueOf() i toString()

    console.log(Number(person)); // NaN

    console.log(String(person)); // [object Object]
    console.log(typeof(String(person))); // string

    // moÅ¼emy sami wywoÅ‚aÄ‡ metodÄ™ toString() bezpoÅ›rednio

    console.log(person.toString()); // [object Object]
        </code>
      </pre>

        <p class="article__paragraph">PrzesÅ‚aniamy domyÅ›lne metody i sami decydujemy w jaki sposÃ³b ma nastÄ…piÄ‡ konwersja:</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28,

      valueOf() {
        return this.age;
      },

      toString() {
        return `{name: ${this.name}, age: ${this.age}}`;
      }
    };

    console.log(Number(person)); // 28

    console.log(String(person)); // {name: Tomasz, age: 28}
    console.log(person.toString()); // {name: Tomasz, age: 28}
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Niejawna konwersja typÃ³w</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczb na ciÄ…gi znakÃ³w</strong></p>

        <p class="article__paragraph">JeÅ›li dowolny argument operatora + to wartoÅ›Ä‡ typu string, otrzymamy konkatenacjÄ™ Å‚aÅ„cuchÃ³w znakÃ³w.</p>

        <pre class="article__code">
        <code>
    let birthday = 1989;

    console.log(birthday + ''); // 1989
    console.log(typeof(birthday + '')); // string
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana ciÄ…gÃ³w znakÃ³w na liczby</strong></p>

        <pre class="article__code">
        <code>
    let a = '1';
    let b = 3;

    console.log(a - b); // -2
    console.log(a * b); // 3
    console.log(a / b); // 0.3333333333333333
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- konwersja dowolnej wartoÅ›ci na typ boolean</strong></p>

        <p class="article__paragraph">KaÅ¼da wartoÅ›Ä‡ uÅ¼yta w kontekÅ›cie poniÅ¼szych wyraÅ¼eÅ„ zostanie zamieniona na typ boolean:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">wyraÅ¼enie testowe w instrukcji <strong class="bold">if</strong></li>
          <li class="ordered-list__item">wyraÅ¼enie testowe w nagÅ‚Ã³wku pÄ™tli <strong class="bold">for</strong></li>
          <li class="ordered-list__item">wyraÅ¼enie testowe w pÄ™tlach <strong class="bold">while</strong> i <strong class="bold">do while</strong></li>
          <li class="ordered-list__item">wyraÅ¼enie testowe w operatorze warunkowym</li>
          <li class="ordered-list__item">argument z lewej strony operatorÃ³w <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong></li>
        </ol>


        <p class="article__paragraph">OmÃ³wimy wszystkie te wyraÅ¼enia w kolejnych lekcjach, wiÄ™c nie przejmuj siÄ™, Å¼e nie wiesz jeszcze co oznaczajÄ….</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Korzystanie z rÃ³wnoÅ›ci luÅºnej ==</h3>

        <p class="article__paragraph">WartoÅ›Ä‡ NaN nigdy nie jest rÃ³wna NaN. MoÅ¼emy to sobie wytÅ‚umaczyÄ‡ w nastÄ™pujÄ…cy sposÃ³b.</p>

        <pre class="article__code">
        <code>
    console.log('a' * 2); // NaN
    console.log('b' * 2); // NaN
        </code>
      </pre>

        <p class="article__paragraph">Obie wartoÅ›ci nie sÄ… prawidÅ‚owymi liczbami, ale kaÅ¼da z nich powstaÅ‚a w inny sposÃ³b, dlatego nie sÄ… sobie rÃ³wne. Å»eby sprawdziÄ‡ czy dana wartoÅ›Ä‡ jest NaN, korzystamy z wbudowanej funkcji <strong class="bold">Number.isNaN()</strong>. WaÅ¼ne jest Å¼eby nie pomyliÄ‡ z globalnÄ… funkcjÄ… <strong class="bold">isNaN()</strong>. Jest to starsza wersja tej funkcji, ktÃ³ra wymusza konwersjÄ™ na typ number przed dokonaniem sprawdzenia.</p>

        <pre class="article__code">
        <code>
    console.log(NaN == NaN); // false
    console.log(('a' * 2) == NaN); // false

    console.log(Number.isNaN(NaN)); // true
    console.log(Number.isNaN('a' * 2)); // true

    let a = 'NaN';

    console.log(Number.isNaN(a)); // false
    console.log(isNaN(a)); // true
        </code>
      </pre>

        <p class="article__paragraph">RÃ³wnoÅ›Ä‡ luÅºna ma kilka przypadkÃ³w, ktÃ³re bez znajomoÅ›ci mechanizmu przeprowadzanej konwersji dajÄ… nam zaskakujÄ…ce rezultaty. Dlatego teÅ¼ gdy korzystamy z operatora ==, naleÅ¼y przestrzegaÄ‡ poniÅ¼szych zasad:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">JeÅ›li po ktÃ³rejÅ› ze stron wystÄ™puje wartoÅ›Ä‡ <strong class="bold">true</strong> lub <strong class="bold">false</strong>, nigdy nie uÅ¼ywaj operatora ==</li>
          <li class="ordered-list__item">JeÅ›li po ktÃ³rejÅ› ze stron moÅ¼e wystÄ…piÄ‡ wartoÅ›Ä‡ <strong class="bold">[], â€²â€² lub 0</strong>, nie uÅ¼ywaj operatora ==</li>
        </ol>

        <p class="article__paragraph">Oto lista szalonych wynikÃ³w, ktÃ³rych chcemy uniknÄ…Ä‡ w naszym kodzie:</p>

        <pre class="article__code">
        <code>
    console.log('0' == false); // true
    console.log(false == 0); // true
    console.log(false == ''); // true
    console.log(false == []); // true

    console.log('' == 0); // true
    console.log('' == []); // true
    console.log(0 == []); // true
        </code>
      </pre>

      </section>

    </article>


    <!-- Article 09 -->


    <article class="article">

      <header id="Instrukcje_warunkowe" class="article__header">
        <div class="decor">09</div>
        <h2 class="article__title">Instrukcje warunkowe</h2>
      </header>

      <p class="article__paragraph">Do podejmowania decyzji w kodzie JS sÅ‚uÅ¼Ä… instrukcje warunkowe <strong class="bold">if â€¦ else, switch</strong> oraz operator warunkowy.</p>

      <section class="article__section">
        <h3 class="article__section__title">if â€¦ else</h3>

        <p class="article__paragraph">Nasz warunek jest zamieniany na typ boolean. W zaleÅ¼noÅ›ci od otrzymanego wyniku, wykonamy dany fragment kodu.</p>

        <pre class="article__code">
        <code>
    if (warunek) {
      // jeÅ›li prawda wykonaj ten blok kodu
    } else {
      // jeÅ›li faÅ‚sz wykonaj ten blok kodu
    }
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy w ten sposÃ³b sprawdzaÄ‡ czy dana wartoÅ›Ä‡ istnieje lub czy speÅ‚nia dany warunek np.</p>

        <pre class="article__code">
        <code>
    // sprawdzamy czy obiekt user posiada wÅ‚aÅ›ciwoÅ›Ä‡ myName
    const user = {
      name: 'Tomasz',
      age: 29,
      country: 'Poland'
    };
    if (user.myName) {
      console.log(`WÅ‚aÅ›ciwoÅ›Ä‡ myName zostaÅ‚a odnaleziona, jej wartoÅ›Ä‡ wynosi ${user.myName}`);
    } else {
      console.log('WÅ‚aÅ›ciwoÅ›Ä‡ myName nie zostaÅ‚a odnaleziona w obiekcie user.');
    }
    /*
    Nasz wynik:
    WÅ‚aÅ›ciwoÅ›Ä‡ myName nie zostaÅ‚a odnaleziona w obiekcie user.
    */
    // sprawdzamy czy uÅ¼ytkownik moÅ¼e kupiÄ‡ legalnie piwo w Polsce
    if (user.age &gt;= 18 &amp;&amp; user.country === 'Poland') {
      console.log('MoÅ¼esz legalnie kupiÄ‡ piwo bÄ™dÄ…c w Polsce.');
    } else {
      console.log('W Polsce, nie sprzedajemy alkoholu nieletnim!');
    }
    /*
    Nasz wynik:
    MoÅ¼esz legalnie kupiÄ‡ piwo bÄ™dÄ…c w Polsce
    */
        </code>
      </pre>

        <p class="article__paragraph">JeÅ›li chcemy wykonaÄ‡ tylko jednÄ… linijkÄ™ kodu moÅ¼emy pominÄ…Ä‡ nawiasy klamrowe. Nie jest to zalecana praktyka, ale czasami bywa przydatna i warto o niej wiedzieÄ‡.</p>

        <pre class="article__code">
        <code>
    if (user.name === 'Tomasz') console.log('CzeÅ›Ä‡ Tomasz!'); // CzeÅ›Ä‡ Tomasz!
    if (user.age &gt;= 18) console.log('JesteÅ› peÅ‚noletni.'); // JesteÅ› peÅ‚noletni.
        </code>
      </pre>

        <p class="article__paragraph">Dodatkowo moÅ¼emy zagnieÅ¼dÅ¼aÄ‡ warunki jeden w drugim i sprawdzaÄ‡ kilka warunkÃ³w po sobie</p>

        <pre class="article__code">
        <code>
    if (user.country === 'Poland') {
      if (user.name === 'Janek') {
        if (user.age &gt;= 18) {
          console.log('UÅ¼ytkownik przeszedÅ‚ test prawdziwego Polaka.');
        }
      }
    } else if (user.country === 'Germany') {
      if (user.name === 'Hans') {
        if (user.age &gt;= 18) {
          console.log('UÅ¼ytkownik przeszedÅ‚ test prawdziwego Niemca.');
        }
      }
    } else {
      console.log('UÅ¼ytkownik nie jest ani prawdziwym Polakiem ani prawdziwym Niemcem.');
    }
        </code>
      </pre>

        <p class="article__paragraph">Jak moÅ¼emy zobaczyÄ‡ w powyÅ¼szym przykÅ‚adzie jest to maÅ‚o czytelny sposÃ³b prezentowania logiki naszego kodu. Dodatkowo Å‚atwo w nim popeÅ‚niÄ‡ bÅ‚Ä…d. Dlatego korzystajmy z operatorÃ³w logicznych, Å¼eby nie stosowaÄ‡ zbyt wielu poziomÃ³w zagnieÅ¼dÅ¼enia kodu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">switch</h3>

        <p class="article__paragraph">Gdy chcemy wybraÄ‡ co ma siÄ™ staÄ‡ na podstawie kilku moÅ¼liwych odpowiedzi, korzystamy ze switcha. Jego dziaÅ‚anie polega na sprawdzeniu kaÅ¼dej zdefiniowanej odpowiedzi do naszego warunku. NastÄ™pnie wykonywany jest kod, ktÃ³ry przeszedÅ‚ nasz warunek aÅ¼ do sÅ‚owa kluczowego <strong class="bold">break</strong>. SÅ‚uÅ¼y ono do przerwania dziaÅ‚ania wykonywanego kodu i wyjÅ›cie z bloku kodu <strong class="bold">switch</strong>. Musimy je dodaÄ‡ po kaÅ¼dej moÅ¼liwej odpowiedzi, w przeciwnym razie zostanie wykonany caÅ‚y pozostaÅ‚y kod. Na koÅ„cu instrukcji <strong class="bold">switch</strong> zawsze podajemy przypadek domyÅ›lny (<strong class="bold">default</strong>), ktÃ³ry ma zostaÄ‡ wykonany w przypadku braku dopasowania Å¼adnej z powyÅ¼szych odpowiedzi.</p>

        <pre class="article__code">
        <code>
    switch (warunek) {
      case odpowiedÅº1:
        // wykonaj ten kod gdy odpowiedÅ¼1 jest poprawna
        break;
      case odpowiedÅº2:
        // wykonaj ten kod gdy odpowiedÅ¼2 jest poprawna
        break;
      case odpowiedÅº3:
        // wykonaj ten kod gdy odpowiedÅ¼3 jest poprawna
        break;
      default:
        // gdy Å¼adna z powyÅ¼szych odpowiedzi nie jest wÅ‚aÅ›ciwa, wykonaj ten kod
    }
        </code>
      </pre>

        <strong class="bold">PrzykÅ‚ad</strong>

        <pre class="article__code">
        <code>
    // Jaka jest stolica paÅ„stwa, w ktÃ³rym mieszka nasz uÅ¼ytkownik ?
    switch (user.country) {
      case 'Poland':
        console.log('StolicÄ… paÅ„stwa uÅ¼ytkownika jest Warszawa.');
        break;
      case 'Germany':
        console.log('StolicÄ… paÅ„stwa uÅ¼ytkownika jest Berlin.');
        break;
      case 'Italy':
        console.log('StolicÄ… paÅ„stwa uÅ¼ytkownika jest Rzym.');
        break;
      default:
        console.log('UÅ¼ytkownik mieszka poza EuropÄ….');
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operator warunkowy</h3>

        <p class="article__paragraph">Gdy mamy tylko dwie moÅ¼liwoÅ›ci do wyboru, moÅ¼emy skrÃ³ciÄ‡ nasz kod, przez zastosowanie operatora warunkowego (nazywanego teÅ¼ operatorem trÃ³jkowym).</p>

        <pre class="article__code">
        <code>
    (warunek) ? (wykonaj gdy prawda) : (wykonaj gdy faÅ‚sz)
        </code>
      </pre>
      </section>

      <strong class="bold">PrzykÅ‚ad</strong>

      <pre class="article__code">
        <code>
    let a = 8;
    let b = 5;
    const biggerNumber = (a &gt;= b) ? a : b;
    console.log(biggerNumber); // 8
        </code>
      </pre>

    </article>


    <!-- Article 10 -->


    <article class="article">

      <header id="Tablice" class="article__header">
        <div class="decor">10</div>
        <h2 class="article__title">Tablice</h2>
      </header>

      <p class="article__paragraph">Tablice sÄ… specjalnym typem obiektu w JS. MajÄ… wiÄ™c dostÄ™p do wielu metod pozwalajÄ…cych na manipulowanie nimi. W tym wpisie nie bÄ™dÄ™ omawiaÅ‚ wszystkich dostÄ™pnych dla nich metod. SkupiÄ™ siÄ™ na podstawie ich dziaÅ‚ania. Tablice sÅ‚uÅ¼Ä… do wygodnego przechowywania wiÄ™kszych iloÅ›ci danych typu prostego.</p>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie tablic</h3>

        <p class="article__paragraph">TablicÄ™ moÅ¼emy utworzyÄ‡ za pomocÄ… literaÅ‚u tablicy.</p>

        <pre class="article__code">
        <code>
    // tworzymy pustÄ… tablicÄ™
    const emptyArray = [];
    // tworzymy tablicÄ™ przechowujÄ…cÄ… imiona
    const namesArray = ['Tomasz', 'Daniel', 'Mateusz'];
        </code>
      </pre>

        <p class="article__paragraph">Drugim sposobem na stworzenie tablicy jest uÅ¼ycie konstruktora <strong class="bold">new</strong>.</p>

        <pre class="article__code">
        <code>
    // tworzymy pustÄ… tablicÄ™
    const emptyArray = new Array();
    // tworzymy tablicÄ™ przechowujÄ…cÄ… imiona
    const namesArray = new Array('Tomasz', 'Daniel', 'Mateusz');
    // tworzymy pustÄ… tablicÄ™ o dÅ‚ugoÅ›ci 10 elementÃ³w
    const undefinedElementsArray = new Array(10);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WÅ‚aÅ›ciwoÅ›Ä‡ length</h3>

        <p class="article__paragraph">Opisuje ona dÅ‚ugoÅ›Ä‡ tablicy, czyli liczbÄ™ elementÃ³w jakie siÄ™ w niej znajdujÄ…. NaleÅ¼y pamiÄ™taÄ‡, Å¼e w tablicy mogÄ… znajdowaÄ‡ siÄ™ puste miejsca.</p>

        <pre class="article__code">
        <code>
    // w tablicy znajdujÄ… siÄ™ 3 imiona i jedno puste miejsce zawierajÄ…ce wartoÅ›Ä‡ undefined
    const namesArray = ['Tomasz', 'Daniel', , 'Mateusz'];
    console.log(namesArray.length); // 4
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">DostÄ™p do przechowywanych wartoÅ›ci</h3>

        <p class="article__paragraph">Wszystkie wartoÅ›ci w tablicy posiadajÄ… swÃ³j indeks, czyli liczbÄ™, ktÃ³ra okreÅ›la poÅ‚oÅ¼enie danej wartoÅ›ci w tablicy. Indeksy zaczynamy liczyÄ‡ od zera. Dla tablicy o dÅ‚ugoÅ›ci 3 liczymy (0, 1, 2). Aby pobraÄ‡ wartoÅ›Ä‡ z tablicy wpisujemy jej nazwÄ™ oraz indeks w nawiasie kwadratowym. <strong class="bold">nazwa[indeks]</strong></p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">pierwszy element w tablicy ma zawsze indeks zero: <strong class="bold">nazwa[0]</strong></li>
          <li class="unordered-list__item">ostatni element w tablicy ma indeks: <strong class="bold">nazwa[nazwa.length â€“ 1]</strong></li>
        </ul>

        <pre class="article__code">
        <code>
    // pobieranie wartoÅ›ci z tablicy
    const namesArray = ['Tomasz', 'Daniel', , 'Mateusz'];
    console.log(namesArray[0]); // 'Tomasz'
    console.log(namesArray[1]); // 'Daniel'
    console.log(namesArray[2]); // undefined
    console.log(namesArray[namesArray.length - 1]); // 'Mateusz'
    // nadpisywanie wartoÅ›ci w tablicy
    namesArray[2] = 'Przemek';
    console.log(namesArray); // ["Tomasz", "Daniel", "Przemek", "Mateusz"]
    // usuwanie wartoÅ›ci z tablicy
    delete namesArray[0];
    console.log(namesArray); // [empty, "Daniel", "Przemek", "Mateusz"]
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy najpierw utworzyÄ‡ pustÄ… tablicÄ™ a nastÄ™pnie dodawaÄ‡ do niej wartoÅ›ci za pomocÄ… indeksÃ³w. W takim przypadku musimy byÄ‡ ostroÅ¼ni, poniewaÅ¼ moÅ¼emy utworzyÄ‡ wiele pustych miejsc w naszej tablicy.</p>

        <pre class="article__code">
        <code>
    const animalsArray = [];
    animalsArray[2] = 'cat';
    animalsArray[22] = 'dog';
    console.log(animalsArray); // [empty Ã— 2, "cat", empty Ã— 19, "dog"]
    console.log(animalsArray.length); // 23
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tablice wielowymiarowe</h3>

        <p class="article__paragraph">W tablicy moÅ¼emy przechowywaÄ‡ dowolne wartoÅ›ci, nie muszÄ… to byÄ‡ jedynie wartoÅ›ci typu prostego. MoÅ¼emy w nich umieszczaÄ‡ teÅ¼ obiekty i inne tablice. Gdy tablica zawiera inne tablice jest nazywana tablicÄ… wielowymiarowÄ…. Aby dostaÄ‡ siÄ™ do jej wartoÅ›ci tworzymy ciÄ…g nawiasÃ³w, ktÃ³re okreÅ›lajÄ… kolejno indeksy danej tablicy. <strong class="bold">nazwa[indeks tablicy nr 1][indeks tablicy nr 2][indeks tablicy nr 3] itd.</strong></p>

        <pre class="article__code">
        <code>
    const multidimensionalArray = [['rekin', 'sum'], ['delfin', 'wieloryb'], ['zÃ³Å‚w', 'homar']];
    console.log(multidimensionalArray[0][1]); // 'sum'
    console.log(multidimensionalArray[1][0]); // 'delfin'
    console.log(multidimensionalArray[2][0]); // 'Å¼Ã³Å‚w'
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla forEach</h3>
      </section>

      <p class="article__paragraph">JedynÄ… metodÄ… o jakiej chcÄ™ wspomnieÄ‡ w tym wpisie jest pÄ™tla forEach, poniewaÅ¼ jest to temat powiÄ…zany z tym co bÄ™dzie w kolejnym wpisie, czyli dokÅ‚adnym omÃ³wieniem pÄ™tli w JavaScrpit.</p>

      <p class="article__paragraph">PiszÄ…c w skrÃ³cie, pÄ™tle pozwalajÄ… nam na wykonanie danego fragmentu kodu wielokrotnie, dopÃ³ki jest speÅ‚niony okreÅ›lony przez nas warunek. PÄ™tle sÄ… czÄ™sto wykorzystywane do przeglÄ…dania i manipulowania wartoÅ›ciami w tablicach.</p>

      <p class="article__paragraph">CechÄ… wyrÃ³Å¼niajÄ…cÄ… tÄ… metodÄ™ jest fakt, Å¼e pÄ™tla ta zostanie wykonana tylko dla tych elementÃ³w, ktÃ³re majÄ… przypisanÄ… wartoÅ›Ä‡. Wszystkie puste miejsca w tablicy sÄ… pomijane, mimo Å¼e ich wartoÅ›Ä‡ rÃ³wnieÅ¼ wynosi <strong class="bold">undefined</strong>.</p>

      <pre class="article__code">
        <code>
    const numbersArray = [0, 1, undefined, null, 4, , 6, 7, , 9];
    numbersArray.forEach((num) =&gt; {
      console.log(num * 2);
    });
    /*
    otrzymamy:
    0
    2
    NaN
    0
    8
    12
    14
    18
    */
    console.log(numbersArray[2]); // undefined
    console.log(numbersArray[5]); // undefined
        </code>
      </pre>

    </article>


    <!-- Article 11 -->


    <article class="article">

      <header id="Podstawowe_petle" class="article__header">
        <div class="decor">11</div>
        <h2 class="article__title">Podstawowe pÄ™tle</h2>
      </header>

      <p class="article__paragraph">Gdy chcemy wykonaÄ‡ dany kawaÅ‚ek kodu wielokrotnie, stosujemy w tym celu pÄ™tle. Pozwala nam to na pisanie krÃ³tszego i bardziej czytelnego kodu, ktÃ³ry jest Å‚atwiejszy w utrzymaniu i debugowaniu. W tym wpisie przyjrzymy siÄ™ trzem podstawowym pÄ™tlom dostÄ™pnym w JS. SÄ… to pÄ™tle: <strong class="bold">for, while, doâ€¦while</strong>.</p>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla for</h3>

        <pre class="article__code">
        <code>
    for ([wyraÅ¼enieInicjalizacji]; [warunek]; [wyraÅ¼enieInkrementacji]) {
        Instrukcja
     }
        </code>
      </pre>

        <p class="article__paragraph">ZaÅ‚Ã³Å¼my, Å¼e nie moÅ¼emy spaÄ‡ i Å›piewamy sobie w myÅ›lach piosenkÄ™ <a class="article__link" href="https://www.youtube.com/watch?v=aI3k7X78-KY" target="_blank">Manifest DzieciÄ™cy</a> â€“ Witka Muzyka Ulicy. Za pomocÄ… kodu odliczanie z tej piosenki moÅ¼emy napisaÄ‡ tak:</p>

        <pre class="article__code">
        <code>
    for (let i = 1; i  &lt; 11; i += 1) {
      console.log('i', i);
    }

    /*
     Co da nam w wyniku:

      i 1
      i 2
      i 3
      i 4
      i 5
      i 6
      i 7
      i 8
      i 9
      i 10
    */
        </code>
      </pre>

        <p class="article__paragraph">Jest ogÃ³lnie przyjÄ™tym zwyczajem, Å¼e w pÄ™tlach wykorzystujemy zmienne o nazwie <strong class="bold">i</strong> lub <strong class="bold">j</strong> do iteracji. Jak moÅ¼emy zauwaÅ¼yÄ‡ najpierw inicjalizujemy naszÄ… zmiennÄ… <strong class="bold">i</strong> i przypisujemy jej wartoÅ›Ä‡ poczÄ…tkowÄ…, w naszym przypadku jest to liczba 1.</p>

        <pre class="article__code">
        <code>
    for (let i = 1; --; --) {
      --
    }
        </code>
      </pre>

        <p class="article__paragraph">NastÄ™pnie jest sprawdzany warunek, jeÅ›li jego wynik da nam wartoÅ›Ä‡ <strong class="bold">true</strong> wykonywany jest kod wewnÄ…trz nawiasÃ³w klamrowych (blok kodu pÄ™tli).</p>

        <pre class="article__code">
        <code>
    for (--; i &lt; 11; --) {
      console.log('i', i);
    }
        </code>
      </pre>

        <p class="article__paragraph">Ostatnim krokiem jest zwiÄ™kszenie lub zmniejszenie wartoÅ›ci zmiennej <strong class="bold">i</strong>.</p>

        <pre class="article__code">
        <code>
    for (--; --; i += 1) {
      --
    }
        </code>
      </pre>

        <p class="article__paragraph">CaÅ‚a procedura powtarza siÄ™ ponownie aÅ¼ do momentu gdy warunek zwrÃ³ci nam wartoÅ›Ä‡ <strong class="bold">false</strong>. NaleÅ¼y uwaÅ¼aÄ‡ Å¼eby nie utworzyÄ‡ pÄ™tli dziaÅ‚ajÄ…cej w nieskoÅ„czonoÅ›Ä‡. PoniewaÅ¼ nasza przeglÄ…darka siÄ™ zawiesi, uÅ¼ycie procesora skoczy do 100% i pozostanie nam jedynie <strong class="bold">ctrl + alt + del</strong>, Å¼eby wyjÅ›Ä‡ z tej patowej sytuacji ğŸ™‚</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla while</h3>

        <pre class="article__code">
        <code>
    while (warunek) {
         instrukcja
     }
        </code>
      </pre>

        <p class="article__paragraph">DziaÅ‚a podobnie do pÄ™tli for. TeÅ¼ jest wykonywana dopÃ³ki jest speÅ‚niony jej warunek. Tym razem jednak bardziej musimy pamiÄ™taÄ‡ o zmianie jej licznika, poniewaÅ¼ zmieniamy go w jej wnÄ™trzu.</p>

        <pre class="article__code">
        <code>
    let i = 1;
    while (i &lt; 11) {
        console.log('i', i);
        i += 1;
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla doâ€¦while</h3>

        <pre class="article__code">
        <code>
    do {
        instrukcja
     }
    while (warunek);
        </code>
      </pre>

        <p class="article__paragraph">Jej cechÄ… charakterystycznÄ… jest to, Å¼e zawsze zostanie wykonana przynajmniej raz, poniewaÅ¼ jej warunek jest sprawdzany na koÅ„cu za jej blokiem kodu.</p>

        <pre class="article__code">
        <code>
    let i = 1;
    do {
      console.log('i', i);
      i += 1;
    } while (i &lt; 11);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tle a tablice</h3>

        <p class="article__paragraph">Bardzo czÄ™sto pÄ™tle sÄ… wykorzystywane do dziaÅ‚ania na tablicach. WracajÄ…c do naszej piosenki, tym razem chcemy wypisywaÄ‡ sÅ‚owa zamiast cyfr w jej refrenie. MoÅ¼emy to zrobiÄ‡ w nastÄ™pujÄ…cy sposÃ³b:</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡', 'siedem', 'osiem', 'dziewiÄ™Ä‡', 'dziesiÄ™Ä‡']
    for (let i = 0; i &lt; words.length; i += 1) {
      console.log('i', words[i]);
    }
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e zaczynamy od 0, poniewaÅ¼ jak wiemy z poprzedniej lekcji elementy w tablicach sÄ… indeksowane od 0. NastÄ™pnie chcemy iterowaÄ‡ przez wszystkie elementy jakie siÄ™ w niej znajdujÄ…, w tym celu wykorzystujemy wÅ‚aÅ›ciwoÅ›Ä‡ <strong class="bold">length</strong> aby pobraÄ‡ dÅ‚ugoÅ›Ä‡ tablicy. Oto nasz wynik:</p>

        <pre class="article__code">
        <code>
    /*
        i raz
        i dwa
        i trzy
        i cztery
        i piÄ™Ä‡
        i szeÅ›Ä‡
        i siedem
        i osiem
        i dziewiÄ™Ä‡
        i dziesiÄ™Ä‡
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">break</h3>

        <p class="article__paragraph">Do przerwania wykonywania pÄ™tli w trakcie jej dziaÅ‚ania sÅ‚uÅ¼y sÅ‚owo kluczowe <strong class="bold">break</strong>. ZaÅ‚Ã³Å¼my, Å¼e szukamy w tablicy danej wartoÅ›ci i gdy tylko jÄ… znajdziemy chcemy przerwaÄ‡ wykonywanie naszej pÄ™tli, Å¼eby nie marnowaÄ‡ czasu na czekanie aÅ¼ sprawdzi wszystkie jej elementy. Å»eby byÅ‚o jeszcze ciekawiej tym razem zaczniemy pÄ™tle od koÅ„ca tablicy i bÄ™dziemy szli w kierunku jej pierwszego elementu.</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡', 'siedem', 'osiem', 'dziewiÄ™Ä‡', 'dziesiÄ™Ä‡'];
    for (let i = words.length - 1; i &gt;= 0; i -= 1) {
      if (words[i] === 'osiem') {
        break;
      }
      console.log('i', words[i]);
    }
    /*
    Nasz wynik:
    i dziesiÄ™Ä‡
    i dziewiÄ™Ä‡
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">continue</h3>

        <p class="article__paragraph">Do pomijania wybranych iteracji sÅ‚uÅ¼y sÅ‚owo kluczowe continue. Tym razem jesteÅ›my pijani podczas Å›piewania naszej piosenki i mamy problemy z liczeniem wstecz. Przez co umknÄ™Å‚o nam kilka liczb ğŸ™‚</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡', 'siedem', 'osiem', 'dziewiÄ™Ä‡', 'dziesiÄ™Ä‡'];
    for (let i = words.length - 1; i &gt;= 0; i -= 1) {
      if (words[i] === 'osiem' || words[i] === 'trzy' || words[i] === 'piÄ™Ä‡') {
        continue;
      }
      console.log('i', words[i]);
    }
    /*
    i dziesiÄ™Ä‡
    i dziewiÄ™Ä‡
    i siedem
    i szeÅ›Ä‡
    i cztery
    i dwa
    i raz
    */
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla w pÄ™tli</h3>

        <p class="article__paragraph">MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e jedna pÄ™tla nam nie wystarczy i bÄ™dziemy potrzebowali zagnieÅ¼dÅ¼aÄ‡ jednÄ… pÄ™tle w drugiej. W takiej sytuacji koniecznie trzeba pamiÄ™taÄ‡ o zastosowaniu rÃ³Å¼nych zmiennych dla kaÅ¼dej z pÄ™tli. W pierwszej pÄ™tli korzystamy z iteratora o nazwie <strong class="bold">i</strong>, a w drugiej z iteratora o nazwie <strong class="bold">j</strong>.</p>

        <pre class="article__code">
        <code>
    const arrayOfArrays = [['raz', 'dwa', 'trzy'], ['cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡'], ['siedem', 'osiem', 'dziewiÄ™Ä‡']];
    for (let i = 0; i &lt; arrayOfArrays.length; i += 1) {
      console.log('---------')
      for (let j = 0; j &lt; arrayOfArrays[0].length; j += 1) {
        console.log(arrayOfArrays[i][j]);
      }
    }
    /*
    Nasz wynik:
    ---------
    raz
    dwa
    trzy
    ---------
    cztery
    piÄ™Ä‡
    szeÅ›Ä‡
    ---------
    siedem
    osiem
    dziewiÄ™Ä‡
    */
        </code>
      </pre>
      </section>

    </article>


    <!-- Article 12 -->


    <article class="article">

      <header id="Funkcje_cz1" class="article__header">
        <div class="decor">12</div>
        <h2 class="article__title">Funkcje cz.1</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Czym sÄ… funkcje ?</h3>

        <p class="article__paragraph">Funkcje moÅ¼emy sobie wyobraziÄ‡ jako maszyny do przetwarzania, jako przykÅ‚ad weÅºmy drukarkÄ™. Å»eby coÅ› wydrukowaÄ‡ musimy wÅ‚oÅ¼yÄ‡ do drukarki papier, toner i przesÅ‚aÄ‡ informacje, ktÃ³re chcemy przenieÅ›Ä‡ na papier. W rezultacie otrzymujemy zadrukowane strony naszego dokumentu. Tak samo jest z funkcjami, wkÅ‚adamy do nich argumenty. One przetwarzajÄ… je w swoim wnÄ™trzu i zwracajÄ… nam jakiÅ› wynik.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Po co sÄ… funkcje ?</h3>

        <p class="article__paragraph">DziÄ™ki nim mamy moÅ¼liwoÅ›Ä‡ wielokrotnego uÅ¼ywania tego samego fragmentu kodu bez koniecznoÅ›ci powtarzania go. Pozwala to nam na Å‚atwiejsze dokonywanie zmian w naszym programie, znajdowanie bÅ‚Ä™dÃ³w i znacznie skraca dÅ‚ugoÅ›Ä‡ kodu. W programowaniu istnieje zasada DRY ( Donâ€™t Repeat Yourself ) czyli nie powtarzaj siÄ™ i warto jÄ… stosowaÄ‡.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Deklaracja funkcji</h3>

        <pre class="article__code">
        <code>
    function nazwa(parametry) {
        ciaÅ‚o funkcji â€“ dzieje siÄ™ tu caÅ‚a logika i przetwarzanie parametrÃ³w
        return  zwracany przez funkcjÄ™ wynik
    }
        </code>
      </pre>

        <p class="article__paragraph">Jest to pierwszy ze sposobÃ³w na utworzenie funkcji. PowstaÅ‚a w ten sposÃ³b funkcja ulega mechanizmowi wynoszenia, czyli jest przenoszona na poczÄ…tek skryptu, przez co jest dostÄ™pna w caÅ‚ym naszym programie. Sztampowym przykÅ‚adem jest funkcja, ktÃ³ra sumuje dwie liczby.</p>

        <pre class="article__code">
        <code>
    function sum(a, b) {
      return a + b;
    }

    console.log(sum(2, 3)); // 5
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WyraÅ¼enie funkcyjne</h3>

        <p class="article__paragraph">Drugim sposobem stworzenia funkcji jest wyraÅ¼enie funkcyjne, czyli utworzenie zmiennej, ktÃ³ra bÄ™dzie przechowywaÅ‚a referencjÄ™ do funkcji (strzaÅ‚ka wskazujÄ…ca, gdzie znajduje siÄ™ nasza funkcja). W odrÃ³Å¼nieniu od deklaracji funkcji, funkcje stworzone w ten sposÃ³b nie sÄ… wynoszone, wiÄ™c moÅ¼emy ich uÅ¼ywaÄ‡ tylko w tej czÄ™Å›ci naszego skryptu, ktÃ³ra wystÄ™puje za miejscem ich utworzenia.</p>

        <pre class="article__code">
        <code>
    const sum = function (a, b) {
      return a + b;
    };

    console.log(sum(2, 3)); // 5
        </code>
      </pre>

        <p class="article__paragraph">PoniÅ¼szy kod generuje bÅ‚Ä…d.</p>

        <pre class="article__code">
        <code>
    console.log(sum(2, 3)); // 5

    const sum = function (a, b) {
      return a + b;
    };
    // Uncaught ReferenceError: sum is not defined
        </code>
      </pre>

        <p class="article__paragraph">Jak moÅ¼emy zauwaÅ¼yÄ‡ funkcja ta nie ma swojej nazwy, dlatego nazywana jest funkcjÄ… anonimowÄ…. OdwoÅ‚ujemy siÄ™ do niej za poÅ›rednictwem nazwy naszej zmiennej. MoÅ¼emy jednak nadaÄ‡ jej nazwÄ™ jeÅ›li chcemy.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WywoÅ‚ywanie funkcji</h3>

        <p class="article__paragraph">Aby wywoÅ‚aÄ‡ funkcjÄ™ wpisujemy jej nazwÄ™ oraz parÄ™ nawiasÃ³w <strong class="bold">nazwa()</strong>, w tym momencie nasza funkcja zostaje uruchomiona. KontynuujÄ…c nasz przykÅ‚ad z funkcjÄ… sum. MoÅ¼emy jÄ… wywoÅ‚aÄ‡ bez przekazania argumentÃ³w do jej wnÄ™trza.</p>

        <pre class="article__code">
        <code>
    console.log(sum()); // NaN
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w rezultacie otrzymamy Not a Number. PoniewaÅ¼ nie przekazaliÅ›my do niej Å¼adnych argumentÃ³w, wartoÅ›Ä‡ a i b wynosi <strong class="bold">undefined</strong>. DodajÄ…c obie te wartoÅ›ci do siebie otrzymamy <strong class="bold">NaN</strong>, czyli nie prawidÅ‚owÄ… wartoÅ›Ä‡ liczbowÄ….</p>

        <p class="article__paragraph">MoÅ¼emy siÄ™ przed tym zabezpieczyÄ‡ przypisujÄ…c domyÅ›lne wartoÅ›ci parametrÃ³w. Wtedy za kaÅ¼dym razem gdy, ktÃ³ryÅ› z nich zostanie pominiÄ™ty w wywoÅ‚aniu, zostanie uÅ¼yta jego wartoÅ›Ä‡ domyÅ›lna.</p>

        <p class="article__paragraph">Pierwszy ze sposobÃ³w takiego zabezpieczenia wykorzystuje ES6.</p>

        <pre class="article__code">
        <code>
    function sum(a = 0, b = 0) {
      return a + b;
    }
    console.log(sum()); // 0
        </code>
      </pre>

        <p class="article__paragraph"> Nim wprowadzono ES6 stosowano poniÅ¼szÄ… metodÄ™:</p>

        <pre class="article__code">
        <code>
    function sum(a, b) {
      a = a || 0;
      b = b || 0;
      return a + b;
    }
    console.log(sum()); // 0
        </code>
      </pre>

        <p class="article__paragraph">Gdy nie przekaÅ¼emy Å¼adnego argumentu wartoÅ›Ä‡ a wynosi <strong class="bold">undefined</strong>, nastÄ™pnie operator logiczny (lub) sprawdza wartoÅ›Ä‡ po jego lewej stronie, poniewaÅ¼ jest to wartoÅ›Ä‡ faÅ‚szywa wybiera wartoÅ›Ä‡ po swojej prawej stronie i przypisuje jÄ… do zmiennej <strong class="bold">a</strong>. W tym momencie <strong class="bold">a = 0</strong>.</p>

        <p class="article__paragraph">MoÅ¼emy teÅ¼ przekazaÄ‡ do funkcji wiÄ™cej argumentÃ³w niÅ¼ wymaga przez niÄ… iloÅ›Ä‡ parametrÃ³w. Argumentem jest to co wkÅ‚adamy do funkcji w momencie jej wywoÅ‚ania np. <strong class="bold">sum(2, 3)</strong>, argumenty to liczby <strong class="bold">2</strong> i <strong class="bold">3</strong>. Parametrem natomiast jest nazwa zmiennej wykorzystywana do operacji wewnÄ…trz funkcji, czyli <strong class="bold">a</strong> i <strong class="bold">b</strong> w naszym przykÅ‚adzie. Gdy przekaÅ¼emy wiÄ™kszÄ… iloÅ›Ä‡ argumentÃ³w do funkcji niÅ¼ wymagana, wszystkie dodatkowe sÄ… ignorowane.</p>

        <pre class="article__code">
        <code>
    console.log(sum(2, 3, 5, 66)); // 5
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">return</h3>

        <p class="article__paragraph">Aby zwrÃ³ciÄ‡ wartoÅ›Ä‡ z funkcji wykorzystujemy sÅ‚owo kluczowe return. KoÅ„czy ono dziaÅ‚anie funkcji i zwraca wartoÅ›Ä‡. W funkcji moÅ¼e wystÄ™powaÄ‡ kilka sÅ‚Ã³w return, zawsze jednak dziaÅ‚anie funkcji jest koÅ„czone w chwili dotarcia do pierwszego z nich.</p>

        <pre class="article__code">
        <code>
    function checkAge(age) {
      if (age &gt;= 18) {
        return 'MoÅ¼esz wejÅ›Ä‡ do klubu.';
      }
      return 'MÅ‚odocianym wstÄ™p wzbroniony!';
    }
    console.log(checkAge(29)); // MoÅ¼esz wejÅ›Ä‡ do klubu.
        </code>
      </pre>

        <p class="article__paragraph">JeÅ›li pominiemy sÅ‚owo <strong class="bold">return</strong>, funkcja zwrÃ³ci wartoÅ›Ä‡ <strong class="bold">undefined</strong>. PrzewaÅ¼nie chcemy przechowaÄ‡ wynik dziaÅ‚a naszej funkcji w jakiejÅ› zmiennej aby mÃ³c go pÃ³Åºniej wykorzystaÄ‡.</p>

        <pre class="article__code">
        <code>
    let guest = checkAge(16);
    console.log(guest); // MÅ‚odocianym wstÄ™p wzbroniony!

    function printUserName(name) {
      console.log(`Mam na imiÄ™ ${name}`);
    }

    let printMyName = printUserName('Tomasz') // Mam na imiÄ™ Tomasz
    console.log(printMyName); // undefined
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 13 -->


    <article class="article">

      <header id="Funkcje_cz2" class="article__header">
        <div class="decor">13</div>
        <h2 class="article__title">Funkcje cz.2</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Zakres lokalny funkcji</h3>

        <p class="article__paragraph">Z wczeÅ›niejszego wpisu na temat zmiennej var, wiemy, Å¼e jej zakresem moÅ¼e byÄ‡ zakres lokalny funkcji. Oznacza to, Å¼e moÅ¼emy tworzyÄ‡ zmienne, ktÃ³re sÄ… zamkniÄ™te w ciele naszej funkcji i nie da siÄ™ do nich odwoÅ‚aÄ‡ spoza niej. Za kaÅ¼dym razem gdy dana funkcja jest wywoÅ‚ywana, zostaje utworzona zmienna w niej zadeklarowana, ktÃ³ra jest usuwana po zakoÅ„czeniu jej dziaÅ‚ania przez mechanizm usuwania nieuÅ¼ytkÃ³w aby zwolniÄ‡ miejsce w pamiÄ™ci.</p>

        <pre class="article__code">
        <code>
    function defineMyName() {
      let myName = 'Tomasz';
    }

    defineMyName();
    console.log(myMame); // Uncaught ReferenceError: myMame is not defined
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Zakres zagnieÅ¼dÅ¼ony</h3>

        <p class="article__paragraph">Gdy mamy kilka funkcji zagnieÅ¼dÅ¼onych jedna w drugiej. Najpierw silnik JS sprawdza bieÅ¼Ä…cy zakres leksykalny funkcji, wykonywanego kodu. JeÅ›li zmienna nie zostanie w nim odnaleziona, sprawdza kolejny zakres zewnÄ™trzny i kontynuuje sprawdzanie tak dÅ‚ugo aÅ¼ znajdzie szukanÄ… zmiennÄ… lub dotrze do zakresu globalnego. W tym momencie jeÅ›li zmienna nie zostaÅ‚a odnaleziona zgÅ‚aszany jest bÅ‚Ä…d.</p>

        <pre class="article__code">
        <code>
    let someString = null;
    let anotherString = null;

    function globalFunction() {
      let someString = 'Hello';

      function internalFunction1() {
        let anotherString = 'Word';
        console.group('internalFunction1');
        console.log(someString);
        console.log(anotherString);
        console.groupEnd();
      }

      function internalFunction2() {
        console.group('internalFunction2');
        console.log(someString);
        console.log(anotherString);
        console.groupEnd();
      }

      console.group('globalFunction');
      console.log(someString);
      console.log(anotherString);
      console.groupEnd();
      internalFunction1();
      internalFunction2();
    }

    globalFunction();

    /*
    globalFunction
      Hello
      null
    internalFunction1
      Hello
      Word
    internalFunction2
      Hello
      null
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">DomkniÄ™cia</h3>

        <p class="article__paragraph">Funkcje w JavaScript sÄ… wartoÅ›ciami pierwszej klasy co oznacza, Å¼e mogÄ… byÄ‡ przekazywane i zwracane przez inne funkcje.</p>

        <p class="article__paragraph">DomkniÄ™cia pozwalajÄ… nam na dostÄ™p do zmiennych zadeklarowanych w zakresie leksykalnym funkcji nawet gdy wywoÅ‚amy danÄ… funkcjÄ™ poza jej zakresem leksykalnym.</p>

        <pre class="article__code">
        <code>
    function globalFunction() {
      let myName = 'Tomasz';

      function internalFunction() {
        return `CzeÅ›Ä‡, ${myName}!`;
      }
      return internalFunction;
    }

    let sayHello = globalFunction();
    console.log(sayHello()); // CzeÅ›Ä‡, Tomasz!
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyÅ¼szym przykÅ‚adzie funkcji <strong class="bold">sayHello</strong> przypisujemy wynik wykonania funkcji <strong class="bold">globalFunction</strong>. PoniewaÅ¼ <strong class="bold">globalFunction</strong> zwraca nam funkcjÄ™ wewnÄ™trznÄ… <strong class="bold">internalFunction</strong>. Zatem funkcja <strong class="bold">sayHello</strong> jest referencjÄ… do funkcji <strong class="bold">internalFunction</strong>.</p>

        <p class="article__paragraph">W tym momencie moÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ wewnÄ™trznÄ… za pomocÄ… <strong class="bold">sayHello()</strong>, poza jej zakresem leksykalnym, mimo, Å¼e funkcja <strong class="bold">globalFunction</strong> zostaÅ‚a juÅ¼ wykonana nadal mamy dostÄ™p do jej zmiennej <strong class="bold">myName</strong>. WÅ‚aÅ›nie na tym polega mechanizm domkniÄ™cia.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">IIFE</h3>

        <p class="article__paragraph">To skrÃ³t od Immediately Invoked Function Expression, sÄ… to funkcje anonimowe, ktÃ³re sÄ… wywoÅ‚ywane zaraz po ich deklaracji.</p>

        <pre class="article__code">
        <code>
    let getMyName = (function() {
        let myName = 'Tomasz';
        return myName;
    })();

    console.log(getMyName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyÅ¼szym przykÅ‚adzie aby wykonaÄ‡ funkcjÄ™ natychmiast po jej deklaracji bierzemy jÄ… w dodatkowy nawias, a nastÄ™pnie dodajemy parÄ™ pustych nawiasÃ³w na jej koÅ„cu. Tak samo jak wywoÅ‚ujemy zwykÅ‚a funkcjÄ™.</p>

        <p class="article__paragraph">IIFE sÄ… wykorzystywane we wzorcu moduÅ‚u, ktÃ³ry pozwala nam na zgrupowanie podobnej funkcjonalnoÅ›ci w jednym obiekcie oraz na stworzenie prywatnych zmiennych, ktÃ³re mogÄ… byÄ‡ modyfikowane jedynie za poÅ›rednictwem udostÄ™pnionych przez nas metod.</p>

        <pre class="article__code">
        <code>
    const myModule = (function () {
      let myName = 'Tomasz';
      let myAge = 29;

      return {
        increaseMyAge: function() {
          return myAge += 1;
        },
        getMyAge: function() {
          return myAge;
        }
      };
    })();
    console.log(myModule.myName); // undefined
    console.log(myModule.myAge); // undefined
    myModule.increaseMyAge();
    console.log(myModule.getMyAge()); // 30
        </code>
      </pre>
      </section>

    </article>


    <!-- Article 14 -->


    <article class="article">

      <header id="Funkcje_cz3" class="article__header">
        <div class="decor">14</div>
        <h2 class="article__title">Funkcje cz.3</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Funkcje strzaÅ‚kowe</h3>

        <p class="article__paragraph">W ES6 zostaÅ‚y wprowadzone funkcje strzaÅ‚kowe. MajÄ… krÃ³tszÄ… skÅ‚adnie, dziÄ™ki czemu idealnie nadajÄ… siÄ™ do stosowania jako wyraÅ¼enia zwrotne (o nich w dalszej czÄ™Å›ci tego wpisu) . SÄ… bardziej czytelne niÅ¼ standardowe funkcje przy prostych operacjach. Dodatkowo nie majÄ… wiÄ…zania <strong class="bold">this</strong>. MoÅ¼emy je tylko tworzyÄ‡ jako wyraÅ¼enia funkcyjne, nie podlegajÄ… wiÄ™c wynoszeniu.</p>

        <pre class="article__code">
        <code>
    (parametr1, parametr2, itd.) =&gt; { return wynik; }
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy pomijamy sÅ‚owo kluczowe <strong class="bold">function</strong>, dodajemy natomiast strzaÅ‚kÄ™ za nawiasami z parametrami funkcji. NastÄ™pnie tworzymy ciaÅ‚o funkcji w nawiasach klamrowych.</p>

        <pre class="article__code">
        <code>
    const mathOperation = (a, b, c) =&gt; {
      if (c &gt; 0) {
        return a + b;
      }
      return a - b;
    };
        </code>
      </pre>

        <p class="article__paragraph">W przypadku gdy nasza funkcja przyjmuje tylko jeden parametr i jej jedynym zadaniem jest zwrÃ³ciÄ‡ nam wynik. MoÅ¼emy uproÅ›ciÄ‡ nasz zapis jeszcze bardziej i pominÄ…Ä‡ nawiasy na okoÅ‚o parametrÃ³w oraz nawiasy klamrowe ciaÅ‚a funkcji i sÅ‚owo kluczowe <strong class="bold">return</strong>.</p>

        <pre class="article__code">
        <code>
    const greetings = name =&gt; `CzeÅ›Ä‡ ${name}!`;
    console.log(greetings('Tomasz')); // CzeÅ›Ä‡ Tomasz!

    const difference = (a, b) =&gt; a - b;
    console.log(difference(10, 4)); // 6
        </code>
      </pre>

        <p class="article__paragraph">Brak wiÄ…zania <strong class="bold">this</strong>. Na temat sÅ‚owa kluczowego <strong class="bold">this</strong> napisaÅ‚em juÅ¼ wpis, ktÃ³ry moÅ¼na przeczytaÄ‡ <a class="article__link" target="_blank" href="http://blog.tomasz-rybacki.pl/javascript/this/">tutaj</a>. W odniesieniu do funkcji strzaÅ‚kowych sÅ‚owo <strong class="bold">this</strong> odnosi siÄ™ do zakresu nadrzÄ™dnego funkcji lub zakresu globalnego.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WyraÅ¼enia zwrotne</h3>

        <p class="article__paragraph">W poprzednim wpisie wspomniaÅ‚em, Å¼e do funkcji moÅ¼emy przekazywaÄ‡ rÃ³wnieÅ¼ inne funkcje jako parametry. WÅ‚aÅ›nie takie funkcje nazywamy wyraÅ¼eniami zwrotnymi (ang. callback). Mamy dostÄ™pnych wiele wbudowanych metod, ktÃ³re przyjmujÄ… inne funkcje jako parametry. Jako przykÅ‚ad weÅºmy funkcjÄ™ <strong class="bold">setTimeout</strong>.</p>

        <pre class="article__code">
        <code>
    window.setTimeout(callback, opÃ³Åºnienie)
        </code>
      </pre>

        <p class="article__paragraph">Funkcja ta wykonuje dostarczonÄ… przez nas funkcjÄ™ po upÅ‚ywie okreÅ›lonej liczby milisekund.</p>

        <pre class="article__code">
        <code>
    function printMessage() {
      console.log('ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.');
    }
    window.setTimeout(printMessage, 1000);

    // ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy rÃ³wnieÅ¼ wykorzystaÄ‡ wÅ‚aÅ›nie poznane przez nas funkcje strzaÅ‚kowe, zamiast deklarowania oddzielnej funkcji <strong class="bold">printMessage</strong>, moÅ¼emy przekazaÄ‡ anonimowÄ… funkcjÄ™ strzaÅ‚kowÄ… zapisanÄ… wprost w metodzie <strong class="bold">setTimeout</strong>.</p>


        <pre class="article__code">
        <code>
    window.setTimeout(() =&gt; {
      console.log('ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.')
    }, 1000);

    // ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy teÅ¼ pisaÄ‡ wÅ‚asne funkcje, ktÃ³re przyjmujÄ… inne funkcje jako parametry.</p>

        <pre class="article__code">
        <code>
    function randomBetween(callback, min, max) {
      const randomNumber = Math.floor(Math.random() * (max - min + 1) + min);
      callback(randomNumber);
    }

    randomBetween((number) =&gt; {
      console.log(`WylosowanÄ… liczbÄ… jest ${number}!`);
    }, 10, 20);
    // WylosowanÄ… liczbÄ… jest 12!
        </code>
      </pre>

        <p class="article__paragraph"> W powyÅ¼szym przykÅ‚adzie funkcja randomBetween losujÄ™ liczbÄ™ z podanego przedziaÅ‚u. Jako pierwszy argument przyjmuje funkcjÄ™, ktÃ³ra wyÅ›wietla wiadomoÅ›Ä‡. Kolejne dwa argumenty okreÅ›lajÄ… do jakiego przedziaÅ‚u ma naleÅ¼eÄ‡ wylosowana liczba. Widzimy, Å¼e funkcja zwrotna zostaje wywoÅ‚ana w ciele funkcji randomBetween z wylosowanÄ… wczeÅ›niej liczbÄ…. Liczba ta jest przekazywana do anonimowej funkcji strzaÅ‚kowej, ktÃ³ra nastÄ™pnie wyÅ›wietla jÄ… w konsoli naszej przeglÄ…darki.</p>
      </section>

    </article>


    <!-- Article 15 -->


    <article class="article">

      <header id="Objekty_cz1" class="article__header">
        <div class="decor">15</div>
        <h2 class="article__title">Obiekty cz.1</h2>
      </header>

      <p class="article__paragraph">W JavaScript prawie wszystko jest obiektem (funkcje, tablice, obiekty wbudowane). W kilku kolejnych wpisach opiszÄ™ w jaki sposÃ³b dziaÅ‚ajÄ… obiekty i na czym polega programowanie obiektowe w JS.</p>

      <p class="article__paragraph">Obiekty sÄ… kolekcjÄ… wartoÅ›ci skÅ‚adajÄ…cych siÄ™ z par <strong class="bold">nazwa: wartoÅ›Ä‡</strong>, sÅ‚uÅ¼Ä…cych do opisywania dowolnej rzeczy np. ludzi, samochodÃ³w, zwierzÄ…t itd.</p>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie obiektu</h3>

        <p class="article__paragraph">Najprostszym sposobem utworzenia pojedynczego obiektu jest opakowanie naszych par <strong class="bold">nazwa: wartoÅ›Ä‡</strong> w nawiasy klamrowe <strong class="bold">{}</strong>, jest to tak zwany literaÅ‚ obiektu. WartoÅ›ci przechowywane w obiekcie nazywamy <strong class="bold">wÅ‚aÅ›ciwoÅ›ciami</strong> natomiast funkcje przechowywane w obiekcie to <strong class="bold">metody</strong> tego obiektu.</p>

        <pre class="article__code">
        <code>
    const myFamilyHouse = {
      city: 'OstroÅ‚Ä™ka',
      inhabitants: 2,
      floors: 2,

      neighborhood: function () {
        return 'Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgieÅ‚ku.';
      }
    };
        </code>
      </pre>

        <p class="article__paragraph">PowyÅ¼szy obiekt opisujÄ…cy mÃ³j rodzinny dom ma 3 wÅ‚aÅ›ciwoÅ›ci: <strong class="bold">city, inhabitants, floors</strong>. Posiada teÅ¼ jednÄ… metodÄ™: <strong class="bold">neighborhood</strong>.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">DostÄ™p do wartoÅ›ci</h3>

        <p class="article__paragraph">Aby odczytaÄ‡ wartoÅ›Ä‡ wÅ‚aÅ›ciwoÅ›ci lub wywoÅ‚aÄ‡ metodÄ™ uÅ¼ywamy notacji z kropkÄ… lub notacji z nawiasami.</p>

        <pre class="article__code">
        <code>
    console.log(myFamilyHouse.city); // OstroÅ‚Ä™ka
    console.log(myFamilyHouse.floors); // 2

    console.log(myFamilyHouse.neighborhood());
    // Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgieÅ‚ku.

    console.log(myFamilyHouse['inhabitants']); // 2
    console.log(myFamilyHouse['neighborhood']())
    // Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgieÅ‚ku.
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyÅ¼szym przykÅ‚adzie notacja z kropkÄ… jest o wiele bardziej czytelna dlatego jest najczÄ™Å›ciej stosowana. Ma jednak swoje ograniczenia w postaci:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">nazwy wÅ‚aÅ›ciwoÅ›ci muszÄ… byÄ‡ znakami alfanumerycznymi (z uwzglÄ™dnieniem znakÃ³w _ i $)</li>
          <li class="unordered-list__item">nie mogÄ… zaczynaÄ‡ siÄ™ od cyfry</li>
          <li class="unordered-list__item">nie mogÄ… zawieraÄ‡ nazw zmiennych</li>
        </ul>

        <p class="article__paragraph">Natomiast w przypadku notacji z nawiasami moÅ¼emy uÅ¼ywaÄ‡:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">znaku spacji w nazwach</li>
          <li class="unordered-list__item">nazw zmiennych</li>
          <li class="unordered-list__item">cyfr na poczÄ…tku Å‚aÅ„cucha znakÃ³w</li>
        </ul>

        <p class="article__paragraph">Musimy pamiÄ™taÄ‡, Å¼e identyfikatory w notacji z nawiasami muszÄ… byÄ‡ wartoÅ›ciÄ… typu 'string' lub zmiennÄ…, ktÃ³ra zawiera wartoÅ›ci typu 'string'.</p>
      </section>


      <section class="article__section">
        <h3 class="article__section__title">Nadpisanie wartoÅ›ci</h3>

        <p class="article__paragraph">Aby zmieniÄ‡ istniejÄ…cÄ… wartoÅ›Ä‡ lub dodaÄ‡ nowÄ…, stosujemy zwykÅ‚e przypisanie. Obiekty sÄ… modyfikowalne (mutable data), w kaÅ¼dej chwili moÅ¼emy modyfikowaÄ‡ ich zawartoÅ›Ä‡. JeÅ›li obiekt zawiera juÅ¼ podany klucz jego wartoÅ›Ä‡ zostanie nadpisana, w przeciwnym razie zostanie on dodany do naszego obiektu.</p>

        <pre class="article__code">
        <code>
    myFamilyHouse.garden = true;
    myFamilyHouse.inhabitants = 3;

    myFamilyHouse.income = function () {
      return myFamilyHouse.inhabitants * 1000;
    };

    console.log(myFamilyHouse.income()); // 3000
    console.log(myFamilyHouse);
    // { city: "OstroÅ‚Ä™ka", inhabitants: 3, floors: 2, neighborhood: Æ’, garden: true, income: Æ’ }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Usuwanie wÅ‚aÅ›ciwoÅ›ci i metod</h3>

        <p class="article__paragraph">Aby pozbyÄ‡ siÄ™ wÅ‚aÅ›ciwoÅ›ci lub metody korzystamy z operatora <strong class="bold">delete</strong>.</p>

        <pre class="article__code">
        <code>
    delete myFamilyHouse.garden;
    delete myFamilyHouse.income;

    console.log(myFamilyHouse);
    // { city: "OstroÅ‚Ä™ka", inhabitants: 3, floors: 2, neighborhood: Æ’ }
        </code>
      </pre>

        <p class="article__paragraph">W tym momencie omÃ³wiliÅ›my podstawy funkcjonowania obiektÃ³w. Wystarczy na dzisiaj, wiedza przyswajana w maÅ‚ych dawkach lepiej siÄ™ wchÅ‚ania ğŸ™‚</p>
      </section>
    </article>


    <!-- Article 16 -->


    <article class="article">

      <header id="Objekty_cz2" class="article__header">
        <div class="decor">16</div>
        <h2 class="article__title">Obiekty cz.2</h2>
      </header>

      <p class="article__paragraph">Dzisiejszy wpis nie naleÅ¼y do najÅ‚atwiejszych dlatego warto przeczytaÄ‡ go kilkukrotnie i samemu przeÄ‡wiczyÄ‡ w edytorze. BÄ™dzie za to ciekawie, poniewaÅ¼ poznamy podstawowy mechanizm dziaÅ‚ania jÄ™zyka JavaScript.</p>

      <section class="article__section">
        <h3 class="article__section__title">Konstruktory</h3>

        <p class="article__paragraph">SÄ… to zwyczajne funkcje, ktÃ³rych nazwÄ™ piszemy z wielkiej litery (jest to ogÃ³lnie przyjÄ™ta konwencja). PozwalajÄ… nam tworzyÄ‡ wiele podobnych do siebie obiektÃ³w (o tych samych wÅ‚aÅ›ciwoÅ›ciach i metodach). Konstruktor moÅ¼emy sobie wyobraziÄ‡ jako formÄ™ do ciastek, przy pomocy ktÃ³rej wyciskamy wiele podobnych ciasteczek. KaÅ¼de z powstaÅ‚ych ciasteczek jest nowÄ… instancjÄ… obiektu. Czyli samodzielnym obiektem, ktÃ³ry powstaÅ‚ na bazie danego konstruktora.</p>

        <pre class="article__code">
        <code>
    function User(name, age, location) {
      this.name = name;
      this.age = age;
      this.location = location;

      this.greetings = function () {
        console.log(`Witaj ${this.name}, dobrze ciÄ™ widzieÄ‡!`);
      };
    }

    const user1 = new User('Tomasz', 29, 'Poland');
    const user2 = new User('Daniel', 26, 'Poland');

    user1.greetings(); // Witaj Tomasz, dobrze ciÄ™ widzieÄ‡!
    console.log(user1);
    // {name: "Tomasz", age: 29, location: "Poland", greetings: Æ’}
        </code>
      </pre>

        <p class="article__paragraph">W powyÅ¼szym przykÅ‚adzie utworzyliÅ›my funkcjÄ™ konstruktora o nazwie <strong class="bold">User</strong>, nastÄ™pnie przy jej pomocy stworzyliÅ›my dwÃ³ch uÅ¼ytkownikÃ³w. Aby to zrobiÄ‡ korzystamy z operatora <strong class="bold">new</strong>. DziaÅ‚a on w nastÄ™pujÄ…cy sposÃ³b:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Tworzy nowy pusty obiekt, ktÃ³ry dziedziczy po <strong class="bold">User.prototype</strong></li>
          <li class="ordered-list__item">Sprawia, Å¼e <strong class="bold">this</strong> odnosi siÄ™ do nowo utworzonego obiektu.</li>
          <li class="ordered-list__item">Ustawia jaki konstruktor zostaÅ‚ uÅ¼yty do utworzenia obiektu.</li>
          <li class="ordered-list__item">Na koniec zwraca nam referencjÄ™ do nowo utworzonego obiektu, ktÃ³ry jest zapisywany w naszej zmiennej np. <strong class="bold">user1</strong>.</li>
        </ol>

        <p class="article__paragraph">Adnotacja do punktu nr 3. DziÄ™ki temu moÅ¼emy sprawdziÄ‡ czy dany obiekt zostaÅ‚ stworzony za pomocÄ… danego konstruktora.</p>

        <pre class="article__code">
        <code>
    const user3 = {
      name: 'Marcin',
      age: 29,
      location: 'Cuba'
    };

    console.log(user1 instanceof User); // true
    console.log(user3 instanceof User); // false
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Prototypy i dziedziczenie</h3>

        <p class="article__paragraph">Model obiektowy jÄ™zyka JavaScript bazuje na prototypach. Wszystkie obiekty, ktÃ³re tworzymy powstajÄ… na bazie innych obiektÃ³w. UmoÅ¼liwia to dziedziczenie wÅ‚aÅ›ciwoÅ›ci i metod po innych obiektach. Prototypem nazywamy obiekt po ktÃ³rym sÄ… dziedziczone wÅ‚aÅ›ciwoÅ›ci i metody.</p>

        <p class="article__paragraph">MoÅ¼emy to sobie wyobraziÄ‡ jako drzewo, gdzie pniem jest prototyp obiektu <strong class="bold">Object</strong>, to na jego podstawie powstajÄ… wszystkie inne obiekty, ktÃ³re tworzÄ… strukturÄ™ rozgaÅ‚Ä™zieÅ„ niczym w prawdziwym drzewie. Prototyp <strong class="bold">Object</strong> zawiera podstawowe metody, ktÃ³re dziedziczÄ… wszystkie inne obiekty, dziÄ™ki ktÃ³rym funkcjonuje nasz system obiektÃ³w.</p>

        <pre class="article__code">
        <code>
    console.log(user3)

    //  {name: "Marcin", age: 29, location: "Cuba"}
    //  age: 29
    //  location: "Cuba"
    //  name: "Marcin"
    //  __proto__:
    //      constructor: Æ’ Object()
    //      hasOwnProperty: Æ’ hasOwnProperty()
    //      isPrototypeOf: Æ’ isPrototypeOf()
    //      propertyIsEnumerable: Æ’ propertyIsEnumerable()
    //      toLocaleString: Æ’ toLocaleString()
    //      toString: Æ’ toString()
    //      valueOf: Æ’ valueOf()
    //      __defineGetter__: Æ’ __defineGetter__()
    //      __defineSetter__: Æ’ __defineSetter__()
    //      __lookupGetter__: Æ’ __lookupGetter__()
    //      __lookupSetter__: Æ’ __lookupSetter__()
    //      get __proto__: Æ’ __proto__()
    //      set __proto__: Æ’ __proto__()
        </code>
      </pre>

        <p class="article__paragraph">W powyÅ¼szym przykÅ‚adzie widzimy, Å¼e nasz obiekt user3 ma dostÄ™pne metody takie jak np: hasOwnProperty, toString, valueOf itd. Wszystkie te metody zostaÅ‚y odziedziczone po jego prototypie i mamy do nich dostÄ™p z poziomu obiektu user3.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Jak dziaÅ‚a dziedziczenie ?</h3>

        <p class="article__paragraph">Chcemy ulepszyÄ‡ nasz wczeÅ›niejszy kod i przenieÅ›Ä‡ metodÄ™ greetings wyÅ¼ej w naszym Å‚aÅ„cuchu prototypÃ³w. Nie ma potrzeby, Å¼eby kaÅ¼dy z naszych obiektÃ³w uÅ¼ytkownikÃ³w miaÅ‚ swojÄ… wÅ‚asnÄ… metodÄ™ powitania. DuÅ¼o lepszym rozwiÄ…zaniem jest utworzenie jednej metody greetings, z ktÃ³rej bÄ™dzie mÃ³gÅ‚ korzystaÄ‡ kaÅ¼dy z uÅ¼ytkownikÃ³w.</p>

        <pre class="article__code">
        <code>
    function User(name, age, location) {
      this.name = name;
      this.age = age;
      this.location = location;
    }

    User.prototype.greetings = function () {
        console.log(`Witaj ${this.name}, dobrze ciÄ™ widzieÄ‡!`);
      };

    const user1 = new User('Tomasz', 29, 'Poland');
    const user2 = new User('Daniel', 26, 'Poland');

    user1.greetings(); // Witaj Tomasz, dobrze ciÄ™ widzieÄ‡!
    user2.greetings(); // Witaj Daniel, dobrze ciÄ™ widzieÄ‡!

    console.log(user1); // {name: "Tomasz", age: 29, location: "Poland"}
    console.log(Object.getPrototypeOf(user1)); // {greetings: Æ’, constructor: Æ’}
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy powyÅ¼ej, obiekt <strong class="bold">user1</strong> nie ma wÅ‚asnej metody <strong class="bold">greetings</strong>. Mimo to moÅ¼e jÄ… wywoÅ‚aÄ‡. Dzieje siÄ™ tak poniewaÅ¼ odziedziczyÅ‚ jÄ… po swoim prototypie. W chwili wywoÅ‚ania tej metody JavaScript sprawdza czy istnieje ona w danym obiekcie. JeÅ›li nie zostaÅ‚a znaleziona, nastÄ™puje przesuniÄ™cie siÄ™ w dÃ³Å‚ naszej gaÅ‚Ä™zi do prototypu danego obiektu. JeÅ›li i tu nie zostaÅ‚a odnaleziona caÅ‚y proces siÄ™ powtarza, aÅ¼ do momentu znalezienia metody lub dotarcia do pnia naszego drzewa jakim jest obiekt <strong class="bold">Object</strong>. JeÅ›li i tu nie zostaje znaleziona nasza metoda, zgÅ‚aszany jest bÅ‚Ä…d.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PrzesÅ‚anianie prototypu</h3>

        <p class="article__paragraph">PoniewaÅ¼ JS zaczyna sprawdzanie od obiektu, ktÃ³ry wywoÅ‚aÅ‚ danÄ… metodÄ™, moÅ¼emy utworzyÄ‡ w nim jego wÅ‚asnÄ… metodÄ™ o tej samej nazwie i tym samym przesÅ‚oniÄ‡ metodÄ™, ktÃ³ra juÅ¼ istnieje w Å‚aÅ„cuchu prototypÃ³w.</p>

        <pre class="article__code">
        <code>
    user1.greetings = function () {
      console.log(`Witaj ponownie ${this.name}, jak siÄ™ dzisiaj masz ?`);
    };

    user1.greetings(); // Witaj ponownie Tomasz, jak siÄ™ dzisiaj masz ?
    user2.greetings(); // Witaj Daniel, dobrze ciÄ™ widzieÄ‡!
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e <strong class="bold">user1</strong> ma swoje wÅ‚asne powitanie, ktÃ³re nie wpÅ‚ynÄ™Å‚o na uÅ¼ytkownika <strong class="bold">user2</strong>.</p>

        <p class="article__paragraph">JeÅ›li chcemy dodaÄ‡ kilka rzeczy naraz do prototypu, moÅ¼emy to zrobiÄ‡. PrzypisujÄ…c obiekt do prototypu. Musimy tylko pamiÄ™taÄ‡, Å¼e w takim przypadku musimy rÄ™cznie dodaÄ‡ wÅ‚aÅ›ciwoÅ›ci <strong class="bold">constructor</strong> do naszego prototypu.</p>

        <pre class="article__code">
        <code>
    User.prototype = {
      constructor: User, // UWAGA! - zawsze samemu ustawiamy tÄ… wÅ‚aÅ›ciwoÅ›Ä‡
      greetings: function () {
        console.log(`Witaj ${this.name}, dobrze ciÄ™ widzieÄ‡!`);
      },
      farewell: function () {
        console.log(`DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia ${this.name}`);
      }
    };
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Prototypy sÄ… dynamiczne</h3>

        <p class="article__paragraph">Oznacza to, Å¼e wszystkie obiekty utworzone na podstawie danego prototypu, te utworzone przed jak i po modyfikacji prototypu (np. dodanie nowej metody) majÄ… dostÄ™p do wszystkich jego wÅ‚aÅ›ciwoÅ›ci i metod.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie Å‚aÅ„cucha prototypÃ³w</h3>

        <p class="article__paragraph">ZaÅ‚Ã³Å¼my, Å¼e chcemy utworzyÄ‡ nastÄ™pujÄ…cy Å‚aÅ„cuch <strong class="bold">Object -&gt; Human -&gt; User</strong>. KaÅ¼dy Å‚aÅ„cuch budujemy od bardziej ogÃ³lnej koncepcji do bardziej szczegÃ³Å‚owej. Na poczÄ…tku mamy wiÄ™c ogÃ³lne pojÄ™cie obiektu zdefiniowane przez sam jÄ™zyk JS. PÃ³Åºniej tworzymy obiekt CzÅ‚owieka, jest to dosyÄ‡ ogÃ³lna kategoria. NastÄ™pnie podkategoriÄ… CzÅ‚owieka moÅ¼e byÄ‡ UÅ¼ytkownik.</p>

        <pre class="article__code">
        <code>
    function Human() {}

    Human.prototype = {
      constructor: Human,
      greetings: function () {
        console.log(`Witaj ${this.login}, dobrze ciÄ™ widzieÄ‡!`);
      },
      farewell: function () {
        console.log(`DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia ${this.login}`);
      }
    };

    function User(login, email) {
      this.login = login;
      this.email = email;
    }

    User.prototype = Object.create(Human.prototype); // Tutaj nastÄ™puje poÅ‚Ä…czenie prototypÃ³w
    User.prototype.constructor = User; // UWAGA! - ustawiamy rÄ™cznie

    const user1 = new User('Tomasz', 'example@gmail.com');
    const human1 = new Human();

    user1.greetings(); // Witaj Tomasz, dobrze ciÄ™ widzieÄ‡!

    console.log(human1 instanceof User); // false
    console.log(user1 instanceof Human); // true
    console.log(user1 instanceof User); // true
        </code>
      </pre>

        <p class="article__paragraph">Przy pomocy <strong class="bold">Object.create()</strong>, tworzymy nowy obiekt, powstaje on na podstawie istniejÄ…cego i wybranego przez nas obiektu prototypu.</p>
      </section>
    </article>


    <!-- Article 17 -->


    <article class="article">

      <header id="Klasy" class="article__header">
        <div class="decor">17</div>
        <h2 class="article__title">Klasy</h2>
      </header>

      <p class="article__paragraph">W ES6 wprowadzono nowÄ… skÅ‚adnie <strong class="bold">class</strong>, jest to ukÅ‚on w stronÄ™ osÃ³b, ktÃ³re na co dzieÅ„ programujÄ… w jÄ™zykach opartych o klasy jak np. Java. DziÄ™ki temu nie muszÄ… uczyÄ‡ siÄ™ bardziej ogÃ³lnej koncepcji prototypÃ³w i dziedziczenia. MogÄ… od razu zaczÄ…Ä‡ pisaÄ‡ programy, w oparciu o to co dobrze znajÄ… i czego uÅ¼ywali na co dzieÅ„ do tej pory.</p>

      <p class="article__paragraph">Nie zmienia to mechanizmu w jaki dziaÅ‚a JavaScript. Wszystko to co poznaliÅ›my w poprzednim wpisie nadal funkcjonuje i dzieje siÄ™ pod pÅ‚aszczykiem nowej skÅ‚adni, ktÃ³rÄ… poznamy dzisiaj.</p>

      <section class="article__section">
        <h3 class="article__section__title">class</h3>

        <p class="article__paragraph">Klasy sÄ… specjalnymi funkcjami, ktÃ³re zawierajÄ… w swoim ciele konstruktor i metody dodawane do prototypu. DziÄ™ki temu mamy wszystko Å‚adnie pogrupowane. StwÃ³rzmy podobny przykÅ‚ad do tego z poprzedniego wpisu.</p>

        <pre class="article__code">
        <code>
    class Human {
      constructor(name) {
        this.name = name;
      }

      greetings() {
        console.log(`Witaj ${this.login || this.name}, dobrze ciÄ™ widzieÄ‡!`);
      }

      farewell() {
        console.log(`DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia ${this.login || this.name}.`);
      }
    }

    class User extends Human {
      constructor(name, login, email) {
        super(name);
        this.login = login;
        this.email = email;
      }
    }

    const user1 = new User('Tomasz', 'Tom89', 'TomaszRybacki1989@gmail.com');

    console.log(user1);
    // {name: "Tomasz", login: "Tom89", email: "TomaszRybacki1989@gmail.com"}

    user1.greetings(); // Witaj Tom89, dobrze ciÄ™ widzieÄ‡!
    user1.farewell(); // DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia Tom89.
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e nasz kod jest teraz o wiele bardziej czytelny. Nasza funkcja konstruktora jest zawarta wewnÄ…trz klasy. Dodatkowo sÅ‚owo kluczowe <strong class="bold">extends</strong> wyraÅºnie pokazuje zaleÅ¼noÅ›Ä‡ pomiÄ™dzy obiektami. Å»eby odwoÅ‚aÄ‡ siÄ™ do kodu konstruktora z klasy wyÅ¼szej i go rozszerzyÄ‡, uÅ¼ywamy sÅ‚owa kluczowego <strong class="bold">super()</strong>, w nawiasach podajÄ…c argumenty z jakimi chcemy go wywoÅ‚aÄ‡.</p>

        <p class="article__paragraph">OczywiÅ›cie caÅ‚y mechanizm dziaÅ‚ania pozostaje taki sam, moÅ¼emy nadal nadpisaÄ‡ odziedziczone metody i dodaÄ‡ nowe dostÄ™pne tylko w instancjach stworzonych przy uÅ¼yciu naszej klasy <strong class="bold">User</strong>.</p>

        <pre class="article__code">
        <code>
    class User extends Human {
      constructor(name, login, email) {
        super(name);
        this.login = login;
        this.email = email;
      }

      farewell() {
        console.log('MiÅ‚ego dnia.');
      }

      changeLogin() {
        console.log('TwÃ³j login zostaÅ‚ zmieniony.');
      }
    }

    const user1 = new User('Tomasz', 'Tom89', 'TomaszRybacki1989@gmail.com');
    const human1 = new Human('Daniel');

    user1.greetings(); // Witaj Tom89, dobrze ciÄ™ widzieÄ‡!
    user1.farewell(); // MiÅ‚ego dnia.
    user1.changeLogin(); // TwÃ³j login zostaÅ‚ zmieniony.

    human1.greetings(); // Witaj Daniel, dobrze ciÄ™ widzieÄ‡!
    human1.farewell(); // DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia Daniel.
    human1.changeLogin(); // TypeError
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wynoszenie</h3>

        <p class="article__paragraph">IstotnÄ… rÃ³Å¼nicÄ… pomiÄ™dzy zwykÅ‚Ä… funkcjÄ… a klasÄ… jest to, Å¼e klasy nie sÄ… wynoszone na poczÄ…tek naszego skryptu. Musimy je wiÄ™c najpierw zadeklarowaÄ‡ a dopiero potem ich uÅ¼ywaÄ‡.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Deklaracja klasy i wyraÅ¼enie klasy</h3>

        <p class="article__paragraph">PowyÅ¼szy przykÅ‚ad zawiera deklaracjÄ™ klasy czyli:</p>

        <pre class="article__code">
        <code>
    class Human {}
        </code>
      </pre>

        <p class="article__paragraph">Tak samo jak w przypadku funkcji moÅ¼emy przypisaÄ‡ jÄ… do zmiennej, tak samo moÅ¼emy postÄ…piÄ‡ z klasÄ…. WyraÅ¼enia klas mogÄ… byÄ‡ anonimowe lub nazwane.</p>

        <pre class="article__code">
        <code>
    const Human = class {};

    const Human = class Human {};
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Metody statyczne</h3>

        <p class="article__paragraph">SÄ… to metody dostÄ™pne tylko z poziomu klasy. Nie moÅ¼na siÄ™ do nich odwoÅ‚aÄ‡ za pomocÄ… instancji utworzonych przy pomocy tej klasy. SÅ‚uÅ¼Ä… przewaÅ¼nie do tworzenia metod pomocniczych.</p>

        <pre class="article__code">
        <code>
    class Human {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }

      static youngerHuman(a, b) {
        if (a.age &gt; b.age) {
          return b.name;
        }
        return a.name;
      }
    }

    class User extends Human {
      constructor(name, age, login, email) {
        super(name, age);
        this.login = login;
        this.email = email;
      }
    }

    const user1 = new User('Tomasz', 29, 'Tom89', 'TomaszRybacki1989@gmail.com');
    const user2 = new User('Marcin', 32, 'Martin86', 'example@gmail.com');

    const human1 = new Human('Daniel', 26);

    user1.youngerHuman(); // TypeError
    human1.youngerHuman(); // TypeError

    console.log(Human.youngerHuman(user1, user2)); // Tomasz
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 18 -->


    <article class="article">

      <header id="Obiekty_opakowujace" class="article__header">
        <div class="decor">18</div>
        <h2 class="article__title">Obiekty opakowujÄ…ce</h2>
      </header>

      <p class="article__paragraph">Teraz gdy poznaÅ‚eÅ› obiekty i typy proste w JavaScript. BÄ™dziesz mÃ³gÅ‚ z Å‚atwoÅ›ciÄ… zrozumieÄ‡ co siÄ™ dzieje w poniÅ¼szej sytuacji:</p>

      <pre class="article__code">
        <code>
    let myName = 'Tomasz';

    console.log(myName.indexOf('s')); // 4
    console.log(typeof myName); // string
        </code>
      </pre>

      <p class="article__paragraph">PatrzÄ…c na powyÅ¼szy kod, moÅ¼esz podrapaÄ‡ siÄ™ w gÅ‚owÄ™ i pomyÅ›leÄ‡. Co jest grane ? PrzecieÅ¼ przy pomocy notacji z kropkÄ… odwoÅ‚ujemy siÄ™ do metody obiektu. Ale w nastÄ™pnej linijce kodu widzimy wyraÅºnie, Å¼e zmienna <strong class="bold">myName</strong> przechowuje wartoÅ›Ä‡ typu prostego.</p>

      <section class="article__section">
        <h3 class="article__section__title">Opakowanie przez silnik JS</h3>

        <p class="article__paragraph">RozwiÄ…zanie tej zagadki jest proste. Oto co siÄ™ wydarzyÅ‚o za kurtynÄ…:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Za kaÅ¼dym razem gdy chcemy wywoÅ‚aÄ‡ metodÄ™ na wartoÅ›ci typu prostego zostaje ona â€po cichuâ€ opakowana przy pomocy obiektu.</li>
          <li class="ordered-list__item">NastÄ™pnie zostaje wywoÅ‚ana nasza metoda.</li>
          <li class="ordered-list__item">Gdy tylko otrzymamy wynik jej dziaÅ‚ania nasz obiekt opakowujÄ…cy jest niszczony.</li>
        </ol>

        <p class="article__paragraph">Teraz powyÅ¼szy przykÅ‚ad jest dla nas zrozumiaÅ‚y i logiczny. Otrzymane wartoÅ›ci sÄ… dokÅ‚adnie tym czego siÄ™ spodziewaliÅ›my. Opakowaniu ulegajÄ… wartoÅ›ci proste typu: string, number i boolean.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WÅ‚asnorÄ™czne opakowanie</h3>

        <p class="article__paragraph">To co zostaÅ‚o zrobione â€po cichuâ€ przez silnik JS. MoÅ¼emy rÃ³wnieÅ¼ zrobiÄ‡ samemu przy uÅ¼yciu konstruktora.</p>

        <pre class="article__code">
        <code>
    let myName = new String('Tomasz');

    console.log(myName.indexOf('s')); // 4

    console.log(myName); // {"Tomasz"}
    console.log(typeof myName); // object

    let myAge = new Number(29);

    console.log(myAge); // {29}
    console.log(typeof myAge); // object

    let codingIsCool = new Boolean(true);

    console.log(codingIsCool); // {true}
    console.log(typeof codingIsCool); // object
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy nasza wartoÅ›Ä‡ pozostaje caÅ‚y czas zapakowana i sprawdzenie jej typu zwraca object. MoÅ¼emy teÅ¼ rÄ™cznie rozpakowaÄ‡ naszÄ… wartoÅ›Ä‡ wykorzystujÄ…c mechanizm konwersji typÃ³w.</p>

        <pre class="article__code">
        <code>
    myName = myName + '';

    console.log(myName); // Tomasz
    console.log(typeof myName); // string

    myAge = myAge + 0;

    console.log(myAge); // 29
    console.log(typeof myAge); // number

    codingIsCool = !!codingIsCool;

    console.log(codingIsCool); // true
    console.log(typeof codingIsCool); // boolean
        </code>
      </pre>

        <p class="article__paragraph">Teraz gdy wiemy na czym polega opakowywanie typÃ³w prostych. ZapamiÄ™tajmy Å¼eby nigdy nie robiÄ‡ tego samemu. Zawsze twÃ³rz wartoÅ›ci typu prostego w postaci literaÅ‚u!</p>
      </section>

    </article>


    <!-- Article 19 -->


    <article class="article">

      <header id="Obiekty_wbudowane" class="article__header">
        <div class="decor">19</div>
        <h2 class="article__title">Obiekty wbudowane</h2>
      </header>

      <p class="article__paragraph">W JavaScript mamy dostÄ™p do wielu juÅ¼ utworzonych obiektÃ³w, ktÃ³re pozwalajÄ… nam na wykonywanie rÃ³Å¼nych operacji. MoÅ¼emy je podzieliÄ‡ na trzy grupy:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Obiekty opakowujÄ…ce. PozwalajÄ… nam na zarzÄ…dzanie rÃ³Å¼nymi typami danych. SÄ… to: <strong class="bold">Array, Number, Boolean, Symbol, Object, Array, Function, Map, Set, JSON.</strong></li>
        <li class="ordered-list__item">Obiekty uÅ¼ytkowe. PozwalajÄ… nam wykonywaÄ‡ rÃ³Å¼ne operacje. SÄ… to: <strong class="bold">Math, Date, RegExp.</strong></li>
        <li class="ordered-list__item">Obiekty bÅ‚Ä™dÃ³w. SÅ‚uÅ¼Ä… do zarzÄ…dzania powstaÅ‚ymi bÅ‚Ä™dami. SÄ… to: <strong class="bold">Error, EvalError, InternalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError.</strong></li>
      </ol>

      <p class="article__paragraph">Jak widzisz jest tego caÅ‚kiem sporo, czÄ™Å›Ä‡ z tych obiektÃ³w juÅ¼ poznaÅ‚eÅ›. Dzisiaj chcÄ™ siÄ™ skupiÄ‡ na obiektach z drugiej grupy.</p>

      <section class="article__section">
        <h3 class="article__section__title">Math</h3>

        <p class="article__paragraph">Obiekt Math sÅ‚uÅ¼y do przeprowadzania rÃ³Å¼nych dziaÅ‚aÅ„ matematycznych. Jest dosyÄ‡ niezwykÅ‚y, w przeciwieÅ„stwie do pozostaÅ‚ych nie jest funkcjÄ… konstruktora. Wszystkie jego wÅ‚aÅ›ciwoÅ›ci i metody sÄ… statyczne. OdwoÅ‚ujemy siÄ™ do nich przez obiekt Math. Przyjrzyjmy siÄ™ jego najczÄ™Å›ciej uÅ¼ywanym wÅ‚aÅ›ciwoÅ›ciom i metodom.</p>

        <pre class="article__code">
        <code>
    WÅ‚aÅ›ciwoÅ›ci:

    console.log(Math.PI); // 3.141592
    // zwraca wartoÅ›Ä‡ liczby pi

    console.log(Math.SQRT2); // 1.414213
    // zwraca pierwiastek kwadratowy z 2

    Metody:

    console.log(Math.abs(-6)) // 6
    // zwraca wartoÅ›Ä‡ absolutnÄ… liczby

    console.log(Math.cbrt(27)) // 3
    // zwraca pierwiastek szeÅ›cienny z liczby

    console.log(Math.sqrt(16)) // 4
    // zwraca pierwiastek kwadratowy z liczby

    console.log(Math.pow(5, 2)) // 25
    // zwraca liczbÄ™ podniesionÄ… do potÄ™gi

    console.log(Math.ceil(5.2)) // 6
    // zaokrÄ…gla liczbÄ™ w gÃ³rÄ™

    console.log(Math.floor(5.6)) // 5
    // zaokrÄ…gla liczbÄ™ w dÃ³Å‚

    console.log(Math.round(5.5)) // 6
    // zaokrÄ…gla liczbÄ™ do najbliÅ¼szej wartoÅ›ci caÅ‚kowitej

    console.log(Math.random()) // 0.634532
    // generuje losowÄ… liczbÄ™ z przedziaÅ‚u od 0 do 1 (nie zawiera jedynki)

    console.log(Math.min(45, 23)); // 23
    // zwraca najmniejszÄ… z podanych liczb

    console.log(Math.max(45, 23)); // 45
    // zwraca najwiÄ™kszÄ… z podanych liczb
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Date</h3>

        <p class="article__paragraph">Obiekt date pozwala nam na pracÄ™ z czasem. Oparty jest na czasie uniksowym, czyli wartoÅ›ci dodatnie oznaczajÄ… liczbÄ™ milisekund jakie upÅ‚ynÄ™Å‚y od poczÄ…tku roku 1970. Nie uwzglÄ™dnia jednak milisekund przestÄ™pnych. Sposoby tworzenia obiektu date:</p>

        <pre class="article__code">
        <code>
    // pobieranie aktualnej daty z urzÄ…dzenia uÅ¼ytkownika

    let now = new Date();
    console.log(now);
    // Tue Jul 31 2018 12:32:52 GMT+0200

    // ustawianie wybranej daty

    let myBirthday = new Date(1989, 4, 24);
    console.log(myBirthday);
    // Wed May 24 1989 00:00:00 GMT+0200

    // ustawianie daty na podstawie liczby milisekund jakie upÅ‚yneÅ‚y od poczÄ…tku 1970
    let unixEpoch = new Date(6000);
    console.log(unixEpoch);
    // Thu Jan 01 1970 01:00:06 GMT+0100
        </code>
      </pre>

        <p class="article__paragraph">PamiÄ™tamy, Å¼e miesiÄ…ce sÄ… numerowane od zera. MoÅ¼emy ustawiÄ‡ datÄ™ z dokÅ‚adnoÅ›ciÄ… do milisekundy, korzystajÄ…c z poniÅ¼szej skÅ‚adni:</p>

        <span class="article__command">new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds);</span>

        <p class="article__paragraph">Obiekt Date zawiera caÅ‚Ä… listÄ™ metod sÅ‚uÅ¼Ä…cych do pobierania i ustawiania czÄ™Å›ci skÅ‚adowych daty. KompletnÄ… listÄ™ tych metod znajdziesz tutaj. Polecam Ci samodzielne pogÅ‚Ä™bianie wiedzy z materiaÅ‚Ã³w MDN (mozilla developer network). Prowadzona przez nich dokumentacja jest bardzo solidna i stanowi doskonaÅ‚e ÅºrÃ³dÅ‚o wiedzy na temat JavaScript.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">RegExp</h3>

        <p class="article__paragraph">WyraÅ¼enia regularne to wzorce stosowane do dopasowywania kombinacji znakÃ³w w Å‚aÅ„cuchach. W JavaScript wyraÅ¼enia regularne sÄ… rÃ³wnieÅ¼ obiektami. Zapisujemy je pomiÄ™dzy ukoÅ›nikami np: /^[a-zA-z]\w*\w$/</p>

        <h4 class="article__section__subtitle">Metody obiektu RegExp</h4>

        <p class="article__paragraph"><strong class="bold">exec</strong> â€“ wyszukuje dopasowanie w Å‚aÅ„cuchu. Zwraca dopasowany fragment lub <strong class="bold">null</strong> gdy nic nie znaleziono.</p>

        <p class="article__paragraph"><strong class="bold">test</strong> â€“ sprawdza dopasowanie w Å‚aÅ„cuchu . Zwraca <strong class="bold">true</strong> gdy wystÄ™puje lub <strong class="bold">false</strong> gdy nie wystÄ™puje.</p>

        <h4 class="article__section__subtitle">Metody obiektu String</h4>

        <p class="article__paragraph"><strong class="bold">match</strong> â€“ wyszukuje dopasowanie w Å‚aÅ„cuchu. Zwraca tablicÄ™ dopasowanych fragmentÃ³w lub <strong class="bold">null</strong> gdy nic nie znaleziono.</p>

        <p class="article__paragraph"><strong class="bold">search</strong> â€“ sprawdza dopasowanie w Å‚aÅ„cuchu. Zwraca <strong class="bold">index</strong> dopasowania lub <strong class="bold">-1</strong> gdy nic nie znajdzie.</p>

        <p class="article__paragraph"><strong class="bold">replace</strong> â€“ sprawdza dopasowanie w Å‚aÅ„cuchu i zastÄ™puje dopasowane fragmenty nowymi podanymi Å‚aÅ„cuchami.</p>

        <p class="article__paragraph"><strong class="bold">split</strong> â€“ wykorzystuje wyraÅ¼enie regularne lub Å‚aÅ„cuch znakÃ³w do podzielenia Å‚aÅ„cucha na tablicÄ™ Å‚aÅ„cuchÃ³w powstaÅ‚ych w wyniku podziaÅ‚u.</p>

        <h4 class="article__section__subtitle">Oznaczenia</h4>

        <p class="article__paragraph">
          ^ â€“ dopasowuje pierwszy znak w Å‚aÅ„cuchu<br> $ â€“ dopasowuje ostatni znak w Å‚aÅ„cuchu<br> * â€“ dopasowuje poprzedzajÄ…cy znak 0 powtÃ³rzeÅ„ lub wiÄ™cej, ekwiwalent do {0,}<br> + â€“ dopasowuje poprzedzajÄ…ce wyraÅ¼enie 1 lub wiÄ™cej razy, ekwiwalent do {1,}<br> ? â€“ dopasowuje poprzedzajÄ…ce wyraÅ¼enie 0 lub 1 raz, ekwiwalent do {0,1}<br> . â€“ dopasowuje kaÅ¼dy (dowolny) znak za wyjÄ…tkiem znaku od nowej lini
        </p>

        <p class="article__paragraph">
          (x) â€“ dopasowuje x i zapamiÄ™tuje dopasowanie, pÃ³Åºniej moÅ¼emy je wykorzystaÄ‡ i np. zamieniaÄ‡ je miejscami za pomocÄ… $1, $2<br> (?:x) â€“ dopasowuje x i nie zapamiÄ™tuje dopasowania, pozwala grupowaÄ‡ znaki wewnÄ…trz wyraÅ¼enia regularnego<br> x(?=y) â€“ dopasowuje x tylko gdy jest po nim y<br> x(?!y) â€“ dopasowuje x gdy nie nastÄ™puje po nim y<br> x|y â€“ dopasowuje x lub y
        </p>

        <p class="article__paragraph">
          {n} â€“ dopasowuje dokÅ‚adnie iloÅ›Ä‡ poprzedzajÄ…cych wyraÅ¼eÅ„<br> {n,} â€“ dopasowuje przynajmniej n wystÄ…pieÅ„ poprzedzajÄ…cych wyraÅ¼eÅ„<br> {n,m} â€“ dopasowuje iloÅ›Ä‡ wystÄ…pieÅ„ wyraÅ¼enia z przedziaÅ‚u od n do m<br> [xyz] â€“ dopasowuje dowolny ze znakÃ³w z zestawu, zakres podajemy przy uÅ¼yciu â€“ np:/[a-z]/<br> [^xyz] â€“ dopasowuje wszystko co nie naleÅ¼y do zestawu<br>
        </p>

        <p class="article__paragraph">
          \d â€“ dopasowujÄ™ cyfrÄ™, ekwiwalent do [0-9]<br> \D â€“ dopasowuje nie-cyfrÄ™, ekwiwalent do [^0-9]<br> \s â€“ dopasowuje biaÅ‚y znak np: spacje, tabulator<br> \S â€“ dopasowuje pojedyÅ„czy nie biaÅ‚y znak<br> \t â€“ dopasowuje tabulator<br> \w â€“ dopasowuje alfabetyczno-numeryczny znak z uwzglÄ™dnieniem podkreÅ›lenia, ekwiwalent do [A-Za-z0-9_]<br> \W â€“ dopasowuje nie alfabetyczno-numeryczny znak<br> \b â€“ granica sÅ‚owa, dopasowuje siÄ™ do zmiany znaku z \w na \W lub na odwrÃ³t
        </p>

        <p class="article__paragraph">
          \xhh â€“ dopasowuje znak z kodem hh (dwie cyfry szesnastkowe)<br> \uhhhh â€“ dopasowuje znak z kodem hhhh ( cztery cyfry szesnastkowe)<br> \u{hhhh} â€“ tylko gdy flaga u jest wÅ‚Ä…czona. Dopasowuje znak z kodem Unicode o wartoÅ›ci hhhh
        </p>

        <h4 class="article__section__subtitle">Flagi</h4>

        <p class="article__paragraph">Flagi moÅ¼emy dodaÄ‡ na koÅ„cu wyraÅ¼enia regularnego Å¼eby zmodyfikowaÄ‡ sposÃ³b w jaki dziaÅ‚a np. <strong class="bold">/wyraÅ¼enieRegularne/flaga</strong></p>

        <p class="article__paragraph">
          g â€“ nie zatrzymuje wyszukiwania po pierwszym dopasowaniu i szuka dalej<br> i â€“ nie rozrÃ³Å¼nia wielkoÅ›ci znakÃ³w np. a = A<br> m â€“ wyszukiwanie wielowierszowe (^ i $) dziaÅ‚ajÄ… dla kaÅ¼dej nowej linii<br> u â€“ traktuje wyraÅ¼enie jako znaki Unicode<br> y â€“ sprawdza tylko wskazanÄ… pozycjÄ™ pod danym indexem (RegExp.lastIndex = index)
        </p>

        <h4 class="article__section__subtitle">Znaki specjalne</h4>

        <p class="article__paragraph">Wszystkie znaki z tej listy naleÅ¼y poprzedziÄ‡ ukoÅ›nikiem wstecznym \ Å¼eby wykorzystaÄ‡ je jako zwykÅ‚e znaki w wyraÅ¼eniu regularnym:<strong class="bold"> \ ^ $ * + ? . ( ) | { } [ ]</strong></p>

        <p class="article__paragraph">Do wyraÅ¼eÅ„ regularnych moÅ¼emy teÅ¼ wstawiaÄ‡ zmienne z wykorzystaniem â€Template stringsâ€ nie uÅ¼ywamy wtedy ukoÅ›nikÃ³w // i caÅ‚e wyraÅ¼enie zapisujemy w â€ np. `(?:[0\\D]*(\\d+)\\D*){${n}}`, gdzie n jest zmiennÄ….</p>

        <p class="article__paragraph">WewnÄ…trz wyraÅ¼enia regularnego moÅ¼na korzystaÄ‡ z wczeÅ›niej zapamiÄ™tanych dopasowaÅ„ w nawiasach () np. /([a-z]+)[^a-z]+\1\b/gi, gdzie \1 oznacza wczeÅ›niej dopasowane sÅ‚owo z nawiasÃ³w ([a-z]+)</p>
      </section>
    </article>


    <!-- Article 20 -->


    <article class="article">

      <header id="DOM" class="article__header">
        <div class="decor">20</div>
        <h2 class="article__title">DOM</h2>
      </header>

      <p class="article__paragraph">DOM to skrÃ³t od Document Object Model, czyli modelu obiektowego dokumentu. Nie jest czÄ™Å›ciÄ… jÄ™zyka JavaScript, tylko API dla dokumentÃ³w HTML i XML. API to skrÃ³t od application programming interface, czyli interfejsu programowania aplikacji.</p>

      <p class="article__paragraph">WyjaÅ›nijmy sobie, co kryje siÄ™ pod tymi pojÄ™ciami. API jest ogÃ³lnÄ… koncepcjÄ… okreÅ›lajÄ…cÄ… w jaki sposÃ³b rÃ³Å¼ne programy i urzÄ…dzenia majÄ… siÄ™ komunikowaÄ‡ miÄ™dzy sobÄ…. Natomiast DOM jest implementacjÄ… tego sposobu komunikacji dla naszych dokumentÃ³w HTML. OkreÅ›la w jaki sposÃ³b wyglÄ…da struktura dokumentu, tak zwane drzewo DOM, oraz w jaki sposÃ³b nasze skrypty pisane w JavaScript mogÄ… oddziaÅ‚ywaÄ‡ z tÄ… strukturÄ….</p>

      <p class="article__paragraph">Za kaÅ¼dym razem gdy wczytamy stronÄ™ internetowÄ… nasza przeglÄ…darka, tworzy jej odwzorowanie w postaci drzewa DOM dodanego do obiektu globalnego <strong class="bold">window</strong>. W obiekcie <strong class="bold">window.document</strong> znajdziemy caÅ‚Ä… strukturÄ™ tagÃ³w naszego dokumentu HTML.</p>

      <section class="article__section">
        <h3 class="article__section__title">Drzewo DOM</h3>

        <p class="article__paragraph">SkÅ‚ada siÄ™ z wÄ™zÅ‚Ã³w. WÄ™zÅ‚y te mogÄ… zawieraÄ‡ kolejne pod wÄ™zÅ‚y. GÅ‚Ã³wnym elementem jest element <strong class="bold">&lt;html&gt;</strong> zwany korzeniem dokumentu. To od niego rozchodzÄ… siÄ™ kolejne rozgaÅ‚Ä™zienia. Przyjmijmy, Å¼e mamy nastÄ™pujÄ…cy dokument html:</p>

        <pre class="article__code">
        <code>
    &lt;!DOCTYPE html&gt;
    &lt;html lang="pl"&gt;
    &lt;head&gt;
      &lt;title&gt;DOM&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;header&gt;
        &lt;nav&gt;&lt;/nav&gt;
      &lt;/header&gt;
      &lt;main&gt;
        &lt;h1&gt;Title&lt;/h1&gt;
        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;
      &lt;/main&gt;
      &lt;footer&gt;
        &lt;a href="#"&gt;Link&lt;/a&gt;
      &lt;/footer&gt;
      &lt;script src="../scripts/code.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
        </code>
      </pre>

        <p class="article__paragraph">Graficznie moÅ¼emy go rozpisaÄ‡ w postaci nastÄ™pujÄ…cego drzewa DOM:</p>

        <img class="article__img" src="img/DOM%20tree.jpg" alt="DOM tree">

        <p class="article__paragraph">Gdy otworzymy narzÄ™dzia developerskie Chrome (F12) w zakÅ‚adce Elements, zobaczymy uproszczony model naszego drzewa DOM, ktÃ³ry nie zawiera pustych wÄ™zÅ‚Ã³w tekstowych oznaczajÄ…cych nowÄ… liniÄ™. KtÃ³re widzimy w powyÅ¼szym rozpisaniu.</p>

        <p class="article__paragraph">Nasze tagi HTML stajÄ… siÄ™ wÄ™zÅ‚ami elementÃ³w i tworzÄ… strukturÄ™ naszego drzewa. MoÅ¼emy myÅ›leÄ‡ o nich jak o rodzinie. KaÅ¼dy wÄ™zeÅ‚ ma swojego rodzica (czyli wÄ™zeÅ‚, ktÃ³ry go zawiera), ma teÅ¼ swoje dzieci (wÄ™zÅ‚y o jeden poziom niÅ¼ej), oraz rodzeÅ„stwo (wÄ™zÅ‚y na tym samym poziomie co on).</p>

        <p class="article__paragraph">Na przykÅ‚adzie wÄ™zÅ‚a <strong class="bold">&lt;main&gt;</strong>. WÄ™zÅ‚y <strong class="bold">&lt;header&gt;</strong> i <strong class="bold">&lt;footer&gt;</strong> sÄ… jego rodzeÅ„stwem. WÄ™zeÅ‚ <strong class="bold">&lt;body&gt;</strong> jest jego rodzicem. Natomiast wÄ™zÅ‚y <strong class="bold">&lt;h1&gt;</strong> i <strong class="bold">&lt;p&gt;</strong> sÄ… jego dzieÄ‡mi. W tym przykÅ‚adzie rozpatrujemy tylko wÄ™zÅ‚y elementÃ³w, pozostaÅ‚e typy wÄ™zÅ‚Ã³w pomijam. W sumie mamy 12 typÃ³w wÄ™zÅ‚Ã³w:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Element node</li>
          <li class="ordered-list__item">Attribute node</li>
          <li class="ordered-list__item">Text node</li>
          <li class="ordered-list__item">CData section node</li>
          <li class="ordered-list__item">Entity Reference node</li>
          <li class="ordered-list__item">Entity node</li>
          <li class="ordered-list__item">Processing Instruction node</li>
          <li class="ordered-list__item">Comment node</li>
          <li class="ordered-list__item">Document node</li>
          <li class="ordered-list__item">Document Type node</li>
          <li class="ordered-list__item">Document Fragment node</li>
          <li class="ordered-list__item">Notation node</li>
        </ol>

        <p class="article__paragraph">WiÄ™kszoÅ›Ä‡ z nich, nas nie interesuje i podajÄ™ je jedynie jako ciekawostkÄ™.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">OdwoÅ‚ywanie siÄ™ do elementÃ³w</h3>

        <p class="article__paragraph">Oto lista dostÄ™pnych metod, sÅ‚uÅ¼Ä…cych do pobierania elementÃ³w z naszego drzewa DOM:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">document.getElementById(<strong class="bold">'id'</strong>)</li>
          <li class="ordered-list__item">document.getElementsByClassName(<strong class="bold">'klasa'</strong>)</li>
          <li class="ordered-list__item">document.getElementsByTagName(<strong class="bold">'tag'</strong>)</li>
          <li class="ordered-list__item">document.querySelector(<strong class="bold">'selektor css'</strong>)</li>
          <li class="ordered-list__item">document.querySelectorAll(<strong class="bold">'selektor css'</strong>)</li>
        </ol>

        <pre class="article__code">
        <code>
    // pobiera element o podanym id

    const h1Element = document.getElementById('title');
    console.log(h1Element); // &lt;h1 id="title"&gt;Title&lt;/h1&gt;

    // pobiera kolekcjÄ™ elementÃ³w o podanej klasie

    const paragraphElements = document.getElementsByClassName('paragraph');
    console.log(paragraphElements); // HTMLCollection(2)[p.paragraph, p.paragraph]

    // pobiera kolekcjÄ™ elementÃ³w o danej nazwie tagu HTML

    const headerElement = document.getElementsByTagName('header');
    console.log(headerElement); // HTMLCollection[header]

    // pobiera pierwszy element wewnÄ…trz dokumentu, ktÃ³ry pasuje do podanego selektora

    const linkElement = document.querySelector('a[href="#title"]');
    console.log(linkElement); // &lt;a href="#title"&gt;Link&lt;/a&gt;

    const h1Element2 = document.querySelector('#title');
    console.log(h1Element2); // &lt;h1 id="title"&gt;Title&lt;/h1&gt;

    // pobiera wszystkie elementy wewnÄ…trz dokumentu, ktÃ³ry pasuje do podanego selektora

    const paragraphElements2 = document.querySelectorAll('.paragraph');
    console.log(paragraphElements2); // NodeList(2)[p.paragraph, p.paragraph]
        </code>
      </pre>

        <p class="article__paragraph">Widzimy powyÅ¼ej, Å¼e metoda <strong class="bold">querySelectorAll</strong> zwraca listÄ™ wÄ™zÅ‚Ã³w, natomiast wczeÅ›niejsze metody jak <strong class="bold">getElementsByClassName</strong> i <strong class="bold">getElementsByTagName</strong> zwracaÅ‚y kolekcjÄ™ elementÃ³w. Na czym polega rÃ³Å¼nica pomiÄ™dzy nimi ?</p>

        <h4 class="article__section__subtitle">Kolekcja ElementÃ³w (HTMLCollection)</h4>

        <p class="article__paragraph">Zawiera tylko listÄ™ elementÃ³w (element node). Jest â€Å¼ywaâ€ co oznacza, Å¼e jej zawartoÅ›Ä‡ jest aktualizowana na bieÅ¼Ä…co gdy w dokumencie pojawiajÄ… siÄ™ nowe elementy lub istniejÄ…ce sÄ… usuwane.</p>

        <h4 class="article__section__subtitle">Lista WÄ™zÅ‚Ã³w (NodeList)</h4>

        <p class="article__paragraph">MoÅ¼e zawieraÄ‡ dowolne wÄ™zÅ‚y (element node, text node, comment node itp.) IloÅ›Ä‡ jej elementÃ³w jest zazwyczaj statyczna (wyjÄ…tkiem jest metoda <strong class="bold">childNodes</strong>, ktÃ³ra zwraca â€Å¼ywÄ…â€ listÄ™ wÄ™zÅ‚Ã³w), i wynosi dokÅ‚adnie tyle ile ich byÅ‚o na stronie w momencie wywoÅ‚ania naszej metody, ktÃ³ra zwrÃ³ciÅ‚a nam listÄ™ wÄ™zÅ‚Ã³w.</p>

        <pre class="article__code">
        <code>
    // tworzymy nowy paragraf

    const newParagraph = document.createElement('p');

    // dodajemy mu klasÄ™ paragraph

    newParagraph.classList.add('paragraph');

    // dodajemy tekst do naszego paragrafu

    newParagraph.textContent = 'Jestem tekstem zawartym w nowym paragrafie.';

    // podczepiamy stworzony element do body naszego dokumentu

    document.body.appendChild(newParagraph);

    console.log(paragraphElements.length); // 3
    console.log(paragraphElements2.length); // 2
        </code>
      </pre>

        <p class="article__paragraph">W powyÅ¼szym przykÅ‚adzie widzimy, Å¼e nasza kolekcja elementÃ³w przechowywana w zmiennej <strong class="bold">paragraphElements</strong> zostaÅ‚a powiÄ™kszona o jeden. Podczas gdy wartoÅ›Ä‡ zmiennej <strong class="bold">paragraphElements2</strong> nie ulegÅ‚a zmianie.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Poruszanie siÄ™ po DOM</h3>

        <p class="article__paragraph">Nie musimy za kaÅ¼dym razem pobieraÄ‡ nowego elementu za pomocÄ… identyfikatora, klasy, nazwy tagu lub selektora CSS. MoÅ¼emy pobraÄ‡ tylko jeden element i za jego pomocÄ… przechodziÄ‡ do innych elementÃ³w.</p>

        <pre class="article__code">
        <code>
    const bodyElem = document.getElementsByTagName('body')[0];
    console.log(bodyElem); // &lt;body&gt;...&lt;/body&gt;

    // pobiera pierwszy wÄ™zeÅ‚ zawarty w tym elemencie
    console.log(bodyElem.firstChild); // #text

    // pobiera pierwszy element zawarty w tym elemencie
    console.log(bodyElem.firstElementChild); // &lt;header&gt;...&lt;/header&gt;

    // pobiera ostatni wÄ™zeÅ‚ zawarty w tym elemencie
    console.log(bodyElem.lastChild); // &lt;script src="scripts/code.js"&gt;&lt;/script&gt;

    // pobiera ostatni element zawarty w tym elemencie
    console.log(bodyElem.lastElementChild); // &lt;script src="scripts/code.js"&gt;&lt;/script&gt;

    // pobiera kolekcjÄ™ elementÃ³w zawartych w tym elemencie
    console.log(bodyElem.children);
    // HTMLCollection(4)[header, main, footer, script]

    // pobiera listÄ™ wÄ™zÅ‚Ã³w zawartych w tym elemencie
    console.log(bodyElem.childNodes);
    // NodeList(8)[text, header, text, main, text, footer, text, script]

    const mainElem = document.getElementsByTagName('main')[0];
    console.log(mainElem); // &lt;main&gt;...&lt;/main&gt;

    // pobiera wczeÅ›niejszy wÄ™zeÅ‚ na tym samym poziomie co dany element
    console.log(mainElem.previousSibling); // #text

    // pobiera wczeÅ›niejszy element na tym samym poziomie co dany element
    console.log(mainElem.previousElementSibling); // &lt;header&gt;...&lt;/header&gt;

    // pobiera nastÄ™pny wÄ™zeÅ‚ na tym samym poziomie co dany element
    console.log(mainElem.nextSibling); // #text

    // pobiera nastÄ™pny element na tym samym poziomie co dany element
    console.log(mainElem.nextElementSibling); // &lt;footer&gt;...&lt;/footer&gt;

    // pobiera wÄ™zeÅ‚ rodzica
    console.log(mainElem.parentNode); // &lt;body&gt;...&lt;/body&gt;

    // pobiera element rodzica
    console.log(mainElem.parentElement); // &lt;body&gt;...&lt;/body&gt;
        </code>
      </pre>

        <p class="article__paragraph">W powyÅ¼szym przykÅ‚adzie moÅ¼esz zauwaÅ¼yÄ‡, Å¼e pobieramy element przy uÅ¼yciu nazwy tagu <strong class="bold">document.getElementsByTagName('body')[0]</strong>. PoniewaÅ¼ metoda ta zwrÃ³ci nam kolekcie elementÃ³w HTML, zawierajÄ…cÄ… tylko jeden element. Pobieramy ten element przy pomocy nawiasÃ³w kwadratowych tak samo jak ze zwykÅ‚ej tablicy (array). NaleÅ¼y jednak pamiÄ™taÄ‡, o tym, Å¼e pomimo wielu podobieÅ„stw kolekcje elementÃ³w i listy wÄ™zÅ‚Ã³w, nie sÄ… tablicami JavaScript! Brakuje im kilku metod i wÅ‚aÅ›ciwoÅ›ci typowych dla tablic. Z tego teÅ¼ powodu moÅ¼emy je przeksztaÅ‚ciÄ‡ w standardowe tablice przy pomocy metody <strong class="bold">Array.from()</strong> lub w przypadku pÄ™tli po ich elementach ograniczyÄ‡ siÄ™ do stosowania zwyczajnej pÄ™tli <strong class="bold">for</strong>, ktÃ³ra dla nich dziaÅ‚a.</p>

        <p class="article__paragraph">KolejnÄ… rzeczÄ…, ktÃ³rÄ… zauwaÅ¼yÅ‚eÅ› jest to, Å¼e mamy dostÄ™pne bliÅºniacze metody, z ktÃ³rych jedna operuje na wszystkich wÄ™zÅ‚ach DOM, a druga zawÄ™Å¼a swoje dziaÅ‚anie tylko do wÄ™zÅ‚Ã³w, ktÃ³re sÄ… wÄ™zÅ‚ami elementÃ³w.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Usuwanie elementÃ³w</h3>

        <p class="article__paragraph">MoÅ¼emy usuwaÄ‡ â€dzieciâ€ elementÃ³w przy pomocy metody <strong class="bold">removeChild()</strong>, ktÃ³ra zwraca usuniÄ™ty wÄ™zeÅ‚. WÄ™zeÅ‚ ten nie jest caÅ‚kowicie niszczony i moÅ¼emy go ponownie podczepiÄ‡ do dowolnego elementu.</p>

        <pre class="article__code">
        <code>
    const mainElem = document.getElementsByTagName('main')[0];
    mainElem.removeChild(mainElem.lastElementChild);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie i dodawanie nowych elementÃ³w</h3>

        <p class="article__paragraph">Elementy tworzymy przy pomocy metody <strong class="bold">document.createElement()</strong>, utworzony w ten sposÃ³b element nie jest jeszcze widoczny na naszej stronie. Musimy go jeszcze podczepiÄ‡ do naszego drzewa DOM, przy pomocy jednej z dwÃ³ch metod: <strong class="bold">appendChild()</strong> lub <strong class="bold">insertBefore()</strong>.</p>

        <pre class="article__code">
        <code>
    const mainElem = document.querySelector('main');
    console.log(mainElem);

    const newTitleElem = document.createElement('h2');
    newTitleElem.textContent = 'Nowy podtytuÅ‚ dodany za pomocÄ… JavaScript';

    const newParagraphElem = document.createElement('p');
    const newTextNode = document.createTextNode('Nowy tekst paragrafu dodany za pomocÄ… JavaScript.');

    mainElem.appendChild(newParagraphElem);
    newParagraphElem.appendChild(newTextNode);

    mainElem.insertBefore(newTitleElem, mainElem.children[3]);
        </code>
      </pre>

        <p class="article__paragraph">Metoda <strong class="bold">appendChild(nowyElement)</strong> wstawia element na koniec listy dzieci okreÅ›lonego elementu. Natomiast metoda <strong class="bold">elementRodzic.insertBefore(nowyElement, wybranyElement)</strong> wstawia <strong class="bold">nowyelement</strong> przed <strong class="bold">wybranyelement</strong>.</p>
      </section>
    </article>


    <!-- Article 21 -->


    <article class="article">

      <header id="Zdarzenia" class="article__header">
        <div class="decor">21</div>
        <h2 class="article__title">Zdarzenia</h2>
      </header>

      <p class="article__paragraph">DziÄ™ki zdarzeniom moÅ¼emy zapewniÄ‡ interaktywnoÅ›Ä‡ naszej strony i polepszyÄ‡ wraÅ¼enia uÅ¼ytkownikÃ³w z niej korzystajÄ…cych. PrzykÅ‚adami zdarzeÅ„ sÄ…: klikniÄ™cie przycisku, skrolowanie treÅ›ci strony, zmiana rozmiaru okna przeglÄ…darki. Istnieje dÅ‚uga lista zdarzeÅ„ jakie mogÄ… zajÅ›Ä‡ w naszej przeglÄ…darce internetowej. Wszystkie one pozwalajÄ… nam poÅ‚Ä…czyÄ‡ kawaÅ‚ek kodu, ktÃ³ry chcemy wykonaÄ‡ w odpowiedzi na zajÅ›cie konkretnego zdarzenia.</p>

      <section class="article__section">
        <h3 class="article__section__title">Atrybuty HTML umieszczane inline</h3>

        <p class="article__paragraph">PolegajÄ… na umieszczaniu kodu JS wewnÄ…trz pliku HTML poprzez zastosowanie specjalnych atrybutÃ³w HTML. NaleÅ¼y unikaÄ‡ ich uÅ¼ywania, ale warto wiedzieÄ‡, Å¼e istnieje taki sposÃ³b, poniewaÅ¼ moÅ¼emy siÄ™ z nim zetknÄ…Ä‡.</p>

        <pre class="article__code">
        <code>
    &lt;button onclick="logMessage()"&gt;Nie klikaj mnie&lt;/button&gt;
    &lt;script&gt;
    function logMessage() {
      console.log('WiedziaÅ‚em, Å¼e siÄ™ nie posÅ‚uchasz.')
    }
    &lt;/script&gt;
        </code>
      </pre>

        <h4 class="article__section__subtitle">Dlaczego powyÅ¼szy sposÃ³b obsÅ‚ugi zdarzeÅ„ jest zÅ‚y ?</h4>

        <p class="article__paragraph">PoniewaÅ¼ miesza dwie warstwy ze sobÄ…, HTML odpowiedzialny za treÅ›Ä‡ i JS odpowiedzialny za zachowanie. Przez co jest mniej czytelny i trudniejszy w utrzymaniu. GdybyÅ› miaÅ‚ dziesiÄ…tki przyciskÃ³w na swojej stronie i musiaÅ‚ rÄ™cznie dodawaÄ‡ do nich atrybuty, szybko zauwaÅ¼yÅ‚ byÅ› jak kiepskim rozwiÄ…zaniem jest powyÅ¼sza praktyka.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wydarzenia jako wÅ‚aÅ›ciwoÅ›ci</h3>

        <p class="article__paragraph">To kolejny ze sposobÃ³w obsÅ‚ugi zdarzeÅ„ w naszej przeglÄ…darce. KaÅ¼dy element HTML posiada listÄ™ wÅ‚aÅ›ciwoÅ›ci, na ktÃ³rej moÅ¼emy zobaczyÄ‡ dÅ‚ugÄ… listÄ™ moÅ¼liwych zdarzeÅ„ dla tego elementu, zaczynajÄ…cych siÄ™ od przedrostka <strong class="bold">on</strong>, po ktÃ³rej mamy nazwÄ™ wydarzenia oraz wartoÅ›Ä‡ <strong class="bold">null</strong>, np: <strong class="bold">onclick: null</strong>.</p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('KlikneÅ‚eÅ› w przycisk!');
    }

    firstButton.onclick = logMessage;

    console.dir(firstButton); // onclick: Æ’ logMessage()
        </code>
      </pre>

        <p class="article__paragraph">W powyÅ¼szy sposÃ³b moÅ¼emy przypisaÄ‡ naszÄ… funkcjÄ™ do wybranego elementu. Gdy tylko zajdzie zdarzenie wskazanego typu dla tego elementu, nasza funkcja zostanie wywoÅ‚ana. Minusem tego rozwiÄ…zania jest fakt, Å¼e moÅ¼emy przypisaÄ‡ tylko pojedynczÄ… funkcjÄ™ do kaÅ¼dego ze zdarzeÅ„.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">SÅ‚uchacz zdarzeÅ„</h3>

        <p class="article__paragraph">To najnowsza i najlepsza z dostÄ™pnych moÅ¼liwoÅ›ci. Pozwala nam na dodanie â€sÅ‚uchaczaâ€ do elementu, ktÃ³ry bÄ™dzie nasÅ‚uchiwaÅ‚ wybranego zdarzenia i gdy tylko zarejestruje wystÄ…pienie danego zdarzenia odpali podanÄ… funkcjÄ™.</p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('KlikneÅ‚eÅ› w przycisk!');
    }

    firstButton.addEventListener('click', logMessage);
        </code>
      </pre>

        <p class="article__paragraph">Oto jakie korzyÅ›ci zapewnia nam ten sposÃ³b:</p>

        <p class="article__paragraph">1. Pozwala na dodanie wielu rÃ³Å¼nych funkcji do tego samego zdarzenia.</p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('KlikneÅ‚eÅ› w przycisk!');
    }

    function sayHello() {
      console.log('Dobrze CiÄ™ widzieÄ‡.');
    }

    firstButton.addEventListener('click', logMessage);
    firstButton.addEventListener('click', sayHello);
        </code>
      </pre>

        <p class="article__paragraph">2. Pozwala na usuwanie nasÅ‚uchiwaczy zdarzeÅ„ przez zastosowanie metody <strong class="bold">removeEventListener()</strong></p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('KlikneÅ‚eÅ› w przycisk!');
    }

    function sayHello() {
      console.log('Dobrze CiÄ™ widzieÄ‡.');
    }

    firstButton.addEventListener('click', logMessage);
    firstButton.addEventListener('click', sayHello);

    // wywoÅ‚ujemy zdarzenie z poziomu kodu, dziaÅ‚a tak jakby uÅ¼ytkownik kliknÄ… w nasz przycisk

    firstButton.click();
    // KlikneÅ‚eÅ› w przycisk!
    // Dobrze CiÄ™ widzieÄ‡.

    firstButton.removeEventListener('click', sayHello);

    firstButton.click();
    // KlikneÅ‚eÅ› w przycisk!
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Propagacja zdarzeÅ„</h3>

        <p class="article__paragraph">Wiemy, Å¼e struktura dokumentu HTML jest hierarchiczna i tworzy drzewo, w ktÃ³rym jedne elementy zawierajÄ… inne elementy. Gdy na naszej stronie wystÄ…pi zdarzenie np. klikniÄ™cia na dany element. To wystÄ…pienie tego zdarzenia rozchodzi siÄ™ niczym fala po wodzie rÃ³wnieÅ¼ po pozostaÅ‚ych elementach w dokumencie.</p>

        <p class="article__paragraph">ZaÅ‚Ã³Å¼my, Å¼e mamy nastÄ™pujÄ…cy ukÅ‚ad elementÃ³w HTML:</p>

        <pre class="article__code">
        <code>
    &lt;body&gt;
      &lt;div class="container"&gt;
        &lt;button class="button"&gt;Kliknji mnie!&lt;/button&gt;
      &lt;/div&gt;
    &lt;/body&gt;
        </code>
      </pre>

        <p class="article__paragraph">Gdy klikniemy element nastÄ™pujÄ… dwie fazy rozchodzenia siÄ™ tego wydarzenia. Najpierw wystÄ™puje <strong class="bold">przechwytywanie</strong> zdarzenia a nastÄ™pnie <strong class="bold">bÄ…belkowanie zdarzenia</strong>.</p>

        <p class="article__paragraph"><strong class="bold">przechwytywanie zdarzenia</strong> â€“ przesuwamy siÄ™ w dÃ³Å‚ naszego drzewa elementÃ³w i sprawdzamy czy dany element nasÅ‚uchuje danego zdarzenia w tej fazie. JeÅ›li tak, odpalamy danÄ… funkcjÄ™, ktÃ³ra obsÅ‚uguje wystÄ…pienie tego zdarzenia, a nastÄ™pnie przechodzimy do kolejnego elementu itd.</p>

        <p class="article__paragraph">body -&gt; div -&gt; button</p>

        <p class="article__paragraph"><strong class="bold">bÄ…belkowanie zdarzenia</strong> â€“ przesuwamy siÄ™ w gÃ³rÄ™ naszego drzewa elementÃ³w sprawdzamy czy dany element nasÅ‚uchuje danego zdarzenia w tej fazie. JeÅ›li tak, odpalamy danÄ… funkcjÄ™, ktÃ³ra obsÅ‚uguje wystÄ…pienie tego zdarzenia, a nastÄ™pnie przechodzimy do kolejnego elementu itd.</p>

        <p class="article__paragraph">button -&gt; div -&gt; body</p>

        <pre class="article__code">
        <code>
    const firstContainer = document.querySelector('.container');
    const firstButton = document.querySelector('.button');

    function buttonClick() {
      console.log('Przycisk zostaÅ‚ klikniÄ™ty.');
    }

    function containerClick() {
      console.log('Div zostaÅ‚ klikniÄ™ty.');
    }

    firstContainer.addEventListener('click', containerClick);
    firstButton.addEventListener('click', buttonClick);

    firstButton.click();
    // Przycisk zostaÅ‚ klikniÄ™ty.
    // Div zostaÅ‚ klikniÄ™ty
        </code>
      </pre>

        <p class="article__paragraph">Widzimy w powyÅ¼szym przykÅ‚adzie, Å¼e obie nasze funkcje zostaÅ‚y wywoÅ‚ane. Pomimo, Å¼e kliknÄ™liÅ›my tylko w przycisk, to zdarzenie to rozeszÅ‚o siÄ™ do elementu rodzica, ktÃ³ry rÃ³wnieÅ¼ nasÅ‚uchiwaÅ‚ zdarzenia typu <strong class="bold">click</strong>.</p>

        <p class="article__paragraph">Metoda <strong class="bold">addEventListener()</strong>, moÅ¼e rÃ³wnieÅ¼ przyjmowaÄ‡ trzeci parametr w postaci wartoÅ›ci <strong class="bold">true</strong>. DomyÅ›lnie jest on ustawiony na wartoÅ›Ä‡ <strong class="bold">false</strong>. Parametr ten oznacza w ktÃ³rej fazie rozchodzenia siÄ™ zdarzenia ma nastÄ…piÄ‡ jego przechwycenie. Gdy jego wartoÅ›Ä‡ wynosi <strong class="bold">true</strong>, odpalenie zdarzenia nastÄ™puje w fazie przechwytywania zdarzenia, a dla wartoÅ›ci <strong class="bold">false</strong> jest to faza bÄ…belkowania zdarzenia. MoÅ¼emy w ten sposÃ³b odwrÃ³ciÄ‡ kolejnoÅ›Ä‡ w jakiej zostanÄ… wywoÅ‚ane nasze funkcje.</p>

        <pre class="article__code">
        <code>
    firstContainer.addEventListener('click', containerClick, true);
    firstButton.addEventListener('click', buttonClick, false);

    firstButton.click();

    // Div zostaÅ‚ klikniÄ™ty.
    // Przycisk zostaÅ‚ klikniÄ™ty.
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy zatrzymaÄ‡ bÄ…belkowanie zdarzenia na wyÅ¼sze elementy poprzez metodÄ™ <strong class="bold">stopPropagation()</strong>. Wystarczy lekka modyfikacja naszej funkcji <strong class="bold">buttonClick</strong>, aby zapobiec odpaleniu funkcji <strong class="bold">containerClick</strong> przez klikniÄ™cie w przycisk.</p>

        <pre class="article__code">
        <code>
    function buttonClick(event) {
      event.stopPropagation();
      console.log('Przycisk zostaÅ‚ klikniÄ™ty.');
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt zdarzenia</h3>

        <p class="article__paragraph">W powyÅ¼szym przykÅ‚adzie widzimy pojawienie siÄ™ parametru <strong class="bold">event</strong>. Jest to obiekt zdarzenia, ktÃ³ry jest automatycznie przekazywany do naszej funkcji obsÅ‚ugujÄ…cej zaistniaÅ‚e zdarzenie. Niesie on z sobÄ… wiele informacji na temat zaistniaÅ‚ego zdarzenia jak np: typ zdarzenia â€“ <strong class="bold">event.type</strong>, element ktÃ³ry zapoczÄ…tkowaÅ‚ zdarzenie â€“ <strong class="bold">event.target</strong>.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Powstrzymywanie domyÅ›lnego zachowania dla zdarzeÅ„</h3>

        <p class="article__paragraph">NiektÃ³re wydarzenia jak np. wysÅ‚anie formularza z automatu wysyÅ‚ajÄ… pobrane z niego dane na serwer. JeÅ›li chcemy wykonaÄ‡ sprawdzenie poprawnoÅ›ci tych danych po stronie przeglÄ…darki uÅ¼ytkownika, musimy wyÅ‚Ä…czyÄ‡ domyÅ›lne zachowanie dla tego zdarzenia, Å¼eby mÃ³c przeprowadziÄ‡ nasze sprawdzenia. Robimy to za pomocÄ… metody <strong class="bold">preventDefault()</strong>.</p>

        <pre class="article__code">
        <code>
    const form = document.querySelector('#Form');
    console.log(form);

    function validate(event) {
      event.preventDefault();
      console.log('Wykonuje sprawdzenie poprawnoÅ›ci wprowadzonych danych');
    }

    form.addEventListener('submit', validate);
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 22 -->


    <article class="article">

      <header id="JSON" class="article__header">
        <div class="decor">22</div>
        <h2 class="article__title">JSON</h2>
      </header>

      <p class="article__paragraph">Za kaÅ¼dym razem gdy chcemy przesÅ‚aÄ‡ informacje za pomocÄ… sieci internet z pomocÄ… przychodzi nam JSON, jest to powszechnie uÅ¼ywany format danych do przesyÅ‚ania informacji.</p>

      <p class="article__paragraph">JSON to skrÃ³t od JavaScript Object Notation, czyli zapis w stylu obiektÃ³w JavaScript. PoniewaÅ¼ znasz juÅ¼ obiekty JavaScript, moÅ¼na powiedzieÄ‡, Å¼e znasz teÅ¼ JSON-a. Jednak nim krzykniesz â€huraâ€ i zamkniesz ten wpis. Wiedz, Å¼e wystÄ™puje pomiÄ™dzy nimi kilka rÃ³Å¼nic. Oto one:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">JSON zawiera tylko wÅ‚aÅ›ciwoÅ›ci.</li>
        <li class="ordered-list__item">Nazwy kluczy piszemy w cudzysÅ‚owach podwÃ³jnych.</li>
        <li class="ordered-list__item">Wymagany jest brak przecinka po ostatniej wÅ‚aÅ›ciwoÅ›ci.</li>
        <li class="ordered-list__item">Brak komentarzy i pojedynczych cudzysÅ‚owÃ³w.</li>
        <li class="ordered-list__item">WartoÅ›ci <strong class="bold">Infinity, NaN</strong> oraz <strong class="bold">undefined</strong> sÄ… zwracane jako <strong class="bold">null</strong> </li>
      </ol>

      <p class="article__paragraph">PrzykÅ‚adowy JSON:</p>

      <pre class="article__code">
        <code>
    {
      "name": "Tomasz",
      "age": 29,
      "alive": true,
      "login": null,
      "favoriteFilms": ["Forrest Gump", "Najlepszy", "Matrix", "Zielona Mila", "Dwunastu gniewnych ludzi", "Siedem"],
      "favoriteBook": {"title": "The Slight Edge","author": "Jeff Olson","publisher": "Greenleaf Book Group Press"}
    }
        </code>
      </pre>

      <p class="article__paragraph">NajczÄ™Å›ciej dane zapisane w formacie <strong class="bold">.json</strong>, mogÄ… byÄ‡ w postaci pojedynczego obiektu (powyÅ¼szy przykÅ‚ad) lub tablicy zawierajÄ…cej wiele obiektÃ³w (poniÅ¼szy przykÅ‚ad).</p>

      <pre class="article__code">
        <code>
    [
      {
        "name": "Tomasz"
      },
      {
        "name": "Marcin"
      },
      {
        "name": "Daniel"
      }
    ]
        </code>
      </pre>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt JSON</h3>

        <p class="article__paragraph">Aby mÃ³c z Å‚atwoÅ›ciÄ… zamieniaÄ‡ obiekty JavaScript na format .json lub na odwrÃ³t. Mamy dostÄ™pny pojedynczy wbudowany obiekt o nazwie <strong class="bold">JSON</strong>. Zapewnia on nam dwie metody <strong class="bold">stringify(value, replacer,  space)</strong> oraz <strong class="bold">parse(text, reviver)</strong>.</p>

        <h4 class="article__section__subtitle">stringify</h4>

        <p class="article__paragraph">SÅ‚uÅ¼y do zamiany na format json. Jako pierwszy argument przyjmuje nasze dane. Kolejne argumenty sÄ… opcjonalne, drugi z nich pozwala nam na przefiltrowanie danych, ktÃ³re chcemy zamieniÄ‡. MoÅ¼e byÄ‡ podany w postaci funkcji, ktÃ³ra przyjmuje dwa parametry <strong class="bold">(key, value)</strong> lub w postaci tablicy. W takim przypadku zostanÄ… nam zwrÃ³cone tylko te wÅ‚aÅ›ciwoÅ›ci, ktÃ³re sÄ… w niej zawarte. Ostatnim, trzecim argumentem jest cyfra, oznaczajÄ…ca o ile spacji bÄ™dÄ… wciÄ™te nasze dane, lub ciÄ…g znakÃ³w sÅ‚uÅ¼Ä…cy za wciÄ™cia. Argument ten sÅ‚uÅ¼y tylko do tego aby wynik byÅ‚ bardziej czytelny dla nas ludzi.</p>

        <pre class="article__code">
        <code>
    const userData = {
      // WÅ‚aÅ›ciwoÅ›ci

      name: 'Tomasz',
      age: 29,
      alive: true,
      login: null,
      favoriteFilms: ['Forrest Gump', 'Najlepszy', 'Matrix', 'Zielona Mila', 'Dwunastu gniewnych ludzi', 'Siedem'],
      favoriteBook: {
        title: 'The Slight Edge',
        author: 'Jeff Olson',
        publisher: 'Greenleaf Book Group Press'
      },

      // Metody

      getUserName: function() {
        return this.name;
      }
    };

    const jsonData = JSON.stringify(userData, null, 2);
    console.log(jsonData);

    /*
    {
      "name": "Tomasz",
      "age": 29,
      "alive": true,
      "login": null,
      "favoriteFilms": [
        "Forrest Gump",
        "Najlepszy",
        "Matrix",
        "Zielona Mila",
        "Dwunastu gniewnych ludzi",
        "Siedem"
      ],
      "favoriteBook": {
        "title": "The Slight Edge",
        "author": "Jeff Olson",
        "publisher": "Greenleaf Book Group Press"
      }
    }
    */

    function replacer(key, value) {
      if (typeof value === 'string') {
        return undefined;
      }
      return value;
    }

    const filteredJsonData = JSON.stringify(userData, replacer, '--');
    console.log(filteredJsonData);

    /*
    {
    --"age": 29,
    --"alive": true,
    --"login": null,
    --"favoriteFilms": [
    ----null,
    ----null,
    ----null,
    ----null,
    ----null,
    ----null
    --],
    --"favoriteBook": {}
    }
    */

    const filteredJsonData2 = JSON.stringify(userData, ['favoriteFilms'], 2);
    console.log(filteredJsonData2);

    /*
    {
      "favoriteFilms": [
        "Forrest Gump",
        "Najlepszy",
        "Matrix",
        "Zielona Mila",
        "Dwunastu gniewnych ludzi",
        "Siedem"
      ]
    }
    */
        </code>
      </pre>


        <h4 class="article__section__subtitle">parse</h4>

        <p class="article__paragraph">Zamienia ciÄ…g znakÃ³w .json na obiekt lub wartoÅ›Ä‡ JavaScript. Tak samo jak wczeÅ›niej pierwszym argumentem sÄ… nasze dane. Natomiast drugim, opcjonalnym argumentem jest funkcja przeksztaÅ‚cajÄ…ca nasze dane zanim zostanÄ… zwrÃ³cone.</p>

        <pre class="article__code">
        <code>
    const receivedData = JSON.parse(jsonData);
    console.log(receivedData);

    // {name: "Tomasz", age: 29, alive: true, login: null, favoriteFilms: Array(6), â€¦}

    function reviver(key, value) {
      if (value === null ||
         (Array.isArray(value)) &amp;&amp; value.length === 0 ||
         (typeof value === 'object' &amp;&amp; Object.keys(value).length === 0)) {
        return undefined;
      }
      return value;
    }

    const receivedData2 = JSON.parse(filteredJsonData, reviver);
    console.log(receivedData2);

    // {age: 29, alive: true}

    const receivedData3 = JSON.parse(filteredJsonData2);
    console.log(receivedData3);

    // {favoriteFilms: Array(6)}
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 23 -->


    <article class="article">

      <header id="HTTP" class="article__header">
        <div class="decor">23</div>
        <h2 class="article__title">HTTP</h2>
      </header>

      <p class="article__paragraph">Dzisiaj robimy maÅ‚Ä… przerwÄ™ od JavaScript Å¼eby zrozumieÄ‡ jak dziaÅ‚a przesyÅ‚anie informacji przez sieÄ‡. Wiedza ta przyda siÄ™ nam, gdy bÄ™dziemy omawiaÄ‡ AJAX-a czyli asynchroniczny JavaScript i XML.</p>

      <section class="article__section">
        <h3 class="article__section__title">ProtokÃ³Å‚ HTTP</h3>

        <p class="article__paragraph">SÅ‚uÅ¼y do przesyÅ‚ania stron internetowych do naszych przeglÄ…darek oraz do wysyÅ‚ania informacji na serwer. Jest to protokÃ³Å‚ klient-serwer co oznacza, Å¼e Å¼Ä…dania sÄ… inicjowane przez naszÄ… przeglÄ…darkÄ™ internetowÄ…. Za kaÅ¼dym razem gdy wchodzimy na stronÄ™ inicjujemy Å¼Ä…dania do serwera jej poszczegÃ³lnych elementÃ³w jak np: tekst, arkusze stylÃ³w CSS, skrypty JavaScript, obrazki, nagrania wideo itp. Im wiÄ™cej Å¼Ä…daÅ„ i im wiÄ™ksze sÄ… pliki, ktÃ³re sÄ… przesyÅ‚ane tym dÅ‚uÅ¼szy jest czas oczekiwania na zaÅ‚adowanie naszej strony.</p>

        <p class="article__paragraph">Komunikacja z serwerem odbywa siÄ™ na podstawie pojedynczych wiadomoÅ›ci. RÃ³Å¼ne czÄ™Å›ci naszej strony mogÄ… znajdowaÄ‡ siÄ™ na rÃ³Å¼nych serwerach. WiadomoÅ›Ä‡ wysyÅ‚anÄ… przez naszÄ… przeglÄ…darkÄ™ nazywany <strong class="bold">Å¼Ä…daniem</strong>, natomiast wiadomoÅ›Ä‡ wysyÅ‚ana przez serwer to <strong class="bold">odpowiedÅº</strong>. HTTP jest bezstanowy, oznacza to, Å¼e kaÅ¼de z naszych Å¼Ä…daÅ„ jest nie zaleÅ¼ne i nie wie nic o innych Å¼Ä…daniach jakie wykonaliÅ›my do tej pory, przy uÅ¼yciu tego samego poÅ‚Ä…czenia.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Co moÅ¼emy kontrolowaÄ‡ przy uÅ¼yciu HTTP ?</h3>

        <h4 class="article__section__subtitle">1 PamiÄ™Ä‡ podrÄ™czna</h4>

        <p class="article__paragraph">Å»eby zwiÄ™kszyÄ‡ szybkoÅ›Ä‡ wczytywania stron, ktÃ³re czÄ™sto odwiedzamy oraz zmniejszyÄ‡ ruch, czyli tym samym zmniejszyÄ‡ obciÄ…Å¼enie serwera, korzystamy z pamiÄ™ci podrÄ™cznej, ktÃ³ra pozwala nam wykorzystaÄ‡ wczeÅ›niej pobrane zasoby. DziÄ™ki HTTP serwer moÅ¼e poinformowaÄ‡ serwery proxy (serwery poÅ›redniczÄ…ce w wymianie informacji) oraz naszÄ… przeglÄ…darkÄ™ jakie zasoby ma przechowywaÄ‡, przez jaki okres czasu.</p>

        <h4 class="article__section__subtitle">2 Uwierzytelnianie</h4>

        <p class="article__paragraph">Aby ograniczyÄ‡ dostÄ™pnoÅ›Ä‡ do naszej strony, tak aby tylko wybrani uÅ¼ytkownicy mieli do niej dostÄ™p, moÅ¼emy wykorzystaÄ‡ podstawowe metody uwierzytelniania zapewniane przez HTTP, WWW-Authenticate lub poprzez ustawienie okreÅ›lonej sesji przy uÅ¼yciu plikÃ³w cookie HTTP.</p>

        <h4 class="article__section__subtitle">3 Proxy</h4>

        <p class="article__paragraph">JeÅ›li chcemy pozostaÄ‡ anonimowi w sieci i ukryÄ‡ nasz prawdziwy adres IP. MoÅ¼emy to zrobiÄ‡ przy pomocy sieci Tor.</p>

        <h4 class="article__section__subtitle">4 Sesje</h4>

        <p class="article__paragraph">UÅ¼ywanie ciasteczek HTTP pozwala poÅ‚Ä…czyÄ‡ ze sobÄ… oddzielne zapytania pochodzÄ…ce od tego samego klienta. DziÄ™ki temu moÅ¼emy stwierdziÄ‡ czy dane Å¼Ä…danie pochodzi od tego samego uÅ¼ytkownika. Tworzy to sesje, mimo Å¼e podstawowy protokÃ³Å‚ HTTP jest protokoÅ‚em bezstanowym.</p>

        <h4 class="article__section__subtitle">5 CORS</h4>

        <p class="article__paragraph">DziÄ™ki nagÅ‚Ã³wkom HTTP moÅ¼emy zmniejszyÄ‡ obostrzenia zwiÄ…zane z CORS (Cross-Origin Resource Sharing), ktÃ³re polega na blokowaniu danych pochodzÄ…cych z innych ÅºrÃ³deÅ‚ niÅ¼ domena naszej strony.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Å»Ä…dania i odpowiedzi</h3>

        <p class="article__paragraph">DokÅ‚adnej strukturze Å¼Ä…dania i odpowiedzi przyjrzymy siÄ™ w kolejnym wpisie. Dzisiaj natomiast powiemy sobie ogÃ³lnie z czego siÄ™ skÅ‚ada Å¼Ä…danie i odpowiedÅº. Oraz omÃ³wimy statusy otrzymanych odpowiedzi.</p>

        <p class="article__paragraph">ZarÃ³wno Å¼Ä…danie jak i odpowiedÅº zawierajÄ… wersjÄ™ protokoÅ‚u HTTP jaki jest wykorzystywany w komunikacji, nagÅ‚Ã³wki oraz ewentualne ciaÅ‚o wiadomoÅ›ci.</p>

        <p class="article__paragraph">Å»Ä…danie natomiast zawiera dodatkowo adres URL zasobu, do ktÃ³rego chcemy siÄ™ odwoÅ‚aÄ‡ oraz nazwÄ™ metody, okreÅ›lajÄ…cej rodzaj wysyÅ‚anego Å¼Ä…dania.</p>

        <p class="article__paragraph">OdpowiedÅº natomiast zawiera dodatkowo status, informujÄ…cy czy dane Å¼Ä…danie zakoÅ„czyÅ‚o siÄ™ sukcesem lub poraÅ¼kÄ… oraz opis danego kodu statusu.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Statusy HTTP</h3>

        <p class="article__paragraph">ZostaÅ‚y podzielone na 5 grup. Pierwsza cyfra okreÅ›la grupÄ™ do jakiej naleÅ¼y dany status. Mamy wiÄ™c:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Statusy informacyjne â€“ zaczynajÄ…ce siÄ™ od 1 np. 101</li>
          <li class="ordered-list__item">Statusy sukcesu â€“ zaczynajÄ…ce siÄ™ od 2 np. 200</li>
          <li class="ordered-list__item">Statusy przekierowaÅ„ â€“ zaczynajÄ…ce siÄ™ od 3 np. 301</li>
          <li class="ordered-list__item">Statusy bÅ‚Ä™dÃ³w po stronie klienta â€“ zaczynajÄ…ce siÄ™ od 4 np. 404</li>
          <li class="ordered-list__item">Statusy bÅ‚Ä™dÃ³w po stronie serwera â€“ zaczynajÄ…ce siÄ™ od 5 np. 500</li>
        </ol>

        <p class="article__paragraph">NajczÄ™Å›ciej wystÄ™pujÄ…ce kody statusu to:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item"><strong class="bold">200 OK</strong> â€“ wszystko przebiegÅ‚o pomyÅ›lnie</li>
          <li class="unordered-list__item"><strong class="bold">301 Moved Permanently</strong> â€“ informuje klienta, Å¼e zasÃ³b zostaÅ‚ przeniesiony na staÅ‚e w inne miejsce. Taki status informuje wyszukiwarki o tym, Å¼e strona, ktÃ³ra wczeÅ›niej byÅ‚a pod adresem X znajduje siÄ™ w nowym miejscu</li>
          <li class="unordered-list__item"><strong class="bold">400 Bad Request</strong> â€“ serwer informuje klienta o bÅ‚Ä™dnym zapytaniu, ktÃ³re nie bÄ™dzie przetworzone</li>
          <li class="unordered-list__item"><strong class="bold">403 Forbidden</strong> â€“ zasÃ³b wymaga uwierzytelnienia, po potwierdzeniu toÅ¼samoÅ›ci moÅ¼e byÄ‡ dostÄ™pny</li>
          <li class="unordered-list__item"><strong class="bold">404 Not Found</strong> â€“ Å¼Ä…dany zasÃ³b nie istnieje</li>
          <li class="unordered-list__item"><strong class="bold">500 Internal Server Error</strong> â€“ serwer napotkaÅ‚ sytuacje, ktÃ³rej nie umie poprawnie obsÅ‚uÅ¼yÄ‡</li>
          <li class="unordered-list__item"><strong class="bold">502 Bad Gateway</strong> â€“ ten status informuje o tym, Å¼e jeden z poÅ›rednich wÄ™zÅ‚Ã³w dostaÅ‚ bÅ‚Ä™dnÄ… odpowiedÅº od poprzedniego wÄ™zÅ‚a</li>
          <li class="unordered-list__item"><strong class="bold">503 Service Unavailable</strong> â€“ ten bÅ‚Ä…d informuje o tym, Å¼e serwer jest przeciÄ…Å¼ony, ponowna prÃ³ba moÅ¼e zakoÅ„czyÄ‡ siÄ™ poprawnÄ… odpowiedziÄ…</li>
        </ul>
      </section>
    </article>


    <!-- Article 24 -->


    <article class="article">

      <header id="REST_API" class="article__header">
        <div class="decor">24</div>
        <h2 class="article__title">REST API</h2>
      </header>

      <p class="article__paragraph">Kontynuujemy temat rozpoczÄ™ty w poprzednim wpisie. Czym jest API juÅ¼ wiemy z postu o DOM. Natomiast REST (Representational State Transfer) odnosi siÄ™ do sposobu tworzenia takiego API. Jest ono zbudowane na protokole HTTP, w oparciu o 5 zasad:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Jednolity interfejs (Uniform Interface) â€“ oznacza, Å¼e istnieje jeden interfejs, ktÃ³ry obsÅ‚uguje wszystkie typy urzÄ…dzeÅ„, ktÃ³re siÄ™ z nim Å‚Ä…czÄ….</li>
        <li class="ordered-list__item">Klient-serwer (Client-Server) â€“ oznacza rozdzielenie aplikacji po stronie klienta i po stronie serwera.</li>
        <li class="ordered-list__item">Pozbawiony stanu (Stateless) â€“ kaÅ¼de Å¼Ä…danie jest nie zaleÅ¼ne od innych Å¼Ä…daÅ„ i posiada komplet informacji niezbÄ™dnych do jego przetworzenia.</li>
        <li class="ordered-list__item">UÅ¼ywa pamiÄ™ci podrÄ™cznej (Cachable) â€“ Å¼eby odciÄ…Å¼yÄ‡ serwer czÄ™Å›Ä‡ danych powinna byÄ‡ zapisywana w pamiÄ™ci podrÄ™cznej i stamtÄ…d pobierana.</li>
        <li class="ordered-list__item">Zbudowany warstwowo (Layered System) â€“ wysyÅ‚ajÄ…c Å¼Ä…danie do serwera, nasz klient nie powinien wiedzieÄ‡ dokÄ…d odwoÅ‚uje siÄ™ serwer Å¼eby wysÅ‚aÄ‡ nam gotowÄ… odpowiedÅº.</li>
      </ol>

      <section class="article__section">
        <h3 class="article__section__title">Zasoby</h3>

        <p class="article__paragraph">Celem istnienia naszego REST API jest dodawanie, pobieranie, modyfikowanie i kasowanie zasobÃ³w. Zasobami mogÄ… byÄ‡ np. dane naszych uÅ¼ytkownikÃ³w. KaÅ¼dy zasÃ³b jest identyfikowany poprzez <strong class="bold">URI</strong> (Uniform Resource Identifier) czyli Å‚aÅ„cuch znakÃ³w jak np. <strong class="bold">http://blog.tomasz-rybacki.pl</strong>. Dodatkowo zasoby znajdujÄ…ce siÄ™ w sieci posiadajÄ… swÃ³j <strong class="bold">URL</strong> (Uniform Resource Locator), ktÃ³ry okreÅ›la ich poÅ‚oÅ¼enie.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Budowa adresu URL</h3>

        <span class="article__command">scheme://[user:password]@host:port]/path?query#fragment</span>

        <p class="article__paragraph"><strong class="bold">scheme</strong> â€“ okreÅ›la wykorzystywany protokÃ³Å‚ jak http lub https</p>

        <p class="article__paragraph"><strong class="bold">user:password</strong> â€“ sÅ‚uÅ¼y do potwierdzania toÅ¼samoÅ›ci uÅ¼ytkownika, ze wzglÄ™dÃ³w bezpieczeÅ„stwa nie jest jednak wykorzystywany, poniewaÅ¼ z Å‚atwoÅ›ciÄ… moÅ¼na odczytaÄ‡ informacje przesyÅ‚ane w ten sposÃ³b</p>

        <p class="article__paragraph"><strong class="bold">host</strong> â€“ okreÅ›la nazwÄ™ domeny lub jej adres IP</p>

        <p class="article__paragraph"><strong class="bold">port</strong> â€“ okreÅ›la numer portu, ktÃ³ry â€nasÅ‚uchujeâ€ serwer. ProtokoÅ‚y majÄ… przypisane domyÅ›lne porty dla http wartoÅ›Ä‡ ta wynosi 80 natomiast dla https rÃ³wna siÄ™ 443</p>

        <p class="article__paragraph"><strong class="bold">path</strong> â€“ Å›cieÅ¼ka dostÄ™pu do zasobu np: /kurs-javascript/21-dom</p>

        <p class="article__paragraph"><strong class="bold">query</strong> â€“ zaczyna siÄ™ od znaku zapytania. Zawiera pary klucz=wartoÅ›Ä‡ poÅ‚Ä…czone znakiem &amp;. SÅ‚uÅ¼y do podawania dodatkowych danych identyfikujÄ…cych zasÃ³b</p>

        <p class="article__paragraph"><strong class="bold">fragment</strong> â€“ oznacza fragment strony HTML, ktÃ³ra powinna zostaÄ‡ wyÅ›wietlona uÅ¼ytkownikowi</p>

        <p class="article__paragraph">PrzykÅ‚adowy URL:</p>

        <span class="article__command">http://blog.tomasz-rybacki.pl/kurs-javascript/21-dom/#comments</span>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Metody HTTP</h3>

        <p class="article__paragraph">WpisujÄ…c powyÅ¼szy URL do naszej przeglÄ…darki zostaniemy przeniesieni do sekcji komentarzy wpisu o DOM na moim blogu. Stanie siÄ™ tak poniewaÅ¼ nasza przeglÄ…darka uÅ¼yje metody GET aby pobraÄ‡ zasÃ³b jaki znajduje siÄ™ pod wskazanym adresem. W odpowiedzi serwer zwrÃ³ci jej wskazany plik HTML, na podstawie ktÃ³rego zostanie wyÅ›wietlona caÅ‚a strona.</p>

        <p class="article__paragraph">Istnieje 8 metod http do przeprowadzania rÃ³Å¼nych operacji. NaleÅ¼Ä… do nich:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">GET</li>
          <li class="ordered-list__item">POST</li>
          <li class="ordered-list__item">PUT</li>
          <li class="ordered-list__item">DELETE</li>
          <li class="ordered-list__item">OPTIONS</li>
          <li class="ordered-list__item">HEAD</li>
          <li class="ordered-list__item">TRACE</li>
          <li class="ordered-list__item">CONNECT</li>
        </ol>

        <p class="article__paragraph">DziÄ™ki tym metodom moÅ¼emy powiÄ…zaÄ‡ rÃ³Å¼ne akcje jakie majÄ… zostaÄ‡ wykonane dla naszego zasobu, zachowujÄ…c ten sam adres URL np. GET /posts i POST /posts.</p>

        <p class="article__paragraph"><strong class="bold">GET</strong> â€“ odczytuje wskazany zasÃ³b, moÅ¼e zawieraÄ‡ dodatkowe parametry w postaci query string</p>

        <p class="article__paragraph"><strong class="bold">POST</strong> â€“ przesyÅ‚a dane do wskazanego zasobu</p>

        <p class="article__paragraph"><strong class="bold">PUT</strong> â€“ sÅ‚uÅ¼y do aktualizacji danego zasobu</p>

        <p class="article__paragraph"><strong class="bold">DELETE</strong> â€“ sÅ‚uÅ¼y do usuwania zasobÃ³w</p>

        <p class="article__paragraph"><strong class="bold">OPTIONS</strong> â€“ uÅ¼ywane jest do sprawdzania jakie metody sÄ… obsÅ‚ugiwane przez serwer dla danego zasobu</p>

        <p class="article__paragraph"><strong class="bold">HEAD</strong> â€“ sÅ‚uÅ¼y do sprawdzania czy dany zasÃ³b siÄ™ zmieniÅ‚. Jest podobne do zapytania GET z tÄ… rÃ³Å¼nicÄ…, Å¼e nie zawiera ciaÅ‚a wiadomoÅ›ci.</p>

        <p class="article__paragraph"><strong class="bold">TRACE</strong> â€“ sÅ‚uÅ¼y do testowania. W odpowiedzi na nie serwer powinien wysÅ‚aÄ‡ zapytanie, ktÃ³re otrzymaÅ‚. Nie zawiera ciaÅ‚a wiadomoÅ›ci.</p>

        <p class="article__paragraph"><strong class="bold">CONNECT</strong> â€“ sÅ‚uÅ¼y do utworzenia poÅ‚Ä…czenia pomiÄ™dzy klientem a serwerem docelowym za pomocÄ… wÄ™zÅ‚Ã³w poÅ›rednich. W praktyce rzadko stosowane.</p>
      </section>
    </article>


    <!-- Article 25 -->


    <footer class="documentation__footer">
      <span class="footer__txt">designed &amp; coded with <span class="footer__icon">&#10084;</span> by <span class="footer__bold">&copy; Tomasz Rybacki</span> in 2018</span>
    </footer>
  </main>


  <script src="scripts/jquery-3.2.0.min.js"></script>
  <script src="scripts/code.js"></script>
</body>

</html>
