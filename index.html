<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <meta name="author" content="Tomasz Rybacki">
  <meta name="description" content="Responsive Web Design Projects - Build a Technical Documentation Page">

  <title>Technical Documentation Page</title>
  <link rel="icon" type="image/png" sizes="96x96" href="img/favicon96x96.png">

  <link href="https://fonts.googleapis.com/css?family=Muli:400,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="stylesheet" href="css/main.css">

</head>

<body class="body">

  <button class="menu" id="menu-button">
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
  </button>

  <nav id="navbar" class="navigation">
    <header class="navigation__header">
      <h1 class="header__title">Kurs JavaScript</h1>
    </header>
    <ol class="navigation__list">
      <li class="nav-item"><a class="nav-link" href="#Czym_jest_javaScript">01. Czym jest javaScript ?</a></li>
      <li class="nav-item"><a class="nav-link" href="#Debugowanie_cz1">02. Debugowanie cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Debugowanie_cz2">03. Debugowanie cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Typy_wartosci">04. Typy wartości</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zmienne_cz1">05. Zmienne cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zmienne_cz2">06. Zmienne cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Operatory">07. Operatory</a></li>
      <li class="nav-item"><a class="nav-link" href="#Konwersja_typow">08. Konwersja typów</a></li>
      <li class="nav-item"><a class="nav-link" href="#Instrukcje_warunkowe">09. Instrukcje warunkowe</a></li>
      <li class="nav-item"><a class="nav-link" href="#Tablice">10. Tablice</a></li>
      <li class="nav-item"><a class="nav-link" href="#Podstawowe_petle">11. Podstawowe pętle</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz1">12. Funkcje cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz2">13. Funkcje cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz3">14. Funkcje cz.3</a></li>
      <li class="nav-item"><a class="nav-link" href="#Objekty_cz1">15. Objekty cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Objekty_cz2">16. Objekty cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Klasy">17. Klasy</a></li>
      <li class="nav-item"><a class="nav-link" href="#Obiekty_opakowujace">18. Obiekty opakowujące</a></li>
      <li class="nav-item"><a class="nav-link" href="#Obiekty_wbudowane">19. Obiekty wbudowane</a></li>
      <li class="nav-item"><a class="nav-link" href="#DOM">20. DOM</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zdarzenia">21. Zdarzenia</a></li>
      <li class="nav-item"><a class="nav-link" href="#JSON">22. JSON</a></li>
      <li class="nav-item"><a class="nav-link" href="#HTTP">23. HTTP</a></li>
      <li class="nav-item"><a class="nav-link" href="#REST_API">24. REST API</a></li>
    </ol>
  </nav>

  <div class="push"></div>

  <main id="main-doc" class="documentation">

    <header class="documentation__header">
      <img class="header__banner" src="img/JavaScript-banner.jpg" alt="banner javaScript">
      <span class="header__txt">Kurs ten powstał w ramach mojego <a class="blog-link" href="http://blog.tomasz-rybacki.pl">bloga</a>.<br> Zachęcam Cię do jego odwiedzenia oraz życzę owocnej nauki programowania w JavaScript.</span>
    </header>


    <!-- Article 01 -->


    <article class="article">

      <header id="Czym_jest_javaScript" class="article__header">
        <div class="decor">01</div>
        <h2 class="article__title">Czym jest javaScript ?</h2>
      </header>

      <p class="article__paragraph">W wikipedii czytamy, że jest to skryptowy język programowania. Wyjaśnijmy sobie co to oznacza.</p>

      <p class="article__paragraph">Programy napisane w tym języku nie wymagają kompilacji do kodu maszynowego, który jest zapisywany w postaci binarnej (same zera i jedynki). Kod ten jest bezpośrednio wykonywany przez procesor komputera. Zamiast tego nasze skrypty są wykonywane za pomocą interpretera, który analizuje każde wyrażenie przed jego wykonaniem.</p>

      <p class="article__paragraph">JavaScript jest językiem wysokiego poziomu co oznacza, że pisząc w nim nie przejmujemy się wszystkim tym co dzieje się „pod maską” jak: zarządzanie pamięcią, przechowywanie danych, wewnętrzne typy danych. Dzięki temu można dosyć szybko poznać jego podstawy i zacząć samodzielnie pisać skrypty. Używamy w nim abstrakcji do ukrycia technicznych detali. Kod piszemy przy pomocy angielskich słów, dzięki temu odczytywanie go jest proste, niczym czytanie instrukcji obsługi nowo zakupionego urządzenia AGD 🙂</p>

      <p class="article__paragraph">Skrypty, które w nim piszemy są wykonywane w całości od początku do końca. Z góry na dół, od lewej do prawej. Są to zasady, które wszyscy dobrze znamy i z których korzystamy na co dzień podczas czytania. Nasz kod JavaScript działa w pewnym środowisku. Może być to przeglądarka internetowa (na tym środowisku skupimy się w tym kursie) lub np. Node.js, w którym to możemy uruchamiać kod JavaScript po stronie serwera lub w wierszu poleceń naszego komputera. Od naszego środowiska zależy do jakich obiektów globalnych będziemy mieli dostęp. Z niego wynika zastosowanie naszego kodu. Mogą być to wszystkie interakcje użytkownika ze stroną internetową lub logika wykonywana po stronie serwera.</p>

      <p class="article__paragraph">Współczesne narzędzia jak silnik JavaScript V8 w Google Chrome, kompilują nasz kod w chwili wykonania. Pozwala to na jeszcze szybsze działanie naszych programów.</p>

      <p class="article__paragraph">Ciekawostką jest sama nazwa tego języka programowania. Początkowo nazywał się LiveScript, jednak na fali rosnącej popularności i sukcesu jakim cieszył się język Java. Został przemianowany na JavaScript. Został więc jego młodszym bratem i przedmiotem żartów. Ponieważ osoby kompletnie zielone często utożsamiają te dwa różne języki programowania ze sobą. Myśląc, że są tym samym.</p>

    </article>


    <!-- Article 02 -->


    <article class="article">

      <header id="Debugowanie_cz1" class="article__header">
        <div class="decor">02</div>
        <h2 class="article__title">Debugowanie cz.1</h2>
      </header>


      <p class="article__paragraph">Dzisiaj skonfigurujemy nasz projekt, w którym będziemy uczyć się kolejnych zagadnień związanych z JavaScript. Powiemy sobie również na temat błędów i sposobów radzenia sobie z nimi. Zakładam, że masz już zainstalowanego Bracketsa oraz przeglądarkę Chrome.</p>

      <section class="article__section">
        <h3 class="article__section__title">Projekt</h3>
        <p class="article__paragraph">Tworzymy nowy folder do przechowywania naszych plików. Ja nazwałem swój <strong class="bold">Kurs.</strong> Wewnątrz tworzymy nowy folder scripts, w którym będą znajdować się wszystkie nasze skrypty. Tworzymy tam nowy plik o nazwie <strong class="bold">code.js.</strong> Teraz potrzebujemy utworzyć podstawowy plik html o nazwie <strong class="bold">index.html</strong> w folderze głównym.</p>

        <pre class="article__code">
        <code>
    &lt;!DOCTYPE html&gt;
    &lt;html lang="pl"&gt;

      &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;

        &lt;meta name="author" content="Tomasz Rybacki"&gt;
        &lt;meta name="description" content="Kurs JavaScript dla początkujących."&gt;

        &lt;title&gt;Kurs JavaScript&lt;/title&gt;
      &lt;/head&gt;

      &lt;body&gt;

        &lt;script src="scripts/code.js"&gt;&lt;/script&gt;
      &lt;/body&gt;

    &lt;/html&gt;
        </code>
      </pre>

        <p class="article__paragraph">Wewnątrz znacznika <strong class="bold">&lt;script&gt;</strong> umieszczamy ścieżkę dostępu do naszego pliku z kodem js. Znacznik ten umieszczamy zawsze na końcu naszego body tuż przed znacznikiem zamykającym <strong class="bold">&lt;/body&gt;</strong>. Robimy tak ponieważ nie chcemy żeby podczas wczytywania strony, ładujący się kod JavaScript blokował wyświetlanie pozostałej części strony. Sprawiając wrażenie wolnego działania strony i pozostawiając użytkownika z białym ekranem.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">ESLint</h3>
        <p class="article__paragraph">Pierwszym narzędziem jakie wykorzystamy do pisania kodu dobrej jakości będzie <a class="article__link" href="https://eslint.org" target="_blank">ESLint</a> ze zbiorem zasad airbnb-base. Narzędzie to pokazuje nam błędy jakie popełniliśmy oraz daje pomocne wskazówki, jeszcze przed uruchomieniem naszego kodu w przeglądarce.</p>

        <p class="article__paragraph">Żeby je zainstalować, najpierw potrzebujemy zainstalować <a class="article__link" href="https://nodejs.org/en/" target="_blank">Node.js.</a> Pobieramy i instalujemy wersję rekomendowaną dla większości użytkowników, w chwili pisania tego postu jest to wersja 8.11.1 LTS.</p>

        <p class="article__paragraph">Teraz uruchamiamy wiersz poleceń i za jego pomocą nawigujemy do folderu z naszym projektem. (Wszystkie moje polecenia są dla systemu operacyjnego Windows 10) W moim przypadku są to komendy:</p>

        <span class="article__command">E:</span>
        <span class="article__command">cd E:\11 Programowanie\Blog\Kurs</span>

        <p class="article__paragraph">Teraz inicjalizujemy plik package.json, za pomocą komendy:</p>

        <span class="article__command">npm init</span>

        <p class="article__paragraph">Wszystkie opcje zatwierdzamy enterem. Nie musimy nic wpisywać i zmieniać. Następnie instalujemy ESLint wpisując polecenie:</p>

        <span class="article__command">npm install –save-dev eslint eslint-config-airbnb eslint-plugin-import</span>

        <p class="article__paragraph">Teraz dodajemy plik o nazwie .eslintrc. Zawiera on ustawienia z jakich korzystamy w naszym projekcie.</p>

        <pre class="article__code">
        <code>
    {
        "extends": "airbnb-base",
        "parserOptions": {
        "ecmaVersion": 6
        },
        "env": {
        "node": true,
        "browser": true,
        "es6": true
        },
        "rules": {
        "comma-dangle": ["error", "never"],
        "no-unused-vars": ["error", {"vars": "local", "args": "none"}]
        }
    }
      </code>
      </pre>

        <p class="article__paragraph">Widzimy, że nasz zbiór zasad jest rozszerzeniem zasad opracowanych przez airbnb-base. Domyślnie ESLint wspiera tylko składnię ECMAScript 5, ponieważ zamierzamy korzystać również z wersji ECMAScript 6 dodajemy to możliwość w parserOptions. Nie przejmuj się jeśli nie wiesz co to oznacza. Wszystko wyjaśnimy w dalszej części kursu.</p>

        <p class="article__paragraph">„env” przechowuje środowiska w jakich będzie działał nasz kod. Natomiast „rules” zawiera nasze własne ustawienia obecnie obowiązujących zasad. Dodając tu kolejne pozycje, możemy wyłączyć lub zmienić status zgłaszanego błędu na ostrzeżenie lub na odwrót. Wszystkie rodzaje błędów i ich możliwą konfiguracje znajdziemy w dokumentacji ESLint.</p>

        <img class="article__img" src="img/Linter.jpg" alt="zrzut ekranu edytora Brackets">

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Nasze drzewko plików w projekcie powinno wyglądać tak.</li>
          <li class="ordered-list__item">Przykładowy kod, obok widzimy ikony wyświetlane przez ESLint zgłaszające ostrzeżenie i błąd w danej linijce kodu.</li>
          <li class="ordered-list__item">Za pomocą tej ikony włączamy i wyłączamy podgląd zgłoszonych błędów (okno nr 4)</li>
          <li class="ordered-list__item">Lista zgłoszonych błędów. Zaczynając od lewej mamy:
            <ul class="article__unordered-list">
              <li class="unordered-list__item">nr linii kodu z błędem</li>
              <li class="unordered-list__item">typ błędu i informację na jego temat</li>
              <li class="unordered-list__item">nazwę zasady podaną w nawiasie kwadratowym</li>
            </ul>
          </li>
        </ol>

        <p class="article__paragraph">Kod z tej lekcji można pobrać z <a class="article__link" href="https://github.com/TomaszRybacki/Kurs" target="_blank">GitHuba</a>.</p>
      </section>

    </article>


    <!-- Article 03 -->


    <article class="article">

      <header id="Debugowanie_cz2" class="article__header">
        <div class="decor">03</div>
        <h2 class="article__title">Debugowanie cz.2</h2>
      </header>

      <p class="article__paragraph">Dzisiaj dokończymy temat radzenia sobie z błędami. Omówimy obiekt console, punkty kontrolne i typy pojawiających się błędów.</p>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt console</h3>
      </section>

      <p class="article__paragraph">Przeglądarka internetowa Chrome ma wbudowaną konsolę JavaScript, możemy w niej pisać bezpośrednio kod js. Również w niej będą się nam wyświetlały wszystkie błędy jakie napotka interpreter. Będziemy mieli podaną nazwę błędu, jego opis i numer linii kodu, w którym wystąpił. Dzięki temu możemy szybko zlokalizować i poprawić występujące błędy.</p>

      <p class="article__paragraph">Aby ją otworzyć klikamy prawym przyciskiem myszy na stronie internetowej i wybieramy przycisk Zbadaj. Następnie przechodzimy do zakładki Console.</p>

      <img class="article__img" src="img/console.jpg" alt="zrzut ekranu konsoli w przeglądarce Chrome">

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Pasek boczny konsoli. Klikając odpowiednio kategorię wyświetlamy tylko powiadomienia danego typu.</li>
        <li class="ordered-list__item">Konsola. To tutaj będą pojawiać się informacje o błędach z ich opisem. Również tutaj możemy pisać nasz kod JS oraz wyświetlać informacje za pomocą obiektu console.</li>
        <li class="ordered-list__item">Nazwa pliku oraz numer linii kodu z tego pliku, który generuje daną informację.</li>
      </ol>

      <p class="article__paragraph">Konsolę wykorzystujemy również do sprawdzania jakie wartości przyjmują nasze zmienne w danym fragmencie skryptu. Przyjrzyjmy się teraz metodom jakie zapewnia obiekt console. Najważniejsze z nich to:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.log()</strong> – służące do wyświetlania treści w konsoli</li>
      </ul>

      <p class="article__paragraph">Metoda ta ma trzy bliźniacze metody, które również wyświetlają nasz tekst w konsoli ale dodatkowo zapewniają stylowanie. Dzięki czemu możemy filtrować wyświetlane informacje i wyświetlać tylko te, które w danym momencie są dla nas istotne.</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.info()</strong> – wyświetla tekst jako informację</li>
        <li class="unordered-list__item"><strong class="bold">console.warn()</strong> – wyświetla tekst jako ostrzeżenie</li>
        <li class="unordered-list__item"><strong class="bold">console.error()</strong> – wyświetla tekst jako błąd</li>
      </ul>

      <p class="article__paragraph">Kolejną przydatną metodą jest:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.group(), console.groupCollapsed()</strong> – służy do grupowania wyświetlanych informacji pod wspólną etykietą, coś w stylu rozpoczynającego znacznika HTML</li>
        <li class="unordered-list__item"><strong class="bold">console.groupEnd()</strong> – zamyka naszą grupę, coś w stylu zamykającego znacznika HTML</li>
      </ul>

      <p class="article__paragraph">Oprócz tych podstawowych metod, mamy jeszcze kilka, które mogą być przydatne, oto one:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.assert()</strong> – sprawdza warunek, jeśli nie jest spełniony, dopiero wtedy wyświetla wiadomość do konsoli</li>
        <li class="unordered-list__item"><strong class="bold">console.count()</strong> – wyświetla ile razy zostało użyte wywołanie tej metody z daną etykietą. Taki zwykły licznik.</li>
        <li class="unordered-list__item"><strong class="bold">console.time() </strong> – rozpoczyna odliczanie czasu jaki minął od wywołania tej metody, dzięki temu możemy sprawdzić czas wykonania danego fragmentu naszego kodu</li>
        <li class="unordered-list__item"><strong class="bold">console.timeEnd()</strong> – kończy odliczanie czasu i wyświetla ile czasu (milisekund) upłynęło od jego rozpoczęcia</li>
      </ul>

      <strong class="bold">Przykład</strong>

      <pre class="article__code">
        <code>
    // Obiekt console

    console.time('Timer');
    console.count('Counter');

    console.group('names');
    console.info('Tomasz');
    console.warn('Daniel');
    console.error('Marcin');
    console.log('Adam');
    console.groupEnd();

    console.count('Counter');

    console.groupCollapsed('age');
    console.log(28);
    console.log(25);
    console.log(32);
    console.log(32);
    console.groupEnd();

    console.count('Counter');

    const myName = 777;
    console.assert(typeof myName === 'string', 'Niepoprawny typ zmiennej, oczekiwano wartości typu "string".');

    console.timeEnd('Timer');
        </code>
      </pre>

      <section class="article__section">
        <h3 class="article__section__title">Punkty kontrolne</h3>

        <p class="article__paragraph">Może się zdarzyć, że będziemy potrzebować przeanalizować jak działa nasz skrypt kawałek po wałku. W tym celu możemy wstawić słowo kluczowe debugger w każdym miejscu, w którym chcemy żeby nastąpiła pauza w wykonywaniu naszego skryptu. Następnie w zakładce Sources przeglądarki możemy przełączać się pomiędzy utworzonymi punktami kontrolnymi i obserwować w jaki sposób jest wykonywany nasz skrypt, jakie wartości przyjmują zmienne w danym miejscu i jaki jest stos wywołań.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Typy błędów</h3>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">SyntaxError – nieprawidłowa składnia np.: niedopasowane lub brakujące znaki cytowania, brakujące nawiasy, nieprawidłowe nazwy właściwości lub zmiennych</li>
          <li class="unordered-list__item">ReferenceError – zmienna nie istnieje np.: niezadeklarowana zmienna, niezdefiniowana nazwa funkcji</li>
          <li class="unordered-list__item">TypeError – nieoczekiwany typ danych np.: metoda nie istnieje, nieprawidłowa wielkość znaku w nazwie metody</li>
          <li class="unordered-list__item">RangeError – liczba spoza zakresu np.: nie można utworzyć tablicy zawierającej -x elementów</li>
          <li class="unordered-list__item">EvalError – nieprawidłowe użycie funkcji eval()</li>
          <li class="unordered-list__item">URIError – nieprawidłowe użycie funkcji URI</li>
        </ul>

        <p class="article__paragraph">Najbardziej interesują nas pierwsze cztery typy błędów bo to właśnie je będziemy spotykać najczęściej pisząc nasze programy.</p>
      </section>

    </article>


    <!-- Article 04 -->


    <article class="article">

      <header id="Typy_wartosci" class="article__header">
        <div class="decor">04</div>
        <h2 class="article__title">Typy wartości</h2>
      </header>

      <p class="article__paragraph">W JavaScript mamy siedem typów wartości, są to:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">string</li>
        <li class="ordered-list__item">number</li>
        <li class="ordered-list__item">boolean</li>
        <li class="ordered-list__item">undefined</li>
        <li class="ordered-list__item">null</li>
        <li class="ordered-list__item">symbol</li>
        <li class="ordered-list__item">object</li>
      </ol>

      <p class="article__paragraph">Typ przechowywanej wartości możemy sprawdzić za pomocą polecenia <strong class="bold">typeof()</strong>. JS jest językiem dynamicznym, zmienne nie są związane z konkretnym typem danych jaki mogą przechowywać. To wartości przechowywane w zmiennych mają swój typ i mogą się zmieniać w trakcje wykonywania naszego programu. Dzięki czemu zmienna o nazwie <strong class="bold">name</strong> może przechowywać na początku liczbę (typ number), potem ciąg znaków (typ string), żeby ostatecznie zostać obiektem (typ object) na końcu działania naszego programu.</p>


      <section class="article__section">
        <h3 class="article__section__title">String</h3>
        <p class="article__paragraph">Jest to ciąg znaków tekstowych, który zapisujemy w cudzysłowie podwójnym lub pojedynczym lub za pomocą znaku apostrof (tego na klawiszu pod Esc). Ten typ służy do przechowywania informacji w postaci słów np.: „Życie to sztuka wyborów”, ‚Lubię się uczyć.’, `Kodowanie jest fajne.`. Wybór <strong class="bold">“ ”</strong> lub <strong class="bold">‘ ’</strong> należy do ciebie. Natomiast <strong class="bold">´ ´</strong> daje dodatkowe możliwości, o których powiemy w dalszych lekcjach kursu JS.</p>

        <p class="article__paragraph">String w JS jest niezmienny co oznacza, że po jego utworzeniu nie możemy go modyfikować. Możemy jedynie tworzyć nowe wartości typu string na podstawie utworzonej wcześniej wartości np. poprzez wycięcie jego części. Mając słowo ‚domek’, możemy wyciąć pierwsze trzy litery tworząc słowo ‚dom’.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Number</h3>
        <p class="article__paragraph">Przechowuje liczby, pozwala przeprowadzać operacje matematyczne. Typ ten zawiera zarówno liczby całkowite jak i ułamkowe liczby dziesiętne.</p>

        <p class="article__paragraph">W JS wykorzystuje się 64-bitowy binarny format podwójnej precyzji oparty na standardzie IEEE 754. Oznacza to, że liczby są przechowywane w 64 bitach, gdzie 1 bit przechowuje znak liczby (+ lub -), 11 bitów przechowuje wykładnik potęgowy (dla 2³ = 2 * 2 * 2 wykładnikiem jest liczba 3), natomiast pozostałe 52 bity przechowują część ułamkową.</p>

        <p class="article__paragraph">Z tego powodu nie możemy operować na dowolnych liczbach, jesteśmy zmuszeni do ograniczenia się do liczb całkowitych z przedziału od 9007199254740991 do -9007199254740991. Dodatkowo ułamki dziesiętne nie są reprezentowane w sposób dokładny i działanie 0.1 + 0.2 = 0.30000000000000004. Z matematycznego punktu widzenia nie jest to wynik, którego byśmy się spodziewali. Dlatego musimy zachować ostrożność przy operacjach na ułamkach i stosować zaokrąglenia przy porównywaniu wyników z sobą. Kolejną ciekawostką jest też fakt istnienia zera dodatniego i zera ujemnego. Gdy podzielimy 2 / 0 otrzymamy nieskończoność, natomiast dla działania 2 / -0 otrzymamy minus nieskończoność.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Boolean</h3>
        <p class="article__paragraph">Typ ten pozwala na podejmowanie decyzji. Jest to typ logiczny, może przyjmować tylko dwie wartości: true (prawda) i false (fałsz).</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Undefined</h3>
        <p class="article__paragraph">Typ undefined zawiera tylko jedną wartość, wartość undefined. Wartość nie zdefiniowana zostaje automatycznie przypisana zmiennej, która została tylko zadeklarowana przy pomocy słowa kluczowego var lub let (powiemy na ten temat przy okazji omawiania zmiennych).</p>

        <p class="article__paragraph">Dodatkowo sprawdzając typ zmiennej, która nie została zadeklarowana również otrzymamy wartość undefined np. console.log(typeof(c)); zwraca undefined gdy zmienna c nie występuje w naszym kodzie.</p>

        <p class="article__paragraph">Wartość undefined zwraca również:</p>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">funkcja, w której nie zastosowano polecenia return</li>
          <li class="unordered-list__item">właściwość obiektu, która nie jest zadeklarowana</li>
        </ul>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Null</h3>
        <p class="article__paragraph">Typ null zawiera tylko jedną wartość. Jest nią null. Wartość ta reprezentuje celowy brak danej wartości w obiekcie. Wynika z tego, że musimy ją przypisać do właściwości danego obiektu.</p>
        <p class="article__paragraph">Ważną rzeczą, o której trzeba wiedzieć to błąd jaki istnieje w JS od czasu powstania tego języka.</p>

        <pre class="article__code">
        <code>
    let a = null;
    console.log(typeof(a)); // zwraca typ object
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Symbol</h3>
        <p class="article__paragraph">Jest to nie powtarzalna wartość służąca do identyfikacji właściwości w obiekcie. Tworzymy go za pomocą funkcji Symbol(‚opis’). Opis służy wyłącznie do celów debugowania abyśmy my potrafili rozróżnić symbole od siebie. Możemy nadać dwóm symbolom takie same opisy. Nie sprawi to jednak, że oba symbole będą takie same i równe sobie. Za każdym razem tworząc symbol tworzymy nowy unikatowy symbol.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Podsumowanie</h3>
        <p class="article__paragraph">Omówione do tej pory typy to wartości typu prostego, co oznacza, że są niezmienne. Są to takie podstawowe klocki, z których budujemy bardziej złożone konstrukcje.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Object</h3>
        <p class="article__paragraph">Object natomiast jest wartością złożoną składającą się z par klucz: wartość. Gdzie kluczem może być string lub symbol. Natomiast właściwością mogą być wszystkie wyżej wymienione typy. Object dodatkowo zawiera w sobie podtypy takie jak: function (funkcja – obiekt, który ma możliwość wywołania), array (tablica – obiekt, który wykorzystuje liczby jako klucze oraz ma automatycznie uaktualnianą właściwość length, która wskazuje wielkość tablicy).</p>

        <p class="article__paragraph">Gdy myślimy o obiekcie możemy go sobie wyobrazić jako uproszczony model opisujący coś co znamy z rzeczywistości. Weźmy przykład człowieka. Każdy człowiek ma imię, wzrost, wagę, kolor oczu itp. Są to właściwości naszego obiektu. Dodatkowo każdy człowiek potrafi robić różne rzeczy, np. mówić, chodzić itp. Czynności wykonywane przez obiekt nazywamy metodami tego obiektu. Oto przykład obiektu o nazwie person.</p>

        <pre class="article__code">
        <code>
    const person = {
        name: 'Tomasz',
        height: 174,
        weight: 70,
        eyeColor: 'gray',

        sayHello() {
          return 'Hello';
        },
        walk() {
          return 'I go for a walk to a park';
        }
    }

    console.log(person.name); // Tomasz
    console.log(person.walk()); // 'I go for a walk to a park'

    console.log(typeof(person.name)); // string
    console.log(typeof(person.walk)); // function
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wartość specjalna NaN</h3>
        <p class="article__paragraph">Typ number zawiera wartość NaN (not a number). Oznacza wartość, która nie jest poprawną liczbą. Powstaje w wyniku operacji matematycznej, która się nie powiodła np: 2 * 'ja'. Mamy typ number mnożony przez typ string. Ponieważ JS nie ma pojęcia w jaki sposób przeprowadzić taką operację otrzymamy NaN.</p>

        <p class="article__paragraph">Dodatkowo wartość NaN nie jest równa innej wartości NaN. Dlatego żeby sprawdzić czy coś jest wartością NaN musimy użyć metody <strong class="bold">Number.isNaN()</strong>.</p>
      </section>


    </article>


    <!-- Article 05 -->


    <article class="article">

      <header id="Zmienne_cz1" class="article__header">
        <div class="decor">05</div>
        <h2 class="article__title">Zmienne cz.1</h2>
      </header>

      <p class="article__paragraph">W kodzie JS istnieją trzy słowa kluczowe służące do deklarowania zmiennych. Są to słowa <strong class="bold">var, let, const</strong>. Dzisiaj przyjrzymy się różnicom jakie występują pomiędzy nimi oraz powiemy sobie czym jest zakres i wynoszenie.</p>

      <p class="article__paragraph">Należy pamiętać, że w JS występuje typowanie dynamiczne co oznacza, że to wartości przechowywane w zmiennych mają swoje typy. Same zmienne nie wymuszają typu wartości jakie mogą przechowywać i można w nich przechowywać wartości różnego typu.</p>

      <section class="article__section">
        <h3 class="article__section__title">var</h3>

        <p class="article__paragraph">Jest to najstarszy sposób deklarowania zmiennej. Poprzez zadeklarowanie zmiennej rozumiemy następującą linijkę kodu:</p>

        <pre class="article__code">
        <code>
    var myName;
        </code>
      </pre>

        <p class="article__paragraph">Właśnie utworzyliśmy zmienną o nazwie <strong class="bold">myName</strong>. W tym momencie przechowuje ona wartość undefined. Zmienne utworzone w ten sposób są dodawane do obiektu globalnego <strong class="bold">window</strong>. Przy pomocy polecenia:</p>

        <pre class="article__code">
        <code>
    console.log(window);
        </code>
      </pre>

        <p class="article__paragraph">Możemy wyświetlić jego wszystkie wstępnie zdefiniowane właściwości. Zobaczymy, że nasza zmienna została dodana i możemy ją odszukać na tej liście.</p>

        <p class="article__paragraph">Tutaj jako ciekawostkę napiszę, że na początku zadeklarowałem zmienną o nazwie <strong class="bold">name</strong> a następnie byłem zdziwiony, że jej wartość początkowa wynosiła “”, czyli była pustym ciągiem tekstowym (string). Jak możemy zobaczyć obiekt <strong class="bold">window</strong> posiada wstępnie zdefiniowaną właściwość o nazwie <strong class="bold">name</strong>. Zagadka rozwiązana, wszystko działa jak należy.</p>

        <strong class="bold">Zasady nadawania nazw zmiennym:</strong>
        <ol class="article__ordered-list">
          <li class="ordered-list__item">nazwa nie może zaczynać się od cyfry</li>
          <li class="ordered-list__item">nie może zawierać myślnika ani krpoki</li>
          <li class="ordered-list__item">nie wolno używać słów kluczowych jak np.: var, let, const</li>
          <li class="ordered-list__item">wielkość liter ma znaczenie, zmienna <strong class="bold">name</strong> nie równa się zmiennej <strong class="bold">Name</strong></li>
          <li class="ordered-list__item">gdy nazwa składa się z kilku słów zapisujemy je w notacji wielbłądziej (camelCase). Czyli kolejne wyrazy pisane są łącznie, rozpoczynając każdy następny wielką literą. np. <strong class="bold">myName</strong></li>
          <li class="ordered-list__item">nazwa powinna wskazywać na rodzaj informacji jaki jest przechowywany w zmiennej</li>
        </ol>

        <p class="article__paragraph">Wracając do naszego przykładu, jeśli chcę zainicjować zmienną myName i przypisać jej wartość, mogę to zrobić za pomocą znaku równości.</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">Mogę wykonać obie te czynności w tej samej linijce kodu. Należy jednak pamiętać, że interpreter JS, wykonuje te dwie czynności oddzielnie najpierw deklaruje zmienną a dopiero potem przypisuje jej wartość.</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    // ten kod zostanie wykonany jako:

    var myName;
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">Możemy przypisać wartość do zmiennej bez jej deklaracji. Jest to jednak bardzo zły pomysł. W takim przypadku dochodzi bowiem do automatycznego utworzenia zmiennej globalnej w chwili wykonywania danej linii kodu przez interpreter.</p>
      </section>


      <section class="article__section">
        <h3 class="article__section__title">Zakres</h3>

        <p class="article__paragraph">Kolejnym pojęciem jakie musimy zrozumieć jest zakres zmiennej. Zakres oznacza zasięg w jakim jest widoczna nasza zmienna. W przypadku var jest to zakres lokalny funkcji, w której została zadeklarowana zmienna lub jest to zakres globalny dla zmiennych zadeklarowanych poza funkcją.</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    function getMyFullName() {
      var mySurname = 'Rybacki';
      console.log(myName);
      console.log(mySurname);
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // ReferenceError
    getMyFullName(); // Tomasz Rybacki
        </code>
      </pre>

        <p class="article__paragraph">Zakres lokalny funkcji oznacza, że zmienna jest widoczna tylko wewnątrz funkcji, w której została zadeklarowana. Natomiast zmienne z zakresu globalnego są widoczne w całym naszym skrypcie. Dlatego w powyższym przykładzie funkcja getMyFullName wyświetli zarówno moje imię jak i nazwisko.</p>

        <p class="article__paragraph">Jednak gdy spróbuję dostać się do zmiennej mySurname poza funkcją otrzymam błąd ReferenceError. Dzieje się tak ponieważ, reszta mojego skryptu nie widzi tej zmiennej i nie ma pojęcia o jej istnieniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wynoszenie</h3>

        <p class="article__paragraph">Przed wykonaniem naszego kodu interpreter przeszukuje cały nasz kod w poszukiwaniu deklaracji zmiennych i funkcji. Odnalezione deklaracje są następnie wynoszone na początek naszego skryptu, dzięki temu są widoczne w całym naszym skrypcie.</p>

        <pre class="article__code">
        <code>
    console.log(myName); // undefined

    // nie otrzymamy w tym momencie błędu ReferenceError
    // ponieważ zmienna została wyniesiona na początek skryptu

    var myName = 'Tomasz';

    // zauważmy, że dopiero w tym momencie została przypisana wartość

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Powyższy kod zostanie wykonany przez interpreter w następujący sposób:</p>

        <pre class="article__code">
        <code>
    var myName;

    console.log(myName); // undefined

    myName = 'Tomasz';

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Z tego też powodu powinniśmy deklarować wszystkie nasze zmienne na początku naszego skryptu (zakres globalny) lub funkcji (zakres lokalny). Dzięki temu nasz kod jest czytelniejszy, od razu widzimy, jakie zmienne mają jaki zakres.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Dlaczego nie chcemy deklarować wszystkich naszych zmiennych globalnie ?</h3>

        <p class="article__paragraph">Nasza aplikacja lub strona internetowa może współpracować z wieloma bibliotekami napisanymi w JS przez kogoś innego. Wynika z tego, że ktoś inny mógł by nadać takie same nazwy swoim zmiennym jak zrobiliśmy to my w naszym skrypcie. Powstało by wtedy wiele zamieszania, a wyniki działania naszej aplikacji były by nieprzewidywalne. Dlatego staramy się unikać współdzielenia przestrzeni nazw i gdy tylko to możliwe ukrywamy nasze zmienne.</p>
      </section>
    </article>


    <!-- Article 06 -->

    <article class="article">

      <header id="Zmienne_cz2" class="article__header">
        <div class="decor">06</div>
        <h2 class="article__title">Zmienne cz.2</h2>
      </header>

      <p class="article__paragraph">Kontynuujemy temat zmiennych. Dzisiaj przyjrzymy się zmiennym wprowadzonym przez ECMAScript 6. Są to słowa kluczowe <strong class="bold">let</strong> i <strong class="bold">const</strong>. Dodatkowo zobaczymy w jaki sposób wartości są przechowywane w zmiennych.</p>

      <section class="article__section">
        <h3 class="article__section__title">let</h3>

        <p class="article__paragraph">Za pomocą słowa <strong class="bold">let</strong> deklarujemy zmienną, której zakres jest ograniczony do bloku kodu. Blokiem kodu nazywamy wszystko co zawiera się w nawiasach klamrowych { }, możemy w ten sposób zgrupować ze sobą kilka wyrażeń.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    var mySurname = 'Rybacki';

    {
      let myName = 'Marcin';
      var mySurname = 'Kazanowski'

      console.log(myName); // Marcin
      console.log(mySurname); // Kazanowski
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // Kazanowski
        </code>
      </pre>

        <p class="article__paragraph">let nie tworzy właściwości na obiekcie globalnym</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';
    let mySurname = 'Rybacki';

    console.log(window.myName); // Tomasz
    console.log(window.mySurname); // undefined
        </code>
      </pre>

        <p class="article__paragraph">nie można ponownie zadeklarować zmiennej o tej samej nazwie w danym zakresie</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myName = 'Marcin'; // SyntaxError
        </code>
      </pre>

        <p class="article__paragraph">nie ulega wynoszeniu – tak zwana tymczasowa martwa strefa (Temporal Dead Zone)</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz'; // ReferenceError
    console.log(typeof(myName)); // ReferenceError
    let myName;
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">const</h3>

        <p class="article__paragraph">Przy użyciu słowa kluczowego <strong class="bold">const</strong> deklarujemy zmienną, która jest stałą. Co oznacza, że nie można jej przypisać nowej wartości. Dodatkowo musimy przypisać jej wartość w chwili deklaracji.</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"> Poniższe próby zakończą się błędem</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
    const myName = 'Marcin'; // SyntaxError

    const myName; // SyntaxError
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">const</strong> tak samo jak <strong class="bold">let</strong> ma zakres bloku, nie tworzy właściwości na obiekcie globalnym, nie można ponownie zadeklarować zmiennej o tej samej nazwie w danym zakresie i nie ulega wynoszeniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Przechowywanie wartości w zmiennych</h3>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieć w jaki sposób wartości są przechowywane w zmiennych. Otóż wartości typu prostego są przechowywane bezpośrednio w danej zmiennej. Możemy więc kopiować wartości jakie przechowują do innych zmiennych.</p>

        <pre class="article__code">
        <code>
    let a = 2;
    console.log(a); // 2

    let b = a;
    console.log(b); // 2

    b = b + 2;
    console.log(b); // 4
    console.log(a); // 2
        </code>
      </pre>

        <p class="article__paragraph"> Wyobraźmy sobie, że zmienna <strong class="bold">a</strong> jest pudełkiem, w którym znajduje się cyfra <strong class="bold">2</strong>. W momencie zadeklarowania zmiennej <strong class="bold">b</strong> i przypisania jej wartości <strong class="bold">a</strong> powstaje nowe pudełko z nową cyfrą <strong class="bold">2</strong>. W efekcie mamy dwa pudełka i dwie oddzielne cyfry <strong class="bold">2</strong>, które możemy niezależnie od siebie modyfikować.</p>

        <p class="article__paragraph">Natomiast wartości typu złożonego są zapisywane w zmiennych jako referencja do miejsca w pamięci, w której są przechowywane dane informacje. Możemy to sobie wyobrazić jako jedno pudełko, w którym znajduje się obiekt <strong class="bold">me</strong>. W chwili utworzenia obiektu <strong class="bold">myBrother</strong> nie następuje skopiowanie obiektu <strong class="bold">me</strong> i przypisanie go do nowej zmiennej. Powstaje natomiast nowa referencja (czyli taka strzałka wskazująca gdzie znajduje się obiekt <strong class="bold">me</strong>). Mamy więc dwie oddzielne strzałki, które wskazują te same pudełko. Modyfikując więc dowolną ze strzałek, tak naprawdę modyfikujemy ten sam pojemnik. Dlatego w poniższym przykładzie zmieniliśmy zarówno moje imię jak i imię mojego brata.</p>

        <pre class="article__code">
        <code>
    let me = {
      name: 'Tomasz',
      age: 28
    }

    let myBrother = me;

    myBrother.name = 'Daniel';

    console.log(myBrother.name); // Daniel
    console.log(me.name); // Daniel
        </code>
      </pre>

        <p class="article__paragraph">Gdy zadeklarujemy stałą, która przechowuje wartość typu złożonego jak np. obiekt. Możemy zmienić właściwości tego obiektu. Nie możemy jednak przypisać jej nowej wartości.</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28
    }

    person.name = 'Daniel';
    person.age = 25;

    console.log(person); // {name: Daniel, age: 25}

    person = 'Daniel'; // TypeError
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 07 -->

    <article class="article">

      <header id="Operatory" class="article__header">
        <div class="decor">07</div>
        <h2 class="article__title">Operatory</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Operatory matematyczne</h3>

        <p class="article__paragraph">Są nam dobrze znane z lekcji matematyki. Są to:</p>

        <pre class="article__code">
        <code>
    // dodawanie (+)

    console.log(2 + 3); // 5

    // odejmowanie (-)

    console.log(5 - 4); // 1

    // mnożenie (*)

    console.log(2 * 3); // 6

    // dzielenie (/)

    console.log(8 / 2); // 4

    // reszta z dzielenia (%)

    console.log(6 % 5); // 1
        </code>
      </pre>

        <p class="article__paragraph">Nowością dla nas mogą być operatory inkrementacji (++) i dekrementacji (--). Czyli odpowiednio zwiększenia i zmniejszenia danej wartości o 1. Możemy je stosować za równo z lewej strony jak i prawej strony naszej zmiennej. Gdy występują z lewej to zmiana wartości nastąpi już w danej linijce kodu, gdy występują z prawej to zmiana wartości nastąpi w następnej linijce kodu.</p>

        <pre class="article__code">
        <code>
    // inkrementacja (++) - czyli zwiększenie wartości o 1

    let someNumber = 2;

    console.log(someNumber++); // 2
    console.log(someNumber); // 3

    someNumber = 2;

    console.log(++someNumber); // 3
    console.log(someNumber); // 3

    // dekrementacja (--) - czyli zmniejszenie wartości o 1

    let otherNumber = 6;

    console.log(otherNumber--); // 6
    console.log(otherNumber); // 5

    otherNumber = 6;

    console.log(--otherNumber); // 5
    console.log(otherNumber); // 5
        </code>
      </pre>

        <p class="article__paragraph">Osobiście wolę ich nie stosować i używać operatorów przypisania <strong class="bold">someNumber += 1</strong> lub <strong class="bold">someNumber -=1</strong>, co według mnie jest o wiele bardziej czytelne.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory przypisania</h3>

        <p class="article__paragraph">Znamy już operator równa się (=) z poprzednich wpisów. Nie wiemy jednak, że ma on kilka wariantów, które pozwalają najpierw wykonać działanie a następnie przypisać wynik tego działania np. <strong class="bold">someNumber += 1</strong> jest równoznaczne z <strong class="bold">someNumber = someNumber + 1</strong></p>

        <pre class="article__code">
        <code>
    let number = 6;

    // przypisanie dodawania (+=)

    console.log(number += 2); // 8

    // przypisanie odejmowania (-=)

    console.log(number -= 2); // 6

    // przypisanie mnożenia

    console.log(number *= 2); // 12

    // przypisanie dzielenia (/=)

    console.log(number /= 2); // 6

    // przypisanie reszty z dzielenia

    console.log(number %= 2); // 0
        </code>
      </pre>
      </section>
      <section class="article__section">
        <h3 class="article__section__title">Operatory porównania</h3>

        <p class="article__paragraph">Służą do sprawdzenia czy obie strony równania są sobie równe czy różne.</p>

        <p class="article__paragraph"><strong class="bold">1 Porównanie luźne (==)</strong></p>

        <p class="article__paragraph">Zezwala na konwersję typów porównywanych wartości. Czyli gdy porównujemy ze sobą dwie wartości różnych typów jak np. '2' == 2 otrzymamy wartość <strong class="bold">true</strong>. Czyli obie wartości są sobie równe, ponieważ typ string został zamieniony na typ number i dopiero wówczas dokonano porównania 2 == 2, co jak wiemy jest prawdą.</p>

        <p class="article__paragraph"><strong class="bold">2 Porównanie ścisłe (===)</strong></p>

        <p class="article__paragraph">Nie zezwala na konwersję typów porównywanych wartości. Czyli '2' === 2 da nam w wyniku <strong class="bold">false</strong>. Dokładnie na temat konwersji typów powiemy w kolejnym wpisie. Pozostałe operatory porównania to:</p>

        <pre class="article__code">
        <code>
    // większy od (&gt;)

    console.log(4 &gt; 2); // true

    // mniejszy od (&lt;)

    console.log(1 &lt; 3); // true

    // większy równy od (&gt;=)

    console.log(2 &gt;= 2); // true

    // mniejszy równy od (&lt;=)

    console.log(6 &lt;= 9); // true

    // nie równy - porównanie luźne (!=)

    console.log(2 != 3); // true

    // nie równy - porównanie ścisłe (!==)

    console.log('3' !== 3); // true
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory logiczne</h3>

        <p class="article__paragraph">Gdy chcemy podjąć bardziej skomplikowaną decyzję stosujemy operatory logiczne, które pozwalają nam sprawdzić kilka warunków jednocześnie.</p>

        <p class="article__paragraph">Warto wiedzieć, że operator <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong> zwraca jedną ze sprawdzanych wartości, a ponieważ najczęściej jest stosowany w kontekście sprawdzania wartości boolowskich jest następnie konwertowany do wartości <strong class="bold">true</strong> lub <strong class="bold">false</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myAge = 28;
    let isSleeping = true;

    // logiczne i (&amp;&amp;) - zwraca prawdę gdy oba warunki są spełnione

    console.log(myAge &gt;= 18 &amp;&amp; myName === 'Tomasz'); // true
    console.log(myAge &amp;&amp; myName); // Tomasz
    // logiczne lub (||) - zwraca prawdę gdy jeden z warunków jest spełniony

    console.log(myName === 'Tomasz' || myName === 'Marcin'); // true

    // negacja (!) - odwraca wartość z prawdy na fałsz lub na odwrót

    console.log(!isSleeping); // false
        </code>
      </pre>

        <p class="article__paragraph">Wyrażenia logiczne są sprawdzane od lewej do prawej strony. Staramy się pisać je w taki sposób żeby warunek, który ma większe prawdopodobieństwo oblać nasz test był umieszczony z lewej strony. Ponieważ dalsza część naszego wyrażenia nie jest wtedy sprawdzana, tylko od razu otrzymujemy nasz wynik np. dla <strong class="bold">warunek1 &amp;&amp; warunek2</strong> gdy <strong class="bold">warunek1</strong> zwróci <strong class="bold">false</strong>, całe nasze wyrażenie zwróci wartość <strong class="bold">false</strong> bez sprawdzania <strong class="bold">warunek2</strong>. Analogicznie dla <strong class="bold">warunek1 || warunek2</strong>, gdy <strong class="bold">warunek1</strong> zwraca <strong class="bold">true</strong>, całe wyrażenie zwraca wartość <strong class="bold">true</strong>.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Konkatenacja</h3>

        <p class="article__paragraph">Operator (+) ma dodatkowe działanie w postaci łączenia ze sobą łańcuchów znaków.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log('Mam na' + ' imię ' + myName + '.'); // Mam na imię Tomasz.
        </code>
      </pre>

        <p class="article__paragraph">Wraz z wprowadzeniem przez ES6 szablonów ciągów znaków, zamiast używać plusa do łączenia ze sobą łańcuchów znaków korzystamy ze znaku apostrofu (pod klawiszem Esc). Jest to o wiele bardziej czytelniejszy sposób na umieszczanie tekstu ze zmiennych w generowanych przez nas zdaniach. Zmienne umieszczamy w nawiasach klamrowych poprzedzonych znakiem dolara <strong class="bold">${}</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log(`Mam na imię ${myName}.`); // Mam na imię Tomasz.
        </code>
      </pre>
      </section>


    </article>


    <!-- Article 08 -->


    <article class="article">

      <header id="Konwersja_typow" class="article__header">
        <div class="decor">08</div>
        <h2 class="article__title">Konwersja typów</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Czym jest konwersja typów ?</h3>

        <p class="article__paragraph">Jest to zamiana typu jednej wartości na inny typ. Kyle Simpson używa określenia <strong class="bold">jawnej konwersji typów</strong>, gdy w naszym kodzie widać, że konwersja przeprowadzana jest celowo. Oraz określenia <strong class="bold">niejawnej konwersji typów</strong>, gdy następuje ona jako efekt dodatkowy innej przeprowadzanej operacji.</p>

        <p class="article__paragraph">Nie będę dokładnie opisywał mechanizmu jej działania, żeby nie komplikować. W końcu z założenia kurs ten jest przeznaczony dla osób początkujących.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Jawna konwersja typów.</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczby (number) na ciąg znaków (string) lub na odwrót.</strong></p>

        <p class="article__paragraph">Najbardziej przejrzystym sposobem dokonania tej konwersji jest użycie wbudowanych funkcji <strong class="bold">String()</strong> i <strong class="bold">Number()</strong>:</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(Number(age)); // 28
    console.log(typeof(Number(age))); // number

    console.log(String(birthday)); // '1989'
    console.log(typeof(String(birthday))); // string
        </code>
      </pre>

        <p class="article__paragraph">Kolejnym jawnym sposobem na zamianę ciągu znaków na liczbę jest użycie operatora +</p>

        <pre class="article__code">
        <code>
    let age = '28';

    console.log(+age); // 28
    console.log(typeof(+age)); // number
        </code>
      </pre>

        <p class="article__paragraph"> <strong class="bold">- zamiana na typ boolean</strong></p>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieć na temat wartości prawdziwych (truthy) i fałszywych (falsy).</p>

        <p class="article__paragraph">Wartością fałszywą jest wszystko to co zostaje zamienione na wartość <strong class="bold">false</strong> podczas konwersji na typ boolean. Jest to krótka, ściśle określona lista wartości, którą łatwo zapamiętać.</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">undefined</li>
          <li class="ordered-list__item">null</li>
          <li class="ordered-list__item">0</li>
          <li class="ordered-list__item">NaN</li>
          <li class="ordered-list__item">'' pusty ciąg znaków</li>
        </ol>

        <p class="article__paragraph">Wartości prawdziwe możemy zapamiętać jeszcze prościej, są to wszystkie wartości, które nie znajdują się na powyższej liście.</p>

        <p class="article__paragraph">Tak samo jak wcześniej najbardziej czytelnym sposobem na konwersję jest użycie wbudowanej funkcji <strong class="bold">Boolean()</strong></p>

        <pre class="article__code">
        <code>
    let object = {};
    console.log(Boolean(object)); // true

    let array = [];
    console.log(Boolean(array)); // true

    let string = '0';
    console.log(Boolean(string)); // true

    let number = 6;
    console.log(Boolean(number)); // true


    let zero = 0;
    console.log(Boolean(zero)); // false

    let something;
    console.log(Boolean(something)); // false

    let empty = null;
    console.log(Boolean(empty)); // false

    let emptyString = '';
    console.log(Boolean(emptyString)); // false

    let invalidNumber = NaN;
    console.log(Boolean(invalidNumber)); // false
        </code>
      </pre>

        <p class="article__paragraph"> Kolejnym sposobem na konwersję jest użycie operatora podwójnej negacji !!</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(!!age); // true
    console.log(typeof(!!age)); // boolean

    console.log(!!birthday); // true
    console.log(typeof(!!birthday)); // boolean
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana wartości złożonych (obiektów) na wartości proste</strong></p>

        <p class="article__paragraph">W tym przypadku sprawa się nieco komplikuje, ponieważ sami musimy określić w jaki sposób chcemy zamienić obiekt na liczbę lub ciąg znaków. Każdy obiekt dziedziczy metodę <strong class="bold">toString()</strong> i <strong class="bold">valueOf()</strong>, właśnie te dwie metody określają w jaki sposób zostanie dokonana konwersja na <strong class="bold">string</strong> i <strong class="bold">number</strong>.</p>

        <pre class="article__code">
        <code>
    // zostaną wykorzystane domyślne metody odziedziczone po prototypie

    const person = {
      name: 'Tomasz',
      age: 28
    };

    // funkcje wbudowane Number() i String() wywołują metody valueOf() i toString()

    console.log(Number(person)); // NaN

    console.log(String(person)); // [object Object]
    console.log(typeof(String(person))); // string

    // możemy sami wywołać metodę toString() bezpośrednio

    console.log(person.toString()); // [object Object]
        </code>
      </pre>

        <p class="article__paragraph">Przesłaniamy domyślne metody i sami decydujemy w jaki sposób ma nastąpić konwersja:</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28,

      valueOf() {
        return this.age;
      },

      toString() {
        return `{name: ${this.name}, age: ${this.age}}`;
      }
    };

    console.log(Number(person)); // 28

    console.log(String(person)); // {name: Tomasz, age: 28}
    console.log(person.toString()); // {name: Tomasz, age: 28}
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Niejawna konwersja typów</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczb na ciągi znaków</strong></p>

        <p class="article__paragraph">Jeśli dowolny argument operatora + to wartość typu string, otrzymamy konkatenację łańcuchów znaków.</p>

        <pre class="article__code">
        <code>
    let birthday = 1989;

    console.log(birthday + ''); // 1989
    console.log(typeof(birthday + '')); // string
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana ciągów znaków na liczby</strong></p>

        <pre class="article__code">
        <code>
    let a = '1';
    let b = 3;

    console.log(a - b); // -2
    console.log(a * b); // 3
    console.log(a / b); // 0.3333333333333333
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- konwersja dowolnej wartości na typ boolean</strong></p>

        <p class="article__paragraph">Każda wartość użyta w kontekście poniższych wyrażeń zostanie zamieniona na typ boolean:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">wyrażenie testowe w instrukcji <strong class="bold">if</strong></li>
          <li class="ordered-list__item">wyrażenie testowe w nagłówku pętli <strong class="bold">for</strong></li>
          <li class="ordered-list__item">wyrażenie testowe w pętlach <strong class="bold">while</strong> i <strong class="bold">do while</strong></li>
          <li class="ordered-list__item">wyrażenie testowe w operatorze warunkowym</li>
          <li class="ordered-list__item">argument z lewej strony operatorów <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong></li>
        </ol>


        <p class="article__paragraph">Omówimy wszystkie te wyrażenia w kolejnych lekcjach, więc nie przejmuj się, że nie wiesz jeszcze co oznaczają.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Korzystanie z równości luźnej ==</h3>

        <p class="article__paragraph">Wartość NaN nigdy nie jest równa NaN. Możemy to sobie wytłumaczyć w następujący sposób.</p>

        <pre class="article__code">
        <code>
    console.log('a' * 2); // NaN
    console.log('b' * 2); // NaN
        </code>
      </pre>

        <p class="article__paragraph">Obie wartości nie są prawidłowymi liczbami, ale każda z nich powstała w inny sposób, dlatego nie są sobie równe. Żeby sprawdzić czy dana wartość jest NaN, korzystamy z wbudowanej funkcji <strong class="bold">Number.isNaN()</strong>. Ważne jest żeby nie pomylić z globalną funkcją <strong class="bold">isNaN()</strong>. Jest to starsza wersja tej funkcji, która wymusza konwersję na typ number przed dokonaniem sprawdzenia.</p>

        <pre class="article__code">
        <code>
    console.log(NaN == NaN); // false
    console.log(('a' * 2) == NaN); // false

    console.log(Number.isNaN(NaN)); // true
    console.log(Number.isNaN('a' * 2)); // true

    let a = 'NaN';

    console.log(Number.isNaN(a)); // false
    console.log(isNaN(a)); // true
        </code>
      </pre>

        <p class="article__paragraph">Równość luźna ma kilka przypadków, które bez znajomości mechanizmu przeprowadzanej konwersji dają nam zaskakujące rezultaty. Dlatego też gdy korzystamy z operatora ==, należy przestrzegać poniższych zasad:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Jeśli po którejś ze stron występuje wartość <strong class="bold">true</strong> lub <strong class="bold">false</strong>, nigdy nie używaj operatora ==</li>
          <li class="ordered-list__item">Jeśli po którejś ze stron może wystąpić wartość <strong class="bold">[], ′′ lub 0</strong>, nie używaj operatora ==</li>
        </ol>

        <p class="article__paragraph">Oto lista szalonych wyników, których chcemy uniknąć w naszym kodzie:</p>

        <pre class="article__code">
        <code>
    console.log('0' == false); // true
    console.log(false == 0); // true
    console.log(false == ''); // true
    console.log(false == []); // true

    console.log('' == 0); // true
    console.log('' == []); // true
    console.log(0 == []); // true
        </code>
      </pre>

      </section>

    </article>


    <!-- Article 09 -->


    <article class="article">

      <header id="Instrukcje_warunkowe" class="article__header">
        <div class="decor">09</div>
        <h2 class="article__title">Instrukcje warunkowe</h2>
      </header>

      <p class="article__paragraph">Do podejmowania decyzji w kodzie JS służą instrukcje warunkowe <strong class="bold">if … else, switch</strong> oraz operator warunkowy.</p>

      <section class="article__section">
        <h3 class="article__section__title">if … else</h3>

        <p class="article__paragraph">Nasz warunek jest zamieniany na typ boolean. W zależności od otrzymanego wyniku, wykonamy dany fragment kodu.</p>

        <pre class="article__code">
        <code>
    if (warunek) {
      // jeśli prawda wykonaj ten blok kodu
    } else {
      // jeśli fałsz wykonaj ten blok kodu
    }
        </code>
      </pre>

        <p class="article__paragraph">Możemy w ten sposób sprawdzać czy dana wartość istnieje lub czy spełnia dany warunek np.</p>

        <pre class="article__code">
        <code>
    // sprawdzamy czy obiekt user posiada właściwość myName
    const user = {
      name: 'Tomasz',
      age: 29,
      country: 'Poland'
    };
    if (user.myName) {
      console.log(`Właściwość myName została odnaleziona, jej wartość wynosi ${user.myName}`);
    } else {
      console.log('Właściwość myName nie została odnaleziona w obiekcie user.');
    }
    /*
    Nasz wynik:
    Właściwość myName nie została odnaleziona w obiekcie user.
    */
    // sprawdzamy czy użytkownik może kupić legalnie piwo w Polsce
    if (user.age &gt;= 18 &amp;&amp; user.country === 'Poland') {
      console.log('Możesz legalnie kupić piwo będąc w Polsce.');
    } else {
      console.log('W Polsce, nie sprzedajemy alkoholu nieletnim!');
    }
    /*
    Nasz wynik:
    Możesz legalnie kupić piwo będąc w Polsce
    */
        </code>
      </pre>

        <p class="article__paragraph">Jeśli chcemy wykonać tylko jedną linijkę kodu możemy pominąć nawiasy klamrowe. Nie jest to zalecana praktyka, ale czasami bywa przydatna i warto o niej wiedzieć.</p>

        <pre class="article__code">
        <code>
    if (user.name === 'Tomasz') console.log('Cześć Tomasz!'); // Cześć Tomasz!
    if (user.age &gt;= 18) console.log('Jesteś pełnoletni.'); // Jesteś pełnoletni.
        </code>
      </pre>

        <p class="article__paragraph">Dodatkowo możemy zagnieżdżać warunki jeden w drugim i sprawdzać kilka warunków po sobie</p>

        <pre class="article__code">
        <code>
    if (user.country === 'Poland') {
      if (user.name === 'Janek') {
        if (user.age &gt;= 18) {
          console.log('Użytkownik przeszedł test prawdziwego Polaka.');
        }
      }
    } else if (user.country === 'Germany') {
      if (user.name === 'Hans') {
        if (user.age &gt;= 18) {
          console.log('Użytkownik przeszedł test prawdziwego Niemca.');
        }
      }
    } else {
      console.log('Użytkownik nie jest ani prawdziwym Polakiem ani prawdziwym Niemcem.');
    }
        </code>
      </pre>

        <p class="article__paragraph">Jak możemy zobaczyć w powyższym przykładzie jest to mało czytelny sposób prezentowania logiki naszego kodu. Dodatkowo łatwo w nim popełnić błąd. Dlatego korzystajmy z operatorów logicznych, żeby nie stosować zbyt wielu poziomów zagnieżdżenia kodu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">switch</h3>

        <p class="article__paragraph">Gdy chcemy wybrać co ma się stać na podstawie kilku możliwych odpowiedzi, korzystamy ze switcha. Jego działanie polega na sprawdzeniu każdej zdefiniowanej odpowiedzi do naszego warunku. Następnie wykonywany jest kod, który przeszedł nasz warunek aż do słowa kluczowego <strong class="bold">break</strong>. Służy ono do przerwania działania wykonywanego kodu i wyjście z bloku kodu <strong class="bold">switch</strong>. Musimy je dodać po każdej możliwej odpowiedzi, w przeciwnym razie zostanie wykonany cały pozostały kod. Na końcu instrukcji <strong class="bold">switch</strong> zawsze podajemy przypadek domyślny (<strong class="bold">default</strong>), który ma zostać wykonany w przypadku braku dopasowania żadnej z powyższych odpowiedzi.</p>

        <pre class="article__code">
        <code>
    switch (warunek) {
      case odpowiedź1:
        // wykonaj ten kod gdy odpowiedż1 jest poprawna
        break;
      case odpowiedź2:
        // wykonaj ten kod gdy odpowiedż2 jest poprawna
        break;
      case odpowiedź3:
        // wykonaj ten kod gdy odpowiedż3 jest poprawna
        break;
      default:
        // gdy żadna z powyższych odpowiedzi nie jest właściwa, wykonaj ten kod
    }
        </code>
      </pre>

        <strong class="bold">Przykład</strong>

        <pre class="article__code">
        <code>
    // Jaka jest stolica państwa, w którym mieszka nasz użytkownik ?
    switch (user.country) {
      case 'Poland':
        console.log('Stolicą państwa użytkownika jest Warszawa.');
        break;
      case 'Germany':
        console.log('Stolicą państwa użytkownika jest Berlin.');
        break;
      case 'Italy':
        console.log('Stolicą państwa użytkownika jest Rzym.');
        break;
      default:
        console.log('Użytkownik mieszka poza Europą.');
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operator warunkowy</h3>

        <p class="article__paragraph">Gdy mamy tylko dwie możliwości do wyboru, możemy skrócić nasz kod, przez zastosowanie operatora warunkowego (nazywanego też operatorem trójkowym).</p>

        <pre class="article__code">
        <code>
    (warunek) ? (wykonaj gdy prawda) : (wykonaj gdy fałsz)
        </code>
      </pre>
      </section>

      <strong class="bold">Przykład</strong>

      <pre class="article__code">
        <code>
    let a = 8;
    let b = 5;
    const biggerNumber = (a &gt;= b) ? a : b;
    console.log(biggerNumber); // 8
        </code>
      </pre>

    </article>


    <!-- Article 10 -->


    <article class="article">

      <header id="Tablice" class="article__header">
        <div class="decor">10</div>
        <h2 class="article__title">Tablice</h2>
      </header>

      <p class="article__paragraph">Tablice są specjalnym typem obiektu w JS. Mają więc dostęp do wielu metod pozwalających na manipulowanie nimi. W tym wpisie nie będę omawiał wszystkich dostępnych dla nich metod. Skupię się na podstawie ich działania. Tablice służą do wygodnego przechowywania większych ilości danych typu prostego.</p>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie tablic</h3>

        <p class="article__paragraph">Tablicę możemy utworzyć za pomocą literału tablicy.</p>

        <pre class="article__code">
        <code>
    // tworzymy pustą tablicę
    const emptyArray = [];
    // tworzymy tablicę przechowującą imiona
    const namesArray = ['Tomasz', 'Daniel', 'Mateusz'];
        </code>
      </pre>

        <p class="article__paragraph">Drugim sposobem na stworzenie tablicy jest użycie konstruktora <strong class="bold">new</strong>.</p>

        <pre class="article__code">
        <code>
    // tworzymy pustą tablicę
    const emptyArray = new Array();
    // tworzymy tablicę przechowującą imiona
    const namesArray = new Array('Tomasz', 'Daniel', 'Mateusz');
    // tworzymy pustą tablicę o długości 10 elementów
    const undefinedElementsArray = new Array(10);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Właściwość length</h3>

        <p class="article__paragraph">Opisuje ona długość tablicy, czyli liczbę elementów jakie się w niej znajdują. Należy pamiętać, że w tablicy mogą znajdować się puste miejsca.</p>

        <pre class="article__code">
        <code>
    // w tablicy znajdują się 3 imiona i jedno puste miejsce zawierające wartość undefined
    const namesArray = ['Tomasz', 'Daniel', , 'Mateusz'];
    console.log(namesArray.length); // 4
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Dostęp do przechowywanych wartości</h3>

        <p class="article__paragraph">Wszystkie wartości w tablicy posiadają swój indeks, czyli liczbę, która określa położenie danej wartości w tablicy. Indeksy zaczynamy liczyć od zera. Dla tablicy o długości 3 liczymy (0, 1, 2). Aby pobrać wartość z tablicy wpisujemy jej nazwę oraz indeks w nawiasie kwadratowym. <strong class="bold">nazwa[indeks]</strong></p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">pierwszy element w tablicy ma zawsze indeks zero: <strong class="bold">nazwa[0]</strong></li>
          <li class="unordered-list__item">ostatni element w tablicy ma indeks: <strong class="bold">nazwa[nazwa.length – 1]</strong></li>
        </ul>

        <pre class="article__code">
        <code>
    // pobieranie wartości z tablicy
    const namesArray = ['Tomasz', 'Daniel', , 'Mateusz'];
    console.log(namesArray[0]); // 'Tomasz'
    console.log(namesArray[1]); // 'Daniel'
    console.log(namesArray[2]); // undefined
    console.log(namesArray[namesArray.length - 1]); // 'Mateusz'
    // nadpisywanie wartości w tablicy
    namesArray[2] = 'Przemek';
    console.log(namesArray); // ["Tomasz", "Daniel", "Przemek", "Mateusz"]
    // usuwanie wartości z tablicy
    delete namesArray[0];
    console.log(namesArray); // [empty, "Daniel", "Przemek", "Mateusz"]
        </code>
      </pre>

        <p class="article__paragraph">Możemy najpierw utworzyć pustą tablicę a następnie dodawać do niej wartości za pomocą indeksów. W takim przypadku musimy być ostrożni, ponieważ możemy utworzyć wiele pustych miejsc w naszej tablicy.</p>

        <pre class="article__code">
        <code>
    const animalsArray = [];
    animalsArray[2] = 'cat';
    animalsArray[22] = 'dog';
    console.log(animalsArray); // [empty × 2, "cat", empty × 19, "dog"]
    console.log(animalsArray.length); // 23
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tablice wielowymiarowe</h3>

        <p class="article__paragraph">W tablicy możemy przechowywać dowolne wartości, nie muszą to być jedynie wartości typu prostego. Możemy w nich umieszczać też obiekty i inne tablice. Gdy tablica zawiera inne tablice jest nazywana tablicą wielowymiarową. Aby dostać się do jej wartości tworzymy ciąg nawiasów, które określają kolejno indeksy danej tablicy. <strong class="bold">nazwa[indeks tablicy nr 1][indeks tablicy nr 2][indeks tablicy nr 3] itd.</strong></p>

        <pre class="article__code">
        <code>
    const multidimensionalArray = [['rekin', 'sum'], ['delfin', 'wieloryb'], ['zółw', 'homar']];
    console.log(multidimensionalArray[0][1]); // 'sum'
    console.log(multidimensionalArray[1][0]); // 'delfin'
    console.log(multidimensionalArray[2][0]); // 'żółw'
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Pętla forEach</h3>
      </section>

      <p class="article__paragraph">Jedyną metodą o jakiej chcę wspomnieć w tym wpisie jest pętla forEach, ponieważ jest to temat powiązany z tym co będzie w kolejnym wpisie, czyli dokładnym omówieniem pętli w JavaScrpit.</p>

      <p class="article__paragraph">Pisząc w skrócie, pętle pozwalają nam na wykonanie danego fragmentu kodu wielokrotnie, dopóki jest spełniony określony przez nas warunek. Pętle są często wykorzystywane do przeglądania i manipulowania wartościami w tablicach.</p>

      <p class="article__paragraph">Cechą wyróżniającą tą metodę jest fakt, że pętla ta zostanie wykonana tylko dla tych elementów, które mają przypisaną wartość. Wszystkie puste miejsca w tablicy są pomijane, mimo że ich wartość również wynosi <strong class="bold">undefined</strong>.</p>

      <pre class="article__code">
        <code>
    const numbersArray = [0, 1, undefined, null, 4, , 6, 7, , 9];
    numbersArray.forEach((num) =&gt; {
      console.log(num * 2);
    });
    /*
    otrzymamy:
    0
    2
    NaN
    0
    8
    12
    14
    18
    */
    console.log(numbersArray[2]); // undefined
    console.log(numbersArray[5]); // undefined
        </code>
      </pre>

    </article>


    <!-- Article 11 -->


    <article class="article">

      <header id="Podstawowe_petle" class="article__header">
        <div class="decor">11</div>
        <h2 class="article__title">Podstawowe pętle</h2>
      </header>

      <p class="article__paragraph">Gdy chcemy wykonać dany kawałek kodu wielokrotnie, stosujemy w tym celu pętle. Pozwala nam to na pisanie krótszego i bardziej czytelnego kodu, który jest łatwiejszy w utrzymaniu i debugowaniu. W tym wpisie przyjrzymy się trzem podstawowym pętlom dostępnym w JS. Są to pętle: <strong class="bold">for, while, do…while</strong>.</p>

      <section class="article__section">
        <h3 class="article__section__title">Pętla for</h3>

        <pre class="article__code">
        <code>
    for ([wyrażenieInicjalizacji]; [warunek]; [wyrażenieInkrementacji]) {
        Instrukcja
     }
        </code>
      </pre>

        <p class="article__paragraph">Załóżmy, że nie możemy spać i śpiewamy sobie w myślach piosenkę <a class="article__link" href="https://www.youtube.com/watch?v=aI3k7X78-KY" target="_blank">Manifest Dziecięcy</a> – Witka Muzyka Ulicy. Za pomocą kodu odliczanie z tej piosenki możemy napisać tak:</p>

        <pre class="article__code">
        <code>
    for (let i = 1; i  &lt; 11; i += 1) {
      console.log('i', i);
    }

    /*
     Co da nam w wyniku:

      i 1
      i 2
      i 3
      i 4
      i 5
      i 6
      i 7
      i 8
      i 9
      i 10
    */
        </code>
      </pre>

        <p class="article__paragraph">Jest ogólnie przyjętym zwyczajem, że w pętlach wykorzystujemy zmienne o nazwie <strong class="bold">i</strong> lub <strong class="bold">j</strong> do iteracji. Jak możemy zauważyć najpierw inicjalizujemy naszą zmienną <strong class="bold">i</strong> i przypisujemy jej wartość początkową, w naszym przypadku jest to liczba 1.</p>

        <pre class="article__code">
        <code>
    for (let i = 1; --; --) {
      --
    }
        </code>
      </pre>

        <p class="article__paragraph">Następnie jest sprawdzany warunek, jeśli jego wynik da nam wartość <strong class="bold">true</strong> wykonywany jest kod wewnątrz nawiasów klamrowych (blok kodu pętli).</p>

        <pre class="article__code">
        <code>
    for (--; i &lt; 11; --) {
      console.log('i', i);
    }
        </code>
      </pre>

        <p class="article__paragraph">Ostatnim krokiem jest zwiększenie lub zmniejszenie wartości zmiennej <strong class="bold">i</strong>.</p>

        <pre class="article__code">
        <code>
    for (--; --; i += 1) {
      --
    }
        </code>
      </pre>

        <p class="article__paragraph">Cała procedura powtarza się ponownie aż do momentu gdy warunek zwróci nam wartość <strong class="bold">false</strong>. Należy uważać żeby nie utworzyć pętli działającej w nieskończoność. Ponieważ nasza przeglądarka się zawiesi, użycie procesora skoczy do 100% i pozostanie nam jedynie <strong class="bold">ctrl + alt + del</strong>, żeby wyjść z tej patowej sytuacji 🙂</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Pętla while</h3>

        <pre class="article__code">
        <code>
    while (warunek) {
         instrukcja
     }
        </code>
      </pre>

        <p class="article__paragraph">Działa podobnie do pętli for. Też jest wykonywana dopóki jest spełniony jej warunek. Tym razem jednak bardziej musimy pamiętać o zmianie jej licznika, ponieważ zmieniamy go w jej wnętrzu.</p>

        <pre class="article__code">
        <code>
    let i = 1;
    while (i &lt; 11) {
        console.log('i', i);
        i += 1;
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Pętla do…while</h3>

        <pre class="article__code">
        <code>
    do {
        instrukcja
     }
    while (warunek);
        </code>
      </pre>

        <p class="article__paragraph">Jej cechą charakterystyczną jest to, że zawsze zostanie wykonana przynajmniej raz, ponieważ jej warunek jest sprawdzany na końcu za jej blokiem kodu.</p>

        <pre class="article__code">
        <code>
    let i = 1;
    do {
      console.log('i', i);
      i += 1;
    } while (i &lt; 11);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Pętle a tablice</h3>

        <p class="article__paragraph">Bardzo często pętle są wykorzystywane do działania na tablicach. Wracając do naszej piosenki, tym razem chcemy wypisywać słowa zamiast cyfr w jej refrenie. Możemy to zrobić w następujący sposób:</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'pięć', 'sześć', 'siedem', 'osiem', 'dziewięć', 'dziesięć']
    for (let i = 0; i &lt; words.length; i += 1) {
      console.log('i', words[i]);
    }
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, że zaczynamy od 0, ponieważ jak wiemy z poprzedniej lekcji elementy w tablicach są indeksowane od 0. Następnie chcemy iterować przez wszystkie elementy jakie się w niej znajdują, w tym celu wykorzystujemy właściwość <strong class="bold">length</strong> aby pobrać długość tablicy. Oto nasz wynik:</p>

        <pre class="article__code">
        <code>
    /*
        i raz
        i dwa
        i trzy
        i cztery
        i pięć
        i sześć
        i siedem
        i osiem
        i dziewięć
        i dziesięć
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">break</h3>

        <p class="article__paragraph">Do przerwania wykonywania pętli w trakcie jej działania służy słowo kluczowe <strong class="bold">break</strong>. Załóżmy, że szukamy w tablicy danej wartości i gdy tylko ją znajdziemy chcemy przerwać wykonywanie naszej pętli, żeby nie marnować czasu na czekanie aż sprawdzi wszystkie jej elementy. Żeby było jeszcze ciekawiej tym razem zaczniemy pętle od końca tablicy i będziemy szli w kierunku jej pierwszego elementu.</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'pięć', 'sześć', 'siedem', 'osiem', 'dziewięć', 'dziesięć'];
    for (let i = words.length - 1; i &gt;= 0; i -= 1) {
      if (words[i] === 'osiem') {
        break;
      }
      console.log('i', words[i]);
    }
    /*
    Nasz wynik:
    i dziesięć
    i dziewięć
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">continue</h3>

        <p class="article__paragraph">Do pomijania wybranych iteracji służy słowo kluczowe continue. Tym razem jesteśmy pijani podczas śpiewania naszej piosenki i mamy problemy z liczeniem wstecz. Przez co umknęło nam kilka liczb 🙂</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'pięć', 'sześć', 'siedem', 'osiem', 'dziewięć', 'dziesięć'];
    for (let i = words.length - 1; i &gt;= 0; i -= 1) {
      if (words[i] === 'osiem' || words[i] === 'trzy' || words[i] === 'pięć') {
        continue;
      }
      console.log('i', words[i]);
    }
    /*
    i dziesięć
    i dziewięć
    i siedem
    i sześć
    i cztery
    i dwa
    i raz
    */
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Pętla w pętli</h3>

        <p class="article__paragraph">Może się zdarzyć, że jedna pętla nam nie wystarczy i będziemy potrzebowali zagnieżdżać jedną pętle w drugiej. W takiej sytuacji koniecznie trzeba pamiętać o zastosowaniu różnych zmiennych dla każdej z pętli. W pierwszej pętli korzystamy z iteratora o nazwie <strong class="bold">i</strong>, a w drugiej z iteratora o nazwie <strong class="bold">j</strong>.</p>

        <pre class="article__code">
        <code>
    const arrayOfArrays = [['raz', 'dwa', 'trzy'], ['cztery', 'pięć', 'sześć'], ['siedem', 'osiem', 'dziewięć']];
    for (let i = 0; i &lt; arrayOfArrays.length; i += 1) {
      console.log('---------')
      for (let j = 0; j &lt; arrayOfArrays[0].length; j += 1) {
        console.log(arrayOfArrays[i][j]);
      }
    }
    /*
    Nasz wynik:
    ---------
    raz
    dwa
    trzy
    ---------
    cztery
    pięć
    sześć
    ---------
    siedem
    osiem
    dziewięć
    */
        </code>
      </pre>
      </section>

    </article>


    <!-- Article 12 -->


    <article class="article">

      <header id="Funkcje_cz1" class="article__header">
        <div class="decor">12</div>
        <h2 class="article__title">Funkcje cz.1</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Czym są funkcje ?</h3>

        <p class="article__paragraph">Funkcje możemy sobie wyobrazić jako maszyny do przetwarzania, jako przykład weźmy drukarkę. Żeby coś wydrukować musimy włożyć do drukarki papier, toner i przesłać informacje, które chcemy przenieść na papier. W rezultacie otrzymujemy zadrukowane strony naszego dokumentu. Tak samo jest z funkcjami, wkładamy do nich argumenty. One przetwarzają je w swoim wnętrzu i zwracają nam jakiś wynik.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Po co są funkcje ?</h3>

        <p class="article__paragraph">Dzięki nim mamy możliwość wielokrotnego używania tego samego fragmentu kodu bez konieczności powtarzania go. Pozwala to nam na łatwiejsze dokonywanie zmian w naszym programie, znajdowanie błędów i znacznie skraca długość kodu. W programowaniu istnieje zasada DRY ( Don’t Repeat Yourself ) czyli nie powtarzaj się i warto ją stosować.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Deklaracja funkcji</h3>

        <pre class="article__code">
        <code>
    function nazwa(parametry) {
        ciało funkcji – dzieje się tu cała logika i przetwarzanie parametrów
        return  zwracany przez funkcję wynik
    }
        </code>
      </pre>

        <p class="article__paragraph">Jest to pierwszy ze sposobów na utworzenie funkcji. Powstała w ten sposób funkcja ulega mechanizmowi wynoszenia, czyli jest przenoszona na początek skryptu, przez co jest dostępna w całym naszym programie. Sztampowym przykładem jest funkcja, która sumuje dwie liczby.</p>

        <pre class="article__code">
        <code>
    function sum(a, b) {
      return a + b;
    }

    console.log(sum(2, 3)); // 5
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wyrażenie funkcyjne</h3>

        <p class="article__paragraph">Drugim sposobem stworzenia funkcji jest wyrażenie funkcyjne, czyli utworzenie zmiennej, która będzie przechowywała referencję do funkcji (strzałka wskazująca, gdzie znajduje się nasza funkcja). W odróżnieniu od deklaracji funkcji, funkcje stworzone w ten sposób nie są wynoszone, więc możemy ich używać tylko w tej części naszego skryptu, która występuje za miejscem ich utworzenia.</p>

        <pre class="article__code">
        <code>
    const sum = function (a, b) {
      return a + b;
    };

    console.log(sum(2, 3)); // 5
        </code>
      </pre>

        <p class="article__paragraph">Poniższy kod generuje błąd.</p>

        <pre class="article__code">
        <code>
    console.log(sum(2, 3)); // 5

    const sum = function (a, b) {
      return a + b;
    };
    // Uncaught ReferenceError: sum is not defined
        </code>
      </pre>

        <p class="article__paragraph">Jak możemy zauważyć funkcja ta nie ma swojej nazwy, dlatego nazywana jest funkcją anonimową. Odwołujemy się do niej za pośrednictwem nazwy naszej zmiennej. Możemy jednak nadać jej nazwę jeśli chcemy.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wywoływanie funkcji</h3>

        <p class="article__paragraph">Aby wywołać funkcję wpisujemy jej nazwę oraz parę nawiasów <strong class="bold">nazwa()</strong>, w tym momencie nasza funkcja zostaje uruchomiona. Kontynuując nasz przykład z funkcją sum. Możemy ją wywołać bez przekazania argumentów do jej wnętrza.</p>

        <pre class="article__code">
        <code>
    console.log(sum()); // NaN
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w rezultacie otrzymamy Not a Number. Ponieważ nie przekazaliśmy do niej żadnych argumentów, wartość a i b wynosi <strong class="bold">undefined</strong>. Dodając obie te wartości do siebie otrzymamy <strong class="bold">NaN</strong>, czyli nie prawidłową wartość liczbową.</p>

        <p class="article__paragraph">Możemy się przed tym zabezpieczyć przypisując domyślne wartości parametrów. Wtedy za każdym razem gdy, któryś z nich zostanie pominięty w wywołaniu, zostanie użyta jego wartość domyślna.</p>

        <p class="article__paragraph">Pierwszy ze sposobów takiego zabezpieczenia wykorzystuje ES6.</p>

        <pre class="article__code">
        <code>
    function sum(a = 0, b = 0) {
      return a + b;
    }
    console.log(sum()); // 0
        </code>
      </pre>

        <p class="article__paragraph"> Nim wprowadzono ES6 stosowano poniższą metodę:</p>

        <pre class="article__code">
        <code>
    function sum(a, b) {
      a = a || 0;
      b = b || 0;
      return a + b;
    }
    console.log(sum()); // 0
        </code>
      </pre>

        <p class="article__paragraph">Gdy nie przekażemy żadnego argumentu wartość a wynosi <strong class="bold">undefined</strong>, następnie operator logiczny (lub) sprawdza wartość po jego lewej stronie, ponieważ jest to wartość fałszywa wybiera wartość po swojej prawej stronie i przypisuje ją do zmiennej <strong class="bold">a</strong>. W tym momencie <strong class="bold">a = 0</strong>.</p>

        <p class="article__paragraph">Możemy też przekazać do funkcji więcej argumentów niż wymaga przez nią ilość parametrów. Argumentem jest to co wkładamy do funkcji w momencie jej wywołania np. <strong class="bold">sum(2, 3)</strong>, argumenty to liczby <strong class="bold">2</strong> i <strong class="bold">3</strong>. Parametrem natomiast jest nazwa zmiennej wykorzystywana do operacji wewnątrz funkcji, czyli <strong class="bold">a</strong> i <strong class="bold">b</strong> w naszym przykładzie. Gdy przekażemy większą ilość argumentów do funkcji niż wymagana, wszystkie dodatkowe są ignorowane.</p>

        <pre class="article__code">
        <code>
    console.log(sum(2, 3, 5, 66)); // 5
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">return</h3>

        <p class="article__paragraph">Aby zwrócić wartość z funkcji wykorzystujemy słowo kluczowe return. Kończy ono działanie funkcji i zwraca wartość. W funkcji może występować kilka słów return, zawsze jednak działanie funkcji jest kończone w chwili dotarcia do pierwszego z nich.</p>

        <pre class="article__code">
        <code>
    function checkAge(age) {
      if (age &gt;= 18) {
        return 'Możesz wejść do klubu.';
      }
      return 'Młodocianym wstęp wzbroniony!';
    }
    console.log(checkAge(29)); // Możesz wejść do klubu.
        </code>
      </pre>

        <p class="article__paragraph">Jeśli pominiemy słowo <strong class="bold">return</strong>, funkcja zwróci wartość <strong class="bold">undefined</strong>. Przeważnie chcemy przechować wynik działa naszej funkcji w jakiejś zmiennej aby móc go później wykorzystać.</p>

        <pre class="article__code">
        <code>
    let guest = checkAge(16);
    console.log(guest); // Młodocianym wstęp wzbroniony!

    function printUserName(name) {
      console.log(`Mam na imię ${name}`);
    }

    let printMyName = printUserName('Tomasz') // Mam na imię Tomasz
    console.log(printMyName); // undefined
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 13 -->


    <article class="article">

      <header id="Funkcje_cz2" class="article__header">
        <div class="decor">13</div>
        <h2 class="article__title">Funkcje cz.2</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Zakres lokalny funkcji</h3>

        <p class="article__paragraph">Z wcześniejszego wpisu na temat zmiennej var, wiemy, że jej zakresem może być zakres lokalny funkcji. Oznacza to, że możemy tworzyć zmienne, które są zamknięte w ciele naszej funkcji i nie da się do nich odwołać spoza niej. Za każdym razem gdy dana funkcja jest wywoływana, zostaje utworzona zmienna w niej zadeklarowana, która jest usuwana po zakończeniu jej działania przez mechanizm usuwania nieużytków aby zwolnić miejsce w pamięci.</p>

        <pre class="article__code">
        <code>
    function defineMyName() {
      let myName = 'Tomasz';
    }

    defineMyName();
    console.log(myMame); // Uncaught ReferenceError: myMame is not defined
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Zakres zagnieżdżony</h3>

        <p class="article__paragraph">Gdy mamy kilka funkcji zagnieżdżonych jedna w drugiej. Najpierw silnik JS sprawdza bieżący zakres leksykalny funkcji, wykonywanego kodu. Jeśli zmienna nie zostanie w nim odnaleziona, sprawdza kolejny zakres zewnętrzny i kontynuuje sprawdzanie tak długo aż znajdzie szukaną zmienną lub dotrze do zakresu globalnego. W tym momencie jeśli zmienna nie została odnaleziona zgłaszany jest błąd.</p>

        <pre class="article__code">
        <code>
    let someString = null;
    let anotherString = null;

    function globalFunction() {
      let someString = 'Hello';

      function internalFunction1() {
        let anotherString = 'Word';
        console.group('internalFunction1');
        console.log(someString);
        console.log(anotherString);
        console.groupEnd();
      }

      function internalFunction2() {
        console.group('internalFunction2');
        console.log(someString);
        console.log(anotherString);
        console.groupEnd();
      }

      console.group('globalFunction');
      console.log(someString);
      console.log(anotherString);
      console.groupEnd();
      internalFunction1();
      internalFunction2();
    }

    globalFunction();

    /*
    globalFunction
      Hello
      null
    internalFunction1
      Hello
      Word
    internalFunction2
      Hello
      null
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Domknięcia</h3>

        <p class="article__paragraph">Funkcje w JavaScript są wartościami pierwszej klasy co oznacza, że mogą być przekazywane i zwracane przez inne funkcje.</p>

        <p class="article__paragraph">Domknięcia pozwalają nam na dostęp do zmiennych zadeklarowanych w zakresie leksykalnym funkcji nawet gdy wywołamy daną funkcję poza jej zakresem leksykalnym.</p>

        <pre class="article__code">
        <code>
    function globalFunction() {
      let myName = 'Tomasz';

      function internalFunction() {
        return `Cześć, ${myName}!`;
      }
      return internalFunction;
    }

    let sayHello = globalFunction();
    console.log(sayHello()); // Cześć, Tomasz!
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyższym przykładzie funkcji <strong class="bold">sayHello</strong> przypisujemy wynik wykonania funkcji <strong class="bold">globalFunction</strong>. Ponieważ <strong class="bold">globalFunction</strong> zwraca nam funkcję wewnętrzną <strong class="bold">internalFunction</strong>. Zatem funkcja <strong class="bold">sayHello</strong> jest referencją do funkcji <strong class="bold">internalFunction</strong>.</p>

        <p class="article__paragraph">W tym momencie możemy wywołać funkcję wewnętrzną za pomocą <strong class="bold">sayHello()</strong>, poza jej zakresem leksykalnym, mimo, że funkcja <strong class="bold">globalFunction</strong> została już wykonana nadal mamy dostęp do jej zmiennej <strong class="bold">myName</strong>. Właśnie na tym polega mechanizm domknięcia.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">IIFE</h3>

        <p class="article__paragraph">To skrót od Immediately Invoked Function Expression, są to funkcje anonimowe, które są wywoływane zaraz po ich deklaracji.</p>

        <pre class="article__code">
        <code>
    let getMyName = (function() {
        let myName = 'Tomasz';
        return myName;
    })();

    console.log(getMyName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyższym przykładzie aby wykonać funkcję natychmiast po jej deklaracji bierzemy ją w dodatkowy nawias, a następnie dodajemy parę pustych nawiasów na jej końcu. Tak samo jak wywołujemy zwykła funkcję.</p>

        <p class="article__paragraph">IIFE są wykorzystywane we wzorcu modułu, który pozwala nam na zgrupowanie podobnej funkcjonalności w jednym obiekcie oraz na stworzenie prywatnych zmiennych, które mogą być modyfikowane jedynie za pośrednictwem udostępnionych przez nas metod.</p>

        <pre class="article__code">
        <code>
    const myModule = (function () {
      let myName = 'Tomasz';
      let myAge = 29;

      return {
        increaseMyAge: function() {
          return myAge += 1;
        },
        getMyAge: function() {
          return myAge;
        }
      };
    })();
    console.log(myModule.myName); // undefined
    console.log(myModule.myAge); // undefined
    myModule.increaseMyAge();
    console.log(myModule.getMyAge()); // 30
        </code>
      </pre>
      </section>

    </article>


    <!-- Article 14 -->


    <article class="article">

      <header id="Funkcje_cz3" class="article__header">
        <div class="decor">14</div>
        <h2 class="article__title">Funkcje cz.3</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Funkcje strzałkowe</h3>

        <p class="article__paragraph">W ES6 zostały wprowadzone funkcje strzałkowe. Mają krótszą składnie, dzięki czemu idealnie nadają się do stosowania jako wyrażenia zwrotne (o nich w dalszej części tego wpisu) . Są bardziej czytelne niż standardowe funkcje przy prostych operacjach. Dodatkowo nie mają wiązania <strong class="bold">this</strong>. Możemy je tylko tworzyć jako wyrażenia funkcyjne, nie podlegają więc wynoszeniu.</p>

        <pre class="article__code">
        <code>
    (parametr1, parametr2, itd.) =&gt; { return wynik; }
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy pomijamy słowo kluczowe <strong class="bold">function</strong>, dodajemy natomiast strzałkę za nawiasami z parametrami funkcji. Następnie tworzymy ciało funkcji w nawiasach klamrowych.</p>

        <pre class="article__code">
        <code>
    const mathOperation = (a, b, c) =&gt; {
      if (c &gt; 0) {
        return a + b;
      }
      return a - b;
    };
        </code>
      </pre>

        <p class="article__paragraph">W przypadku gdy nasza funkcja przyjmuje tylko jeden parametr i jej jedynym zadaniem jest zwrócić nam wynik. Możemy uprościć nasz zapis jeszcze bardziej i pominąć nawiasy na około parametrów oraz nawiasy klamrowe ciała funkcji i słowo kluczowe <strong class="bold">return</strong>.</p>

        <pre class="article__code">
        <code>
    const greetings = name =&gt; `Cześć ${name}!`;
    console.log(greetings('Tomasz')); // Cześć Tomasz!

    const difference = (a, b) =&gt; a - b;
    console.log(difference(10, 4)); // 6
        </code>
      </pre>

        <p class="article__paragraph">Brak wiązania <strong class="bold">this</strong>. Na temat słowa kluczowego <strong class="bold">this</strong> napisałem już wpis, który można przeczytać <a class="article__link" target="_blank" href="http://blog.tomasz-rybacki.pl/javascript/this/">tutaj</a>. W odniesieniu do funkcji strzałkowych słowo <strong class="bold">this</strong> odnosi się do zakresu nadrzędnego funkcji lub zakresu globalnego.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wyrażenia zwrotne</h3>

        <p class="article__paragraph">W poprzednim wpisie wspomniałem, że do funkcji możemy przekazywać również inne funkcje jako parametry. Właśnie takie funkcje nazywamy wyrażeniami zwrotnymi (ang. callback). Mamy dostępnych wiele wbudowanych metod, które przyjmują inne funkcje jako parametry. Jako przykład weźmy funkcję <strong class="bold">setTimeout</strong>.</p>

        <pre class="article__code">
        <code>
    window.setTimeout(callback, opóźnienie)
        </code>
      </pre>

        <p class="article__paragraph">Funkcja ta wykonuje dostarczoną przez nas funkcję po upływie określonej liczby milisekund.</p>

        <pre class="article__code">
        <code>
    function printMessage() {
      console.log('Zostałam wykonana po upływie 1 sekundy.');
    }
    window.setTimeout(printMessage, 1000);

    // Zostałam wykonana po upływie 1 sekundy.
        </code>
      </pre>

        <p class="article__paragraph">Możemy również wykorzystać właśnie poznane przez nas funkcje strzałkowe, zamiast deklarowania oddzielnej funkcji <strong class="bold">printMessage</strong>, możemy przekazać anonimową funkcję strzałkową zapisaną wprost w metodzie <strong class="bold">setTimeout</strong>.</p>


        <pre class="article__code">
        <code>
    window.setTimeout(() =&gt; {
      console.log('Zostałam wykonana po upływie 1 sekundy.')
    }, 1000);

    // Zostałam wykonana po upływie 1 sekundy.
        </code>
      </pre>

        <p class="article__paragraph">Możemy też pisać własne funkcje, które przyjmują inne funkcje jako parametry.</p>

        <pre class="article__code">
        <code>
    function randomBetween(callback, min, max) {
      const randomNumber = Math.floor(Math.random() * (max - min + 1) + min);
      callback(randomNumber);
    }

    randomBetween((number) =&gt; {
      console.log(`Wylosowaną liczbą jest ${number}!`);
    }, 10, 20);
    // Wylosowaną liczbą jest 12!
        </code>
      </pre>

        <p class="article__paragraph"> W powyższym przykładzie funkcja randomBetween losuję liczbę z podanego przedziału. Jako pierwszy argument przyjmuje funkcję, która wyświetla wiadomość. Kolejne dwa argumenty określają do jakiego przedziału ma należeć wylosowana liczba. Widzimy, że funkcja zwrotna zostaje wywołana w ciele funkcji randomBetween z wylosowaną wcześniej liczbą. Liczba ta jest przekazywana do anonimowej funkcji strzałkowej, która następnie wyświetla ją w konsoli naszej przeglądarki.</p>
      </section>

    </article>


    <!-- Article 15 -->


    <article class="article">

      <header id="Objekty_cz1" class="article__header">
        <div class="decor">15</div>
        <h2 class="article__title">Obiekty cz.1</h2>
      </header>

      <p class="article__paragraph">W JavaScript prawie wszystko jest obiektem (funkcje, tablice, obiekty wbudowane). W kilku kolejnych wpisach opiszę w jaki sposób działają obiekty i na czym polega programowanie obiektowe w JS.</p>

      <p class="article__paragraph">Obiekty są kolekcją wartości składających się z par <strong class="bold">nazwa: wartość</strong>, służących do opisywania dowolnej rzeczy np. ludzi, samochodów, zwierząt itd.</p>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie obiektu</h3>

        <p class="article__paragraph">Najprostszym sposobem utworzenia pojedynczego obiektu jest opakowanie naszych par <strong class="bold">nazwa: wartość</strong> w nawiasy klamrowe <strong class="bold">{}</strong>, jest to tak zwany literał obiektu. Wartości przechowywane w obiekcie nazywamy <strong class="bold">właściwościami</strong> natomiast funkcje przechowywane w obiekcie to <strong class="bold">metody</strong> tego obiektu.</p>

        <pre class="article__code">
        <code>
    const myFamilyHouse = {
      city: 'Ostrołęka',
      inhabitants: 2,
      floors: 2,

      neighborhood: function () {
        return 'Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgiełku.';
      }
    };
        </code>
      </pre>

        <p class="article__paragraph">Powyższy obiekt opisujący mój rodzinny dom ma 3 właściwości: <strong class="bold">city, inhabitants, floors</strong>. Posiada też jedną metodę: <strong class="bold">neighborhood</strong>.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Dostęp do wartości</h3>

        <p class="article__paragraph">Aby odczytać wartość właściwości lub wywołać metodę używamy notacji z kropką lub notacji z nawiasami.</p>

        <pre class="article__code">
        <code>
    console.log(myFamilyHouse.city); // Ostrołęka
    console.log(myFamilyHouse.floors); // 2

    console.log(myFamilyHouse.neighborhood());
    // Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgiełku.

    console.log(myFamilyHouse['inhabitants']); // 2
    console.log(myFamilyHouse['neighborhood']())
    // Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgiełku.
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyższym przykładzie notacja z kropką jest o wiele bardziej czytelna dlatego jest najczęściej stosowana. Ma jednak swoje ograniczenia w postaci:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">nazwy właściwości muszą być znakami alfanumerycznymi (z uwzględnieniem znaków _ i $)</li>
          <li class="unordered-list__item">nie mogą zaczynać się od cyfry</li>
          <li class="unordered-list__item">nie mogą zawierać nazw zmiennych</li>
        </ul>

        <p class="article__paragraph">Natomiast w przypadku notacji z nawiasami możemy używać:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">znaku spacji w nazwach</li>
          <li class="unordered-list__item">nazw zmiennych</li>
          <li class="unordered-list__item">cyfr na początku łańcucha znaków</li>
        </ul>

        <p class="article__paragraph">Musimy pamiętać, że identyfikatory w notacji z nawiasami muszą być wartością typu 'string' lub zmienną, która zawiera wartości typu 'string'.</p>
      </section>


      <section class="article__section">
        <h3 class="article__section__title">Nadpisanie wartości</h3>

        <p class="article__paragraph">Aby zmienić istniejącą wartość lub dodać nową, stosujemy zwykłe przypisanie. Obiekty są modyfikowalne (mutable data), w każdej chwili możemy modyfikować ich zawartość. Jeśli obiekt zawiera już podany klucz jego wartość zostanie nadpisana, w przeciwnym razie zostanie on dodany do naszego obiektu.</p>

        <pre class="article__code">
        <code>
    myFamilyHouse.garden = true;
    myFamilyHouse.inhabitants = 3;

    myFamilyHouse.income = function () {
      return myFamilyHouse.inhabitants * 1000;
    };

    console.log(myFamilyHouse.income()); // 3000
    console.log(myFamilyHouse);
    // { city: "Ostrołęka", inhabitants: 3, floors: 2, neighborhood: ƒ, garden: true, income: ƒ }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Usuwanie właściwości i metod</h3>

        <p class="article__paragraph">Aby pozbyć się właściwości lub metody korzystamy z operatora <strong class="bold">delete</strong>.</p>

        <pre class="article__code">
        <code>
    delete myFamilyHouse.garden;
    delete myFamilyHouse.income;

    console.log(myFamilyHouse);
    // { city: "Ostrołęka", inhabitants: 3, floors: 2, neighborhood: ƒ }
        </code>
      </pre>

        <p class="article__paragraph">W tym momencie omówiliśmy podstawy funkcjonowania obiektów. Wystarczy na dzisiaj, wiedza przyswajana w małych dawkach lepiej się wchłania 🙂</p>
      </section>
    </article>


    <!-- Article 16 -->


    <article class="article">

      <header id="Objekty_cz2" class="article__header">
        <div class="decor">16</div>
        <h2 class="article__title">Obiekty cz.2</h2>
      </header>

      <p class="article__paragraph">Dzisiejszy wpis nie należy do najłatwiejszych dlatego warto przeczytać go kilkukrotnie i samemu przećwiczyć w edytorze. Będzie za to ciekawie, ponieważ poznamy podstawowy mechanizm działania języka JavaScript.</p>

      <section class="article__section">
        <h3 class="article__section__title">Konstruktory</h3>

        <p class="article__paragraph">Są to zwyczajne funkcje, których nazwę piszemy z wielkiej litery (jest to ogólnie przyjęta konwencja). Pozwalają nam tworzyć wiele podobnych do siebie obiektów (o tych samych właściwościach i metodach). Konstruktor możemy sobie wyobrazić jako formę do ciastek, przy pomocy której wyciskamy wiele podobnych ciasteczek. Każde z powstałych ciasteczek jest nową instancją obiektu. Czyli samodzielnym obiektem, który powstał na bazie danego konstruktora.</p>

        <pre class="article__code">
        <code>
    function User(name, age, location) {
      this.name = name;
      this.age = age;
      this.location = location;

      this.greetings = function () {
        console.log(`Witaj ${this.name}, dobrze cię widzieć!`);
      };
    }

    const user1 = new User('Tomasz', 29, 'Poland');
    const user2 = new User('Daniel', 26, 'Poland');

    user1.greetings(); // Witaj Tomasz, dobrze cię widzieć!
    console.log(user1);
    // {name: "Tomasz", age: 29, location: "Poland", greetings: ƒ}
        </code>
      </pre>

        <p class="article__paragraph">W powyższym przykładzie utworzyliśmy funkcję konstruktora o nazwie <strong class="bold">User</strong>, następnie przy jej pomocy stworzyliśmy dwóch użytkowników. Aby to zrobić korzystamy z operatora <strong class="bold">new</strong>. Działa on w następujący sposób:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Tworzy nowy pusty obiekt, który dziedziczy po <strong class="bold">User.prototype</strong></li>
          <li class="ordered-list__item">Sprawia, że <strong class="bold">this</strong> odnosi się do nowo utworzonego obiektu.</li>
          <li class="ordered-list__item">Ustawia jaki konstruktor został użyty do utworzenia obiektu.</li>
          <li class="ordered-list__item">Na koniec zwraca nam referencję do nowo utworzonego obiektu, który jest zapisywany w naszej zmiennej np. <strong class="bold">user1</strong>.</li>
        </ol>

        <p class="article__paragraph">Adnotacja do punktu nr 3. Dzięki temu możemy sprawdzić czy dany obiekt został stworzony za pomocą danego konstruktora.</p>

        <pre class="article__code">
        <code>
    const user3 = {
      name: 'Marcin',
      age: 29,
      location: 'Cuba'
    };

    console.log(user1 instanceof User); // true
    console.log(user3 instanceof User); // false
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Prototypy i dziedziczenie</h3>

        <p class="article__paragraph">Model obiektowy języka JavaScript bazuje na prototypach. Wszystkie obiekty, które tworzymy powstają na bazie innych obiektów. Umożliwia to dziedziczenie właściwości i metod po innych obiektach. Prototypem nazywamy obiekt po którym są dziedziczone właściwości i metody.</p>

        <p class="article__paragraph">Możemy to sobie wyobrazić jako drzewo, gdzie pniem jest prototyp obiektu <strong class="bold">Object</strong>, to na jego podstawie powstają wszystkie inne obiekty, które tworzą strukturę rozgałęzień niczym w prawdziwym drzewie. Prototyp <strong class="bold">Object</strong> zawiera podstawowe metody, które dziedziczą wszystkie inne obiekty, dzięki którym funkcjonuje nasz system obiektów.</p>

        <pre class="article__code">
        <code>
    console.log(user3)

    //  {name: "Marcin", age: 29, location: "Cuba"}
    //  age: 29
    //  location: "Cuba"
    //  name: "Marcin"
    //  __proto__:
    //      constructor: ƒ Object()
    //      hasOwnProperty: ƒ hasOwnProperty()
    //      isPrototypeOf: ƒ isPrototypeOf()
    //      propertyIsEnumerable: ƒ propertyIsEnumerable()
    //      toLocaleString: ƒ toLocaleString()
    //      toString: ƒ toString()
    //      valueOf: ƒ valueOf()
    //      __defineGetter__: ƒ __defineGetter__()
    //      __defineSetter__: ƒ __defineSetter__()
    //      __lookupGetter__: ƒ __lookupGetter__()
    //      __lookupSetter__: ƒ __lookupSetter__()
    //      get __proto__: ƒ __proto__()
    //      set __proto__: ƒ __proto__()
        </code>
      </pre>

        <p class="article__paragraph">W powyższym przykładzie widzimy, że nasz obiekt user3 ma dostępne metody takie jak np: hasOwnProperty, toString, valueOf itd. Wszystkie te metody zostały odziedziczone po jego prototypie i mamy do nich dostęp z poziomu obiektu user3.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Jak działa dziedziczenie ?</h3>

        <p class="article__paragraph">Chcemy ulepszyć nasz wcześniejszy kod i przenieść metodę greetings wyżej w naszym łańcuchu prototypów. Nie ma potrzeby, żeby każdy z naszych obiektów użytkowników miał swoją własną metodę powitania. Dużo lepszym rozwiązaniem jest utworzenie jednej metody greetings, z której będzie mógł korzystać każdy z użytkowników.</p>

        <pre class="article__code">
        <code>
    function User(name, age, location) {
      this.name = name;
      this.age = age;
      this.location = location;
    }

    User.prototype.greetings = function () {
        console.log(`Witaj ${this.name}, dobrze cię widzieć!`);
      };

    const user1 = new User('Tomasz', 29, 'Poland');
    const user2 = new User('Daniel', 26, 'Poland');

    user1.greetings(); // Witaj Tomasz, dobrze cię widzieć!
    user2.greetings(); // Witaj Daniel, dobrze cię widzieć!

    console.log(user1); // {name: "Tomasz", age: 29, location: "Poland"}
    console.log(Object.getPrototypeOf(user1)); // {greetings: ƒ, constructor: ƒ}
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy powyżej, obiekt <strong class="bold">user1</strong> nie ma własnej metody <strong class="bold">greetings</strong>. Mimo to może ją wywołać. Dzieje się tak ponieważ odziedziczył ją po swoim prototypie. W chwili wywołania tej metody JavaScript sprawdza czy istnieje ona w danym obiekcie. Jeśli nie została znaleziona, następuje przesunięcie się w dół naszej gałęzi do prototypu danego obiektu. Jeśli i tu nie została odnaleziona cały proces się powtarza, aż do momentu znalezienia metody lub dotarcia do pnia naszego drzewa jakim jest obiekt <strong class="bold">Object</strong>. Jeśli i tu nie zostaje znaleziona nasza metoda, zgłaszany jest błąd.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Przesłanianie prototypu</h3>

        <p class="article__paragraph">Ponieważ JS zaczyna sprawdzanie od obiektu, który wywołał daną metodę, możemy utworzyć w nim jego własną metodę o tej samej nazwie i tym samym przesłonić metodę, która już istnieje w łańcuchu prototypów.</p>

        <pre class="article__code">
        <code>
    user1.greetings = function () {
      console.log(`Witaj ponownie ${this.name}, jak się dzisiaj masz ?`);
    };

    user1.greetings(); // Witaj ponownie Tomasz, jak się dzisiaj masz ?
    user2.greetings(); // Witaj Daniel, dobrze cię widzieć!
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, że <strong class="bold">user1</strong> ma swoje własne powitanie, które nie wpłynęło na użytkownika <strong class="bold">user2</strong>.</p>

        <p class="article__paragraph">Jeśli chcemy dodać kilka rzeczy naraz do prototypu, możemy to zrobić. Przypisując obiekt do prototypu. Musimy tylko pamiętać, że w takim przypadku musimy ręcznie dodać właściwości <strong class="bold">constructor</strong> do naszego prototypu.</p>

        <pre class="article__code">
        <code>
    User.prototype = {
      constructor: User, // UWAGA! - zawsze samemu ustawiamy tą właściwość
      greetings: function () {
        console.log(`Witaj ${this.name}, dobrze cię widzieć!`);
      },
      farewell: function () {
        console.log(`Dziękujemy, że nas odwiedziłeś. Do zobaczenia ${this.name}`);
      }
    };
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Prototypy są dynamiczne</h3>

        <p class="article__paragraph">Oznacza to, że wszystkie obiekty utworzone na podstawie danego prototypu, te utworzone przed jak i po modyfikacji prototypu (np. dodanie nowej metody) mają dostęp do wszystkich jego właściwości i metod.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie łańcucha prototypów</h3>

        <p class="article__paragraph">Załóżmy, że chcemy utworzyć następujący łańcuch <strong class="bold">Object -&gt; Human -&gt; User</strong>. Każdy łańcuch budujemy od bardziej ogólnej koncepcji do bardziej szczegółowej. Na początku mamy więc ogólne pojęcie obiektu zdefiniowane przez sam język JS. Później tworzymy obiekt Człowieka, jest to dosyć ogólna kategoria. Następnie podkategorią Człowieka może być Użytkownik.</p>

        <pre class="article__code">
        <code>
    function Human() {}

    Human.prototype = {
      constructor: Human,
      greetings: function () {
        console.log(`Witaj ${this.login}, dobrze cię widzieć!`);
      },
      farewell: function () {
        console.log(`Dziękujemy, że nas odwiedziłeś. Do zobaczenia ${this.login}`);
      }
    };

    function User(login, email) {
      this.login = login;
      this.email = email;
    }

    User.prototype = Object.create(Human.prototype); // Tutaj następuje połączenie prototypów
    User.prototype.constructor = User; // UWAGA! - ustawiamy ręcznie

    const user1 = new User('Tomasz', 'example@gmail.com');
    const human1 = new Human();

    user1.greetings(); // Witaj Tomasz, dobrze cię widzieć!

    console.log(human1 instanceof User); // false
    console.log(user1 instanceof Human); // true
    console.log(user1 instanceof User); // true
        </code>
      </pre>

        <p class="article__paragraph">Przy pomocy <strong class="bold">Object.create()</strong>, tworzymy nowy obiekt, powstaje on na podstawie istniejącego i wybranego przez nas obiektu prototypu.</p>
      </section>
    </article>


    <!-- Article 17 -->


    <article class="article">

      <header id="Klasy" class="article__header">
        <div class="decor">17</div>
        <h2 class="article__title">Klasy</h2>
      </header>

      <p class="article__paragraph">W ES6 wprowadzono nową składnie <strong class="bold">class</strong>, jest to ukłon w stronę osób, które na co dzień programują w językach opartych o klasy jak np. Java. Dzięki temu nie muszą uczyć się bardziej ogólnej koncepcji prototypów i dziedziczenia. Mogą od razu zacząć pisać programy, w oparciu o to co dobrze znają i czego używali na co dzień do tej pory.</p>

      <p class="article__paragraph">Nie zmienia to mechanizmu w jaki działa JavaScript. Wszystko to co poznaliśmy w poprzednim wpisie nadal funkcjonuje i dzieje się pod płaszczykiem nowej składni, którą poznamy dzisiaj.</p>

      <section class="article__section">
        <h3 class="article__section__title">class</h3>

        <p class="article__paragraph">Klasy są specjalnymi funkcjami, które zawierają w swoim ciele konstruktor i metody dodawane do prototypu. Dzięki temu mamy wszystko ładnie pogrupowane. Stwórzmy podobny przykład do tego z poprzedniego wpisu.</p>

        <pre class="article__code">
        <code>
    class Human {
      constructor(name) {
        this.name = name;
      }

      greetings() {
        console.log(`Witaj ${this.login || this.name}, dobrze cię widzieć!`);
      }

      farewell() {
        console.log(`Dziękujemy, że nas odwiedziłeś. Do zobaczenia ${this.login || this.name}.`);
      }
    }

    class User extends Human {
      constructor(name, login, email) {
        super(name);
        this.login = login;
        this.email = email;
      }
    }

    const user1 = new User('Tomasz', 'Tom89', 'TomaszRybacki1989@gmail.com');

    console.log(user1);
    // {name: "Tomasz", login: "Tom89", email: "TomaszRybacki1989@gmail.com"}

    user1.greetings(); // Witaj Tom89, dobrze cię widzieć!
    user1.farewell(); // Dziękujemy, że nas odwiedziłeś. Do zobaczenia Tom89.
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, że nasz kod jest teraz o wiele bardziej czytelny. Nasza funkcja konstruktora jest zawarta wewnątrz klasy. Dodatkowo słowo kluczowe <strong class="bold">extends</strong> wyraźnie pokazuje zależność pomiędzy obiektami. Żeby odwołać się do kodu konstruktora z klasy wyższej i go rozszerzyć, używamy słowa kluczowego <strong class="bold">super()</strong>, w nawiasach podając argumenty z jakimi chcemy go wywołać.</p>

        <p class="article__paragraph">Oczywiście cały mechanizm działania pozostaje taki sam, możemy nadal nadpisać odziedziczone metody i dodać nowe dostępne tylko w instancjach stworzonych przy użyciu naszej klasy <strong class="bold">User</strong>.</p>

        <pre class="article__code">
        <code>
    class User extends Human {
      constructor(name, login, email) {
        super(name);
        this.login = login;
        this.email = email;
      }

      farewell() {
        console.log('Miłego dnia.');
      }

      changeLogin() {
        console.log('Twój login został zmieniony.');
      }
    }

    const user1 = new User('Tomasz', 'Tom89', 'TomaszRybacki1989@gmail.com');
    const human1 = new Human('Daniel');

    user1.greetings(); // Witaj Tom89, dobrze cię widzieć!
    user1.farewell(); // Miłego dnia.
    user1.changeLogin(); // Twój login został zmieniony.

    human1.greetings(); // Witaj Daniel, dobrze cię widzieć!
    human1.farewell(); // Dziękujemy, że nas odwiedziłeś. Do zobaczenia Daniel.
    human1.changeLogin(); // TypeError
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wynoszenie</h3>

        <p class="article__paragraph">Istotną różnicą pomiędzy zwykłą funkcją a klasą jest to, że klasy nie są wynoszone na początek naszego skryptu. Musimy je więc najpierw zadeklarować a dopiero potem ich używać.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Deklaracja klasy i wyrażenie klasy</h3>

        <p class="article__paragraph">Powyższy przykład zawiera deklarację klasy czyli:</p>

        <pre class="article__code">
        <code>
    class Human {}
        </code>
      </pre>

        <p class="article__paragraph">Tak samo jak w przypadku funkcji możemy przypisać ją do zmiennej, tak samo możemy postąpić z klasą. Wyrażenia klas mogą być anonimowe lub nazwane.</p>

        <pre class="article__code">
        <code>
    const Human = class {};

    const Human = class Human {};
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Metody statyczne</h3>

        <p class="article__paragraph">Są to metody dostępne tylko z poziomu klasy. Nie można się do nich odwołać za pomocą instancji utworzonych przy pomocy tej klasy. Służą przeważnie do tworzenia metod pomocniczych.</p>

        <pre class="article__code">
        <code>
    class Human {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }

      static youngerHuman(a, b) {
        if (a.age &gt; b.age) {
          return b.name;
        }
        return a.name;
      }
    }

    class User extends Human {
      constructor(name, age, login, email) {
        super(name, age);
        this.login = login;
        this.email = email;
      }
    }

    const user1 = new User('Tomasz', 29, 'Tom89', 'TomaszRybacki1989@gmail.com');
    const user2 = new User('Marcin', 32, 'Martin86', 'example@gmail.com');

    const human1 = new Human('Daniel', 26);

    user1.youngerHuman(); // TypeError
    human1.youngerHuman(); // TypeError

    console.log(Human.youngerHuman(user1, user2)); // Tomasz
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 18 -->


    <article class="article">

      <header id="Obiekty_opakowujace" class="article__header">
        <div class="decor">18</div>
        <h2 class="article__title">Obiekty opakowujące</h2>
      </header>

      <p class="article__paragraph">Teraz gdy poznałeś obiekty i typy proste w JavaScript. Będziesz mógł z łatwością zrozumieć co się dzieje w poniższej sytuacji:</p>

      <pre class="article__code">
        <code>
    let myName = 'Tomasz';

    console.log(myName.indexOf('s')); // 4
    console.log(typeof myName); // string
        </code>
      </pre>

      <p class="article__paragraph">Patrząc na powyższy kod, możesz podrapać się w głowę i pomyśleć. Co jest grane ? Przecież przy pomocy notacji z kropką odwołujemy się do metody obiektu. Ale w następnej linijce kodu widzimy wyraźnie, że zmienna <strong class="bold">myName</strong> przechowuje wartość typu prostego.</p>

      <section class="article__section">
        <h3 class="article__section__title">Opakowanie przez silnik JS</h3>

        <p class="article__paragraph">Rozwiązanie tej zagadki jest proste. Oto co się wydarzyło za kurtyną:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Za każdym razem gdy chcemy wywołać metodę na wartości typu prostego zostaje ona „po cichu” opakowana przy pomocy obiektu.</li>
          <li class="ordered-list__item">Następnie zostaje wywołana nasza metoda.</li>
          <li class="ordered-list__item">Gdy tylko otrzymamy wynik jej działania nasz obiekt opakowujący jest niszczony.</li>
        </ol>

        <p class="article__paragraph">Teraz powyższy przykład jest dla nas zrozumiały i logiczny. Otrzymane wartości są dokładnie tym czego się spodziewaliśmy. Opakowaniu ulegają wartości proste typu: string, number i boolean.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Własnoręczne opakowanie</h3>

        <p class="article__paragraph">To co zostało zrobione „po cichu” przez silnik JS. Możemy również zrobić samemu przy użyciu konstruktora.</p>

        <pre class="article__code">
        <code>
    let myName = new String('Tomasz');

    console.log(myName.indexOf('s')); // 4

    console.log(myName); // {"Tomasz"}
    console.log(typeof myName); // object

    let myAge = new Number(29);

    console.log(myAge); // {29}
    console.log(typeof myAge); // object

    let codingIsCool = new Boolean(true);

    console.log(codingIsCool); // {true}
    console.log(typeof codingIsCool); // object
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy nasza wartość pozostaje cały czas zapakowana i sprawdzenie jej typu zwraca object. Możemy też ręcznie rozpakować naszą wartość wykorzystując mechanizm konwersji typów.</p>

        <pre class="article__code">
        <code>
    myName = myName + '';

    console.log(myName); // Tomasz
    console.log(typeof myName); // string

    myAge = myAge + 0;

    console.log(myAge); // 29
    console.log(typeof myAge); // number

    codingIsCool = !!codingIsCool;

    console.log(codingIsCool); // true
    console.log(typeof codingIsCool); // boolean
        </code>
      </pre>

        <p class="article__paragraph">Teraz gdy wiemy na czym polega opakowywanie typów prostych. Zapamiętajmy żeby nigdy nie robić tego samemu. Zawsze twórz wartości typu prostego w postaci literału!</p>
      </section>

    </article>


    <!-- Article 19 -->


    <article class="article">

      <header id="Obiekty_wbudowane" class="article__header">
        <div class="decor">19</div>
        <h2 class="article__title">Obiekty wbudowane</h2>
      </header>

      <p class="article__paragraph">W JavaScript mamy dostęp do wielu już utworzonych obiektów, które pozwalają nam na wykonywanie różnych operacji. Możemy je podzielić na trzy grupy:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Obiekty opakowujące. Pozwalają nam na zarządzanie różnymi typami danych. Są to: <strong class="bold">Array, Number, Boolean, Symbol, Object, Array, Function, Map, Set, JSON.</strong></li>
        <li class="ordered-list__item">Obiekty użytkowe. Pozwalają nam wykonywać różne operacje. Są to: <strong class="bold">Math, Date, RegExp.</strong></li>
        <li class="ordered-list__item">Obiekty błędów. Służą do zarządzania powstałymi błędami. Są to: <strong class="bold">Error, EvalError, InternalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError.</strong></li>
      </ol>

      <p class="article__paragraph">Jak widzisz jest tego całkiem sporo, część z tych obiektów już poznałeś. Dzisiaj chcę się skupić na obiektach z drugiej grupy.</p>

      <section class="article__section">
        <h3 class="article__section__title">Math</h3>

        <p class="article__paragraph">Obiekt Math służy do przeprowadzania różnych działań matematycznych. Jest dosyć niezwykły, w przeciwieństwie do pozostałych nie jest funkcją konstruktora. Wszystkie jego właściwości i metody są statyczne. Odwołujemy się do nich przez obiekt Math. Przyjrzyjmy się jego najczęściej używanym właściwościom i metodom.</p>

        <pre class="article__code">
        <code>
    Właściwości:

    console.log(Math.PI); // 3.141592
    // zwraca wartość liczby pi

    console.log(Math.SQRT2); // 1.414213
    // zwraca pierwiastek kwadratowy z 2

    Metody:

    console.log(Math.abs(-6)) // 6
    // zwraca wartość absolutną liczby

    console.log(Math.cbrt(27)) // 3
    // zwraca pierwiastek sześcienny z liczby

    console.log(Math.sqrt(16)) // 4
    // zwraca pierwiastek kwadratowy z liczby

    console.log(Math.pow(5, 2)) // 25
    // zwraca liczbę podniesioną do potęgi

    console.log(Math.ceil(5.2)) // 6
    // zaokrągla liczbę w górę

    console.log(Math.floor(5.6)) // 5
    // zaokrągla liczbę w dół

    console.log(Math.round(5.5)) // 6
    // zaokrągla liczbę do najbliższej wartości całkowitej

    console.log(Math.random()) // 0.634532
    // generuje losową liczbę z przedziału od 0 do 1 (nie zawiera jedynki)

    console.log(Math.min(45, 23)); // 23
    // zwraca najmniejszą z podanych liczb

    console.log(Math.max(45, 23)); // 45
    // zwraca największą z podanych liczb
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Date</h3>

        <p class="article__paragraph">Obiekt date pozwala nam na pracę z czasem. Oparty jest na czasie uniksowym, czyli wartości dodatnie oznaczają liczbę milisekund jakie upłynęły od początku roku 1970. Nie uwzględnia jednak milisekund przestępnych. Sposoby tworzenia obiektu date:</p>

        <pre class="article__code">
        <code>
    // pobieranie aktualnej daty z urządzenia użytkownika

    let now = new Date();
    console.log(now);
    // Tue Jul 31 2018 12:32:52 GMT+0200

    // ustawianie wybranej daty

    let myBirthday = new Date(1989, 4, 24);
    console.log(myBirthday);
    // Wed May 24 1989 00:00:00 GMT+0200

    // ustawianie daty na podstawie liczby milisekund jakie upłyneły od początku 1970
    let unixEpoch = new Date(6000);
    console.log(unixEpoch);
    // Thu Jan 01 1970 01:00:06 GMT+0100
        </code>
      </pre>

        <p class="article__paragraph">Pamiętamy, że miesiące są numerowane od zera. Możemy ustawić datę z dokładnością do milisekundy, korzystając z poniższej składni:</p>

        <span class="article__command">new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds);</span>

        <p class="article__paragraph">Obiekt Date zawiera całą listę metod służących do pobierania i ustawiania części składowych daty. Kompletną listę tych metod znajdziesz tutaj. Polecam Ci samodzielne pogłębianie wiedzy z materiałów MDN (mozilla developer network). Prowadzona przez nich dokumentacja jest bardzo solidna i stanowi doskonałe źródło wiedzy na temat JavaScript.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">RegExp</h3>

        <p class="article__paragraph">Wyrażenia regularne to wzorce stosowane do dopasowywania kombinacji znaków w łańcuchach. W JavaScript wyrażenia regularne są również obiektami. Zapisujemy je pomiędzy ukośnikami np: /^[a-zA-z]\w*\w$/</p>

        <h4 class="article__section__subtitle">Metody obiektu RegExp</h4>

        <p class="article__paragraph"><strong class="bold">exec</strong> – wyszukuje dopasowanie w łańcuchu. Zwraca dopasowany fragment lub <strong class="bold">null</strong> gdy nic nie znaleziono.</p>

        <p class="article__paragraph"><strong class="bold">test</strong> – sprawdza dopasowanie w łańcuchu . Zwraca <strong class="bold">true</strong> gdy występuje lub <strong class="bold">false</strong> gdy nie występuje.</p>

        <h4 class="article__section__subtitle">Metody obiektu String</h4>

        <p class="article__paragraph"><strong class="bold">match</strong> – wyszukuje dopasowanie w łańcuchu. Zwraca tablicę dopasowanych fragmentów lub <strong class="bold">null</strong> gdy nic nie znaleziono.</p>

        <p class="article__paragraph"><strong class="bold">search</strong> – sprawdza dopasowanie w łańcuchu. Zwraca <strong class="bold">index</strong> dopasowania lub <strong class="bold">-1</strong> gdy nic nie znajdzie.</p>

        <p class="article__paragraph"><strong class="bold">replace</strong> – sprawdza dopasowanie w łańcuchu i zastępuje dopasowane fragmenty nowymi podanymi łańcuchami.</p>

        <p class="article__paragraph"><strong class="bold">split</strong> – wykorzystuje wyrażenie regularne lub łańcuch znaków do podzielenia łańcucha na tablicę łańcuchów powstałych w wyniku podziału.</p>

        <h4 class="article__section__subtitle">Oznaczenia</h4>

        <p class="article__paragraph">
          ^ – dopasowuje pierwszy znak w łańcuchu<br> $ – dopasowuje ostatni znak w łańcuchu<br> * – dopasowuje poprzedzający znak 0 powtórzeń lub więcej, ekwiwalent do {0,}<br> + – dopasowuje poprzedzające wyrażenie 1 lub więcej razy, ekwiwalent do {1,}<br> ? – dopasowuje poprzedzające wyrażenie 0 lub 1 raz, ekwiwalent do {0,1}<br> . – dopasowuje każdy (dowolny) znak za wyjątkiem znaku od nowej lini
        </p>

        <p class="article__paragraph">
          (x) – dopasowuje x i zapamiętuje dopasowanie, później możemy je wykorzystać i np. zamieniać je miejscami za pomocą $1, $2<br> (?:x) – dopasowuje x i nie zapamiętuje dopasowania, pozwala grupować znaki wewnątrz wyrażenia regularnego<br> x(?=y) – dopasowuje x tylko gdy jest po nim y<br> x(?!y) – dopasowuje x gdy nie następuje po nim y<br> x|y – dopasowuje x lub y
        </p>

        <p class="article__paragraph">
          {n} – dopasowuje dokładnie ilość poprzedzających wyrażeń<br> {n,} – dopasowuje przynajmniej n wystąpień poprzedzających wyrażeń<br> {n,m} – dopasowuje ilość wystąpień wyrażenia z przedziału od n do m<br> [xyz] – dopasowuje dowolny ze znaków z zestawu, zakres podajemy przy użyciu – np:/[a-z]/<br> [^xyz] – dopasowuje wszystko co nie należy do zestawu<br>
        </p>

        <p class="article__paragraph">
          \d – dopasowuję cyfrę, ekwiwalent do [0-9]<br> \D – dopasowuje nie-cyfrę, ekwiwalent do [^0-9]<br> \s – dopasowuje biały znak np: spacje, tabulator<br> \S – dopasowuje pojedyńczy nie biały znak<br> \t – dopasowuje tabulator<br> \w – dopasowuje alfabetyczno-numeryczny znak z uwzględnieniem podkreślenia, ekwiwalent do [A-Za-z0-9_]<br> \W – dopasowuje nie alfabetyczno-numeryczny znak<br> \b – granica słowa, dopasowuje się do zmiany znaku z \w na \W lub na odwrót
        </p>

        <p class="article__paragraph">
          \xhh – dopasowuje znak z kodem hh (dwie cyfry szesnastkowe)<br> \uhhhh – dopasowuje znak z kodem hhhh ( cztery cyfry szesnastkowe)<br> \u{hhhh} – tylko gdy flaga u jest włączona. Dopasowuje znak z kodem Unicode o wartości hhhh
        </p>

        <h4 class="article__section__subtitle">Flagi</h4>

        <p class="article__paragraph">Flagi możemy dodać na końcu wyrażenia regularnego żeby zmodyfikować sposób w jaki działa np. <strong class="bold">/wyrażenieRegularne/flaga</strong></p>

        <p class="article__paragraph">
          g – nie zatrzymuje wyszukiwania po pierwszym dopasowaniu i szuka dalej<br> i – nie rozróżnia wielkości znaków np. a = A<br> m – wyszukiwanie wielowierszowe (^ i $) działają dla każdej nowej linii<br> u – traktuje wyrażenie jako znaki Unicode<br> y – sprawdza tylko wskazaną pozycję pod danym indexem (RegExp.lastIndex = index)
        </p>

        <h4 class="article__section__subtitle">Znaki specjalne</h4>

        <p class="article__paragraph">Wszystkie znaki z tej listy należy poprzedzić ukośnikiem wstecznym \ żeby wykorzystać je jako zwykłe znaki w wyrażeniu regularnym:<strong class="bold"> \ ^ $ * + ? . ( ) | { } [ ]</strong></p>

        <p class="article__paragraph">Do wyrażeń regularnych możemy też wstawiać zmienne z wykorzystaniem „Template strings” nie używamy wtedy ukośników // i całe wyrażenie zapisujemy w „ np. `(?:[0\\D]*(\\d+)\\D*){${n}}`, gdzie n jest zmienną.</p>

        <p class="article__paragraph">Wewnątrz wyrażenia regularnego można korzystać z wcześniej zapamiętanych dopasowań w nawiasach () np. /([a-z]+)[^a-z]+\1\b/gi, gdzie \1 oznacza wcześniej dopasowane słowo z nawiasów ([a-z]+)</p>
      </section>
    </article>


    <!-- Article 20 -->


    <article class="article">

      <header id="DOM" class="article__header">
        <div class="decor">20</div>
        <h2 class="article__title">DOM</h2>
      </header>

      <p class="article__paragraph">DOM to skrót od Document Object Model, czyli modelu obiektowego dokumentu. Nie jest częścią języka JavaScript, tylko API dla dokumentów HTML i XML. API to skrót od application programming interface, czyli interfejsu programowania aplikacji.</p>

      <p class="article__paragraph">Wyjaśnijmy sobie, co kryje się pod tymi pojęciami. API jest ogólną koncepcją określającą w jaki sposób różne programy i urządzenia mają się komunikować między sobą. Natomiast DOM jest implementacją tego sposobu komunikacji dla naszych dokumentów HTML. Określa w jaki sposób wygląda struktura dokumentu, tak zwane drzewo DOM, oraz w jaki sposób nasze skrypty pisane w JavaScript mogą oddziaływać z tą strukturą.</p>

      <p class="article__paragraph">Za każdym razem gdy wczytamy stronę internetową nasza przeglądarka, tworzy jej odwzorowanie w postaci drzewa DOM dodanego do obiektu globalnego <strong class="bold">window</strong>. W obiekcie <strong class="bold">window.document</strong> znajdziemy całą strukturę tagów naszego dokumentu HTML.</p>

      <section class="article__section">
        <h3 class="article__section__title">Drzewo DOM</h3>

        <p class="article__paragraph">Składa się z węzłów. Węzły te mogą zawierać kolejne pod węzły. Głównym elementem jest element <strong class="bold">&lt;html&gt;</strong> zwany korzeniem dokumentu. To od niego rozchodzą się kolejne rozgałęzienia. Przyjmijmy, że mamy następujący dokument html:</p>

        <pre class="article__code">
        <code>
    &lt;!DOCTYPE html&gt;
    &lt;html lang="pl"&gt;
    &lt;head&gt;
      &lt;title&gt;DOM&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;header&gt;
        &lt;nav&gt;&lt;/nav&gt;
      &lt;/header&gt;
      &lt;main&gt;
        &lt;h1&gt;Title&lt;/h1&gt;
        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;
      &lt;/main&gt;
      &lt;footer&gt;
        &lt;a href="#"&gt;Link&lt;/a&gt;
      &lt;/footer&gt;
      &lt;script src="../scripts/code.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
        </code>
      </pre>

        <p class="article__paragraph">Graficznie możemy go rozpisać w postaci następującego drzewa DOM:</p>

        <img class="article__img" src="img/DOM%20tree.jpg" alt="DOM tree">

        <p class="article__paragraph">Gdy otworzymy narzędzia developerskie Chrome (F12) w zakładce Elements, zobaczymy uproszczony model naszego drzewa DOM, który nie zawiera pustych węzłów tekstowych oznaczających nową linię. Które widzimy w powyższym rozpisaniu.</p>

        <p class="article__paragraph">Nasze tagi HTML stają się węzłami elementów i tworzą strukturę naszego drzewa. Możemy myśleć o nich jak o rodzinie. Każdy węzeł ma swojego rodzica (czyli węzeł, który go zawiera), ma też swoje dzieci (węzły o jeden poziom niżej), oraz rodzeństwo (węzły na tym samym poziomie co on).</p>

        <p class="article__paragraph">Na przykładzie węzła <strong class="bold">&lt;main&gt;</strong>. Węzły <strong class="bold">&lt;header&gt;</strong> i <strong class="bold">&lt;footer&gt;</strong> są jego rodzeństwem. Węzeł <strong class="bold">&lt;body&gt;</strong> jest jego rodzicem. Natomiast węzły <strong class="bold">&lt;h1&gt;</strong> i <strong class="bold">&lt;p&gt;</strong> są jego dziećmi. W tym przykładzie rozpatrujemy tylko węzły elementów, pozostałe typy węzłów pomijam. W sumie mamy 12 typów węzłów:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Element node</li>
          <li class="ordered-list__item">Attribute node</li>
          <li class="ordered-list__item">Text node</li>
          <li class="ordered-list__item">CData section node</li>
          <li class="ordered-list__item">Entity Reference node</li>
          <li class="ordered-list__item">Entity node</li>
          <li class="ordered-list__item">Processing Instruction node</li>
          <li class="ordered-list__item">Comment node</li>
          <li class="ordered-list__item">Document node</li>
          <li class="ordered-list__item">Document Type node</li>
          <li class="ordered-list__item">Document Fragment node</li>
          <li class="ordered-list__item">Notation node</li>
        </ol>

        <p class="article__paragraph">Większość z nich, nas nie interesuje i podaję je jedynie jako ciekawostkę.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Odwoływanie się do elementów</h3>

        <p class="article__paragraph">Oto lista dostępnych metod, służących do pobierania elementów z naszego drzewa DOM:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">document.getElementById(<strong class="bold">'id'</strong>)</li>
          <li class="ordered-list__item">document.getElementsByClassName(<strong class="bold">'klasa'</strong>)</li>
          <li class="ordered-list__item">document.getElementsByTagName(<strong class="bold">'tag'</strong>)</li>
          <li class="ordered-list__item">document.querySelector(<strong class="bold">'selektor css'</strong>)</li>
          <li class="ordered-list__item">document.querySelectorAll(<strong class="bold">'selektor css'</strong>)</li>
        </ol>

        <pre class="article__code">
        <code>
    // pobiera element o podanym id

    const h1Element = document.getElementById('title');
    console.log(h1Element); // &lt;h1 id="title"&gt;Title&lt;/h1&gt;

    // pobiera kolekcję elementów o podanej klasie

    const paragraphElements = document.getElementsByClassName('paragraph');
    console.log(paragraphElements); // HTMLCollection(2)[p.paragraph, p.paragraph]

    // pobiera kolekcję elementów o danej nazwie tagu HTML

    const headerElement = document.getElementsByTagName('header');
    console.log(headerElement); // HTMLCollection[header]

    // pobiera pierwszy element wewnątrz dokumentu, który pasuje do podanego selektora

    const linkElement = document.querySelector('a[href="#title"]');
    console.log(linkElement); // &lt;a href="#title"&gt;Link&lt;/a&gt;

    const h1Element2 = document.querySelector('#title');
    console.log(h1Element2); // &lt;h1 id="title"&gt;Title&lt;/h1&gt;

    // pobiera wszystkie elementy wewnątrz dokumentu, który pasuje do podanego selektora

    const paragraphElements2 = document.querySelectorAll('.paragraph');
    console.log(paragraphElements2); // NodeList(2)[p.paragraph, p.paragraph]
        </code>
      </pre>

        <p class="article__paragraph">Widzimy powyżej, że metoda <strong class="bold">querySelectorAll</strong> zwraca listę węzłów, natomiast wcześniejsze metody jak <strong class="bold">getElementsByClassName</strong> i <strong class="bold">getElementsByTagName</strong> zwracały kolekcję elementów. Na czym polega różnica pomiędzy nimi ?</p>

        <h4 class="article__section__subtitle">Kolekcja Elementów (HTMLCollection)</h4>

        <p class="article__paragraph">Zawiera tylko listę elementów (element node). Jest „żywa” co oznacza, że jej zawartość jest aktualizowana na bieżąco gdy w dokumencie pojawiają się nowe elementy lub istniejące są usuwane.</p>

        <h4 class="article__section__subtitle">Lista Węzłów (NodeList)</h4>

        <p class="article__paragraph">Może zawierać dowolne węzły (element node, text node, comment node itp.) Ilość jej elementów jest zazwyczaj statyczna (wyjątkiem jest metoda <strong class="bold">childNodes</strong>, która zwraca „żywą” listę węzłów), i wynosi dokładnie tyle ile ich było na stronie w momencie wywołania naszej metody, która zwróciła nam listę węzłów.</p>

        <pre class="article__code">
        <code>
    // tworzymy nowy paragraf

    const newParagraph = document.createElement('p');

    // dodajemy mu klasę paragraph

    newParagraph.classList.add('paragraph');

    // dodajemy tekst do naszego paragrafu

    newParagraph.textContent = 'Jestem tekstem zawartym w nowym paragrafie.';

    // podczepiamy stworzony element do body naszego dokumentu

    document.body.appendChild(newParagraph);

    console.log(paragraphElements.length); // 3
    console.log(paragraphElements2.length); // 2
        </code>
      </pre>

        <p class="article__paragraph">W powyższym przykładzie widzimy, że nasza kolekcja elementów przechowywana w zmiennej <strong class="bold">paragraphElements</strong> została powiększona o jeden. Podczas gdy wartość zmiennej <strong class="bold">paragraphElements2</strong> nie uległa zmianie.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Poruszanie się po DOM</h3>

        <p class="article__paragraph">Nie musimy za każdym razem pobierać nowego elementu za pomocą identyfikatora, klasy, nazwy tagu lub selektora CSS. Możemy pobrać tylko jeden element i za jego pomocą przechodzić do innych elementów.</p>

        <pre class="article__code">
        <code>
    const bodyElem = document.getElementsByTagName('body')[0];
    console.log(bodyElem); // &lt;body&gt;...&lt;/body&gt;

    // pobiera pierwszy węzeł zawarty w tym elemencie
    console.log(bodyElem.firstChild); // #text

    // pobiera pierwszy element zawarty w tym elemencie
    console.log(bodyElem.firstElementChild); // &lt;header&gt;...&lt;/header&gt;

    // pobiera ostatni węzeł zawarty w tym elemencie
    console.log(bodyElem.lastChild); // &lt;script src="scripts/code.js"&gt;&lt;/script&gt;

    // pobiera ostatni element zawarty w tym elemencie
    console.log(bodyElem.lastElementChild); // &lt;script src="scripts/code.js"&gt;&lt;/script&gt;

    // pobiera kolekcję elementów zawartych w tym elemencie
    console.log(bodyElem.children);
    // HTMLCollection(4)[header, main, footer, script]

    // pobiera listę węzłów zawartych w tym elemencie
    console.log(bodyElem.childNodes);
    // NodeList(8)[text, header, text, main, text, footer, text, script]

    const mainElem = document.getElementsByTagName('main')[0];
    console.log(mainElem); // &lt;main&gt;...&lt;/main&gt;

    // pobiera wcześniejszy węzeł na tym samym poziomie co dany element
    console.log(mainElem.previousSibling); // #text

    // pobiera wcześniejszy element na tym samym poziomie co dany element
    console.log(mainElem.previousElementSibling); // &lt;header&gt;...&lt;/header&gt;

    // pobiera następny węzeł na tym samym poziomie co dany element
    console.log(mainElem.nextSibling); // #text

    // pobiera następny element na tym samym poziomie co dany element
    console.log(mainElem.nextElementSibling); // &lt;footer&gt;...&lt;/footer&gt;

    // pobiera węzeł rodzica
    console.log(mainElem.parentNode); // &lt;body&gt;...&lt;/body&gt;

    // pobiera element rodzica
    console.log(mainElem.parentElement); // &lt;body&gt;...&lt;/body&gt;
        </code>
      </pre>

        <p class="article__paragraph">W powyższym przykładzie możesz zauważyć, że pobieramy element przy użyciu nazwy tagu <strong class="bold">document.getElementsByTagName('body')[0]</strong>. Ponieważ metoda ta zwróci nam kolekcie elementów HTML, zawierającą tylko jeden element. Pobieramy ten element przy pomocy nawiasów kwadratowych tak samo jak ze zwykłej tablicy (array). Należy jednak pamiętać, o tym, że pomimo wielu podobieństw kolekcje elementów i listy węzłów, nie są tablicami JavaScript! Brakuje im kilku metod i właściwości typowych dla tablic. Z tego też powodu możemy je przekształcić w standardowe tablice przy pomocy metody <strong class="bold">Array.from()</strong> lub w przypadku pętli po ich elementach ograniczyć się do stosowania zwyczajnej pętli <strong class="bold">for</strong>, która dla nich działa.</p>

        <p class="article__paragraph">Kolejną rzeczą, którą zauważyłeś jest to, że mamy dostępne bliźniacze metody, z których jedna operuje na wszystkich węzłach DOM, a druga zawęża swoje działanie tylko do węzłów, które są węzłami elementów.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Usuwanie elementów</h3>

        <p class="article__paragraph">Możemy usuwać „dzieci” elementów przy pomocy metody <strong class="bold">removeChild()</strong>, która zwraca usunięty węzeł. Węzeł ten nie jest całkowicie niszczony i możemy go ponownie podczepić do dowolnego elementu.</p>

        <pre class="article__code">
        <code>
    const mainElem = document.getElementsByTagName('main')[0];
    mainElem.removeChild(mainElem.lastElementChild);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie i dodawanie nowych elementów</h3>

        <p class="article__paragraph">Elementy tworzymy przy pomocy metody <strong class="bold">document.createElement()</strong>, utworzony w ten sposób element nie jest jeszcze widoczny na naszej stronie. Musimy go jeszcze podczepić do naszego drzewa DOM, przy pomocy jednej z dwóch metod: <strong class="bold">appendChild()</strong> lub <strong class="bold">insertBefore()</strong>.</p>

        <pre class="article__code">
        <code>
    const mainElem = document.querySelector('main');
    console.log(mainElem);

    const newTitleElem = document.createElement('h2');
    newTitleElem.textContent = 'Nowy podtytuł dodany za pomocą JavaScript';

    const newParagraphElem = document.createElement('p');
    const newTextNode = document.createTextNode('Nowy tekst paragrafu dodany za pomocą JavaScript.');

    mainElem.appendChild(newParagraphElem);
    newParagraphElem.appendChild(newTextNode);

    mainElem.insertBefore(newTitleElem, mainElem.children[3]);
        </code>
      </pre>

        <p class="article__paragraph">Metoda <strong class="bold">appendChild(nowyElement)</strong> wstawia element na koniec listy dzieci określonego elementu. Natomiast metoda <strong class="bold">elementRodzic.insertBefore(nowyElement, wybranyElement)</strong> wstawia <strong class="bold">nowyelement</strong> przed <strong class="bold">wybranyelement</strong>.</p>
      </section>
    </article>


    <!-- Article 21 -->


    <article class="article">

      <header id="Zdarzenia" class="article__header">
        <div class="decor">21</div>
        <h2 class="article__title">Zdarzenia</h2>
      </header>

      <p class="article__paragraph">Dzięki zdarzeniom możemy zapewnić interaktywność naszej strony i polepszyć wrażenia użytkowników z niej korzystających. Przykładami zdarzeń są: kliknięcie przycisku, skrolowanie treści strony, zmiana rozmiaru okna przeglądarki. Istnieje długa lista zdarzeń jakie mogą zajść w naszej przeglądarce internetowej. Wszystkie one pozwalają nam połączyć kawałek kodu, który chcemy wykonać w odpowiedzi na zajście konkretnego zdarzenia.</p>

      <section class="article__section">
        <h3 class="article__section__title">Atrybuty HTML umieszczane inline</h3>

        <p class="article__paragraph">Polegają na umieszczaniu kodu JS wewnątrz pliku HTML poprzez zastosowanie specjalnych atrybutów HTML. Należy unikać ich używania, ale warto wiedzieć, że istnieje taki sposób, ponieważ możemy się z nim zetknąć.</p>

        <pre class="article__code">
        <code>
    &lt;button onclick="logMessage()"&gt;Nie klikaj mnie&lt;/button&gt;
    &lt;script&gt;
    function logMessage() {
      console.log('Wiedziałem, że się nie posłuchasz.')
    }
    &lt;/script&gt;
        </code>
      </pre>

        <h4 class="article__section__subtitle">Dlaczego powyższy sposób obsługi zdarzeń jest zły ?</h4>

        <p class="article__paragraph">Ponieważ miesza dwie warstwy ze sobą, HTML odpowiedzialny za treść i JS odpowiedzialny za zachowanie. Przez co jest mniej czytelny i trudniejszy w utrzymaniu. Gdybyś miał dziesiątki przycisków na swojej stronie i musiał ręcznie dodawać do nich atrybuty, szybko zauważył byś jak kiepskim rozwiązaniem jest powyższa praktyka.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wydarzenia jako właściwości</h3>

        <p class="article__paragraph">To kolejny ze sposobów obsługi zdarzeń w naszej przeglądarce. Każdy element HTML posiada listę właściwości, na której możemy zobaczyć długą listę możliwych zdarzeń dla tego elementu, zaczynających się od przedrostka <strong class="bold">on</strong>, po której mamy nazwę wydarzenia oraz wartość <strong class="bold">null</strong>, np: <strong class="bold">onclick: null</strong>.</p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('Kliknełeś w przycisk!');
    }

    firstButton.onclick = logMessage;

    console.dir(firstButton); // onclick: ƒ logMessage()
        </code>
      </pre>

        <p class="article__paragraph">W powyższy sposób możemy przypisać naszą funkcję do wybranego elementu. Gdy tylko zajdzie zdarzenie wskazanego typu dla tego elementu, nasza funkcja zostanie wywołana. Minusem tego rozwiązania jest fakt, że możemy przypisać tylko pojedynczą funkcję do każdego ze zdarzeń.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Słuchacz zdarzeń</h3>

        <p class="article__paragraph">To najnowsza i najlepsza z dostępnych możliwości. Pozwala nam na dodanie „słuchacza” do elementu, który będzie nasłuchiwał wybranego zdarzenia i gdy tylko zarejestruje wystąpienie danego zdarzenia odpali podaną funkcję.</p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('Kliknełeś w przycisk!');
    }

    firstButton.addEventListener('click', logMessage);
        </code>
      </pre>

        <p class="article__paragraph">Oto jakie korzyści zapewnia nam ten sposób:</p>

        <p class="article__paragraph">1. Pozwala na dodanie wielu różnych funkcji do tego samego zdarzenia.</p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('Kliknełeś w przycisk!');
    }

    function sayHello() {
      console.log('Dobrze Cię widzieć.');
    }

    firstButton.addEventListener('click', logMessage);
    firstButton.addEventListener('click', sayHello);
        </code>
      </pre>

        <p class="article__paragraph">2. Pozwala na usuwanie nasłuchiwaczy zdarzeń przez zastosowanie metody <strong class="bold">removeEventListener()</strong></p>

        <pre class="article__code">
        <code>
    const firstButton = document.querySelector('.button');

    function logMessage() {
      console.log('Kliknełeś w przycisk!');
    }

    function sayHello() {
      console.log('Dobrze Cię widzieć.');
    }

    firstButton.addEventListener('click', logMessage);
    firstButton.addEventListener('click', sayHello);

    // wywołujemy zdarzenie z poziomu kodu, działa tak jakby użytkownik klikną w nasz przycisk

    firstButton.click();
    // Kliknełeś w przycisk!
    // Dobrze Cię widzieć.

    firstButton.removeEventListener('click', sayHello);

    firstButton.click();
    // Kliknełeś w przycisk!
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Propagacja zdarzeń</h3>

        <p class="article__paragraph">Wiemy, że struktura dokumentu HTML jest hierarchiczna i tworzy drzewo, w którym jedne elementy zawierają inne elementy. Gdy na naszej stronie wystąpi zdarzenie np. kliknięcia na dany element. To wystąpienie tego zdarzenia rozchodzi się niczym fala po wodzie również po pozostałych elementach w dokumencie.</p>

        <p class="article__paragraph">Załóżmy, że mamy następujący układ elementów HTML:</p>

        <pre class="article__code">
        <code>
    &lt;body&gt;
      &lt;div class="container"&gt;
        &lt;button class="button"&gt;Kliknji mnie!&lt;/button&gt;
      &lt;/div&gt;
    &lt;/body&gt;
        </code>
      </pre>

        <p class="article__paragraph">Gdy klikniemy element następują dwie fazy rozchodzenia się tego wydarzenia. Najpierw występuje <strong class="bold">przechwytywanie</strong> zdarzenia a następnie <strong class="bold">bąbelkowanie zdarzenia</strong>.</p>

        <p class="article__paragraph"><strong class="bold">przechwytywanie zdarzenia</strong> – przesuwamy się w dół naszego drzewa elementów i sprawdzamy czy dany element nasłuchuje danego zdarzenia w tej fazie. Jeśli tak, odpalamy daną funkcję, która obsługuje wystąpienie tego zdarzenia, a następnie przechodzimy do kolejnego elementu itd.</p>

        <p class="article__paragraph">body -&gt; div -&gt; button</p>

        <p class="article__paragraph"><strong class="bold">bąbelkowanie zdarzenia</strong> – przesuwamy się w górę naszego drzewa elementów sprawdzamy czy dany element nasłuchuje danego zdarzenia w tej fazie. Jeśli tak, odpalamy daną funkcję, która obsługuje wystąpienie tego zdarzenia, a następnie przechodzimy do kolejnego elementu itd.</p>

        <p class="article__paragraph">button -&gt; div -&gt; body</p>

        <pre class="article__code">
        <code>
    const firstContainer = document.querySelector('.container');
    const firstButton = document.querySelector('.button');

    function buttonClick() {
      console.log('Przycisk został kliknięty.');
    }

    function containerClick() {
      console.log('Div został kliknięty.');
    }

    firstContainer.addEventListener('click', containerClick);
    firstButton.addEventListener('click', buttonClick);

    firstButton.click();
    // Przycisk został kliknięty.
    // Div został kliknięty
        </code>
      </pre>

        <p class="article__paragraph">Widzimy w powyższym przykładzie, że obie nasze funkcje zostały wywołane. Pomimo, że kliknęliśmy tylko w przycisk, to zdarzenie to rozeszło się do elementu rodzica, który również nasłuchiwał zdarzenia typu <strong class="bold">click</strong>.</p>

        <p class="article__paragraph">Metoda <strong class="bold">addEventListener()</strong>, może również przyjmować trzeci parametr w postaci wartości <strong class="bold">true</strong>. Domyślnie jest on ustawiony na wartość <strong class="bold">false</strong>. Parametr ten oznacza w której fazie rozchodzenia się zdarzenia ma nastąpić jego przechwycenie. Gdy jego wartość wynosi <strong class="bold">true</strong>, odpalenie zdarzenia następuje w fazie przechwytywania zdarzenia, a dla wartości <strong class="bold">false</strong> jest to faza bąbelkowania zdarzenia. Możemy w ten sposób odwrócić kolejność w jakiej zostaną wywołane nasze funkcje.</p>

        <pre class="article__code">
        <code>
    firstContainer.addEventListener('click', containerClick, true);
    firstButton.addEventListener('click', buttonClick, false);

    firstButton.click();

    // Div został kliknięty.
    // Przycisk został kliknięty.
        </code>
      </pre>

        <p class="article__paragraph">Możemy zatrzymać bąbelkowanie zdarzenia na wyższe elementy poprzez metodę <strong class="bold">stopPropagation()</strong>. Wystarczy lekka modyfikacja naszej funkcji <strong class="bold">buttonClick</strong>, aby zapobiec odpaleniu funkcji <strong class="bold">containerClick</strong> przez kliknięcie w przycisk.</p>

        <pre class="article__code">
        <code>
    function buttonClick(event) {
      event.stopPropagation();
      console.log('Przycisk został kliknięty.');
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt zdarzenia</h3>

        <p class="article__paragraph">W powyższym przykładzie widzimy pojawienie się parametru <strong class="bold">event</strong>. Jest to obiekt zdarzenia, który jest automatycznie przekazywany do naszej funkcji obsługującej zaistniałe zdarzenie. Niesie on z sobą wiele informacji na temat zaistniałego zdarzenia jak np: typ zdarzenia – <strong class="bold">event.type</strong>, element który zapoczątkował zdarzenie – <strong class="bold">event.target</strong>.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Powstrzymywanie domyślnego zachowania dla zdarzeń</h3>

        <p class="article__paragraph">Niektóre wydarzenia jak np. wysłanie formularza z automatu wysyłają pobrane z niego dane na serwer. Jeśli chcemy wykonać sprawdzenie poprawności tych danych po stronie przeglądarki użytkownika, musimy wyłączyć domyślne zachowanie dla tego zdarzenia, żeby móc przeprowadzić nasze sprawdzenia. Robimy to za pomocą metody <strong class="bold">preventDefault()</strong>.</p>

        <pre class="article__code">
        <code>
    const form = document.querySelector('#Form');
    console.log(form);

    function validate(event) {
      event.preventDefault();
      console.log('Wykonuje sprawdzenie poprawności wprowadzonych danych');
    }

    form.addEventListener('submit', validate);
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 22 -->


    <article class="article">

      <header id="JSON" class="article__header">
        <div class="decor">22</div>
        <h2 class="article__title">JSON</h2>
      </header>

      <p class="article__paragraph">Za każdym razem gdy chcemy przesłać informacje za pomocą sieci internet z pomocą przychodzi nam JSON, jest to powszechnie używany format danych do przesyłania informacji.</p>

      <p class="article__paragraph">JSON to skrót od JavaScript Object Notation, czyli zapis w stylu obiektów JavaScript. Ponieważ znasz już obiekty JavaScript, można powiedzieć, że znasz też JSON-a. Jednak nim krzykniesz „hura” i zamkniesz ten wpis. Wiedz, że występuje pomiędzy nimi kilka różnic. Oto one:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">JSON zawiera tylko właściwości.</li>
        <li class="ordered-list__item">Nazwy kluczy piszemy w cudzysłowach podwójnych.</li>
        <li class="ordered-list__item">Wymagany jest brak przecinka po ostatniej właściwości.</li>
        <li class="ordered-list__item">Brak komentarzy i pojedynczych cudzysłowów.</li>
        <li class="ordered-list__item">Wartości <strong class="bold">Infinity, NaN</strong> oraz <strong class="bold">undefined</strong> są zwracane jako <strong class="bold">null</strong> </li>
      </ol>

      <p class="article__paragraph">Przykładowy JSON:</p>

      <pre class="article__code">
        <code>
    {
      "name": "Tomasz",
      "age": 29,
      "alive": true,
      "login": null,
      "favoriteFilms": ["Forrest Gump", "Najlepszy", "Matrix", "Zielona Mila", "Dwunastu gniewnych ludzi", "Siedem"],
      "favoriteBook": {"title": "The Slight Edge","author": "Jeff Olson","publisher": "Greenleaf Book Group Press"}
    }
        </code>
      </pre>

      <p class="article__paragraph">Najczęściej dane zapisane w formacie <strong class="bold">.json</strong>, mogą być w postaci pojedynczego obiektu (powyższy przykład) lub tablicy zawierającej wiele obiektów (poniższy przykład).</p>

      <pre class="article__code">
        <code>
    [
      {
        "name": "Tomasz"
      },
      {
        "name": "Marcin"
      },
      {
        "name": "Daniel"
      }
    ]
        </code>
      </pre>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt JSON</h3>

        <p class="article__paragraph">Aby móc z łatwością zamieniać obiekty JavaScript na format .json lub na odwrót. Mamy dostępny pojedynczy wbudowany obiekt o nazwie <strong class="bold">JSON</strong>. Zapewnia on nam dwie metody <strong class="bold">stringify(value, replacer,  space)</strong> oraz <strong class="bold">parse(text, reviver)</strong>.</p>

        <h4 class="article__section__subtitle">stringify</h4>

        <p class="article__paragraph">Służy do zamiany na format json. Jako pierwszy argument przyjmuje nasze dane. Kolejne argumenty są opcjonalne, drugi z nich pozwala nam na przefiltrowanie danych, które chcemy zamienić. Może być podany w postaci funkcji, która przyjmuje dwa parametry <strong class="bold">(key, value)</strong> lub w postaci tablicy. W takim przypadku zostaną nam zwrócone tylko te właściwości, które są w niej zawarte. Ostatnim, trzecim argumentem jest cyfra, oznaczająca o ile spacji będą wcięte nasze dane, lub ciąg znaków służący za wcięcia. Argument ten służy tylko do tego aby wynik był bardziej czytelny dla nas ludzi.</p>

        <pre class="article__code">
        <code>
    const userData = {
      // Właściwości

      name: 'Tomasz',
      age: 29,
      alive: true,
      login: null,
      favoriteFilms: ['Forrest Gump', 'Najlepszy', 'Matrix', 'Zielona Mila', 'Dwunastu gniewnych ludzi', 'Siedem'],
      favoriteBook: {
        title: 'The Slight Edge',
        author: 'Jeff Olson',
        publisher: 'Greenleaf Book Group Press'
      },

      // Metody

      getUserName: function() {
        return this.name;
      }
    };

    const jsonData = JSON.stringify(userData, null, 2);
    console.log(jsonData);

    /*
    {
      "name": "Tomasz",
      "age": 29,
      "alive": true,
      "login": null,
      "favoriteFilms": [
        "Forrest Gump",
        "Najlepszy",
        "Matrix",
        "Zielona Mila",
        "Dwunastu gniewnych ludzi",
        "Siedem"
      ],
      "favoriteBook": {
        "title": "The Slight Edge",
        "author": "Jeff Olson",
        "publisher": "Greenleaf Book Group Press"
      }
    }
    */

    function replacer(key, value) {
      if (typeof value === 'string') {
        return undefined;
      }
      return value;
    }

    const filteredJsonData = JSON.stringify(userData, replacer, '--');
    console.log(filteredJsonData);

    /*
    {
    --"age": 29,
    --"alive": true,
    --"login": null,
    --"favoriteFilms": [
    ----null,
    ----null,
    ----null,
    ----null,
    ----null,
    ----null
    --],
    --"favoriteBook": {}
    }
    */

    const filteredJsonData2 = JSON.stringify(userData, ['favoriteFilms'], 2);
    console.log(filteredJsonData2);

    /*
    {
      "favoriteFilms": [
        "Forrest Gump",
        "Najlepszy",
        "Matrix",
        "Zielona Mila",
        "Dwunastu gniewnych ludzi",
        "Siedem"
      ]
    }
    */
        </code>
      </pre>


        <h4 class="article__section__subtitle">parse</h4>

        <p class="article__paragraph">Zamienia ciąg znaków .json na obiekt lub wartość JavaScript. Tak samo jak wcześniej pierwszym argumentem są nasze dane. Natomiast drugim, opcjonalnym argumentem jest funkcja przekształcająca nasze dane zanim zostaną zwrócone.</p>

        <pre class="article__code">
        <code>
    const receivedData = JSON.parse(jsonData);
    console.log(receivedData);

    // {name: "Tomasz", age: 29, alive: true, login: null, favoriteFilms: Array(6), …}

    function reviver(key, value) {
      if (value === null ||
         (Array.isArray(value)) &amp;&amp; value.length === 0 ||
         (typeof value === 'object' &amp;&amp; Object.keys(value).length === 0)) {
        return undefined;
      }
      return value;
    }

    const receivedData2 = JSON.parse(filteredJsonData, reviver);
    console.log(receivedData2);

    // {age: 29, alive: true}

    const receivedData3 = JSON.parse(filteredJsonData2);
    console.log(receivedData3);

    // {favoriteFilms: Array(6)}
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 23 -->


    <article class="article">

      <header id="HTTP" class="article__header">
        <div class="decor">23</div>
        <h2 class="article__title">HTTP</h2>
      </header>

      <p class="article__paragraph">Dzisiaj robimy małą przerwę od JavaScript żeby zrozumieć jak działa przesyłanie informacji przez sieć. Wiedza ta przyda się nam, gdy będziemy omawiać AJAX-a czyli asynchroniczny JavaScript i XML.</p>

      <section class="article__section">
        <h3 class="article__section__title">Protokół HTTP</h3>

        <p class="article__paragraph">Służy do przesyłania stron internetowych do naszych przeglądarek oraz do wysyłania informacji na serwer. Jest to protokół klient-serwer co oznacza, że żądania są inicjowane przez naszą przeglądarkę internetową. Za każdym razem gdy wchodzimy na stronę inicjujemy żądania do serwera jej poszczególnych elementów jak np: tekst, arkusze stylów CSS, skrypty JavaScript, obrazki, nagrania wideo itp. Im więcej żądań i im większe są pliki, które są przesyłane tym dłuższy jest czas oczekiwania na załadowanie naszej strony.</p>

        <p class="article__paragraph">Komunikacja z serwerem odbywa się na podstawie pojedynczych wiadomości. Różne części naszej strony mogą znajdować się na różnych serwerach. Wiadomość wysyłaną przez naszą przeglądarkę nazywany <strong class="bold">żądaniem</strong>, natomiast wiadomość wysyłana przez serwer to <strong class="bold">odpowiedź</strong>. HTTP jest bezstanowy, oznacza to, że każde z naszych żądań jest nie zależne i nie wie nic o innych żądaniach jakie wykonaliśmy do tej pory, przy użyciu tego samego połączenia.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Co możemy kontrolować przy użyciu HTTP ?</h3>

        <h4 class="article__section__subtitle">1 Pamięć podręczna</h4>

        <p class="article__paragraph">Żeby zwiększyć szybkość wczytywania stron, które często odwiedzamy oraz zmniejszyć ruch, czyli tym samym zmniejszyć obciążenie serwera, korzystamy z pamięci podręcznej, która pozwala nam wykorzystać wcześniej pobrane zasoby. Dzięki HTTP serwer może poinformować serwery proxy (serwery pośredniczące w wymianie informacji) oraz naszą przeglądarkę jakie zasoby ma przechowywać, przez jaki okres czasu.</p>

        <h4 class="article__section__subtitle">2 Uwierzytelnianie</h4>

        <p class="article__paragraph">Aby ograniczyć dostępność do naszej strony, tak aby tylko wybrani użytkownicy mieli do niej dostęp, możemy wykorzystać podstawowe metody uwierzytelniania zapewniane przez HTTP, WWW-Authenticate lub poprzez ustawienie określonej sesji przy użyciu plików cookie HTTP.</p>

        <h4 class="article__section__subtitle">3 Proxy</h4>

        <p class="article__paragraph">Jeśli chcemy pozostać anonimowi w sieci i ukryć nasz prawdziwy adres IP. Możemy to zrobić przy pomocy sieci Tor.</p>

        <h4 class="article__section__subtitle">4 Sesje</h4>

        <p class="article__paragraph">Używanie ciasteczek HTTP pozwala połączyć ze sobą oddzielne zapytania pochodzące od tego samego klienta. Dzięki temu możemy stwierdzić czy dane żądanie pochodzi od tego samego użytkownika. Tworzy to sesje, mimo że podstawowy protokół HTTP jest protokołem bezstanowym.</p>

        <h4 class="article__section__subtitle">5 CORS</h4>

        <p class="article__paragraph">Dzięki nagłówkom HTTP możemy zmniejszyć obostrzenia związane z CORS (Cross-Origin Resource Sharing), które polega na blokowaniu danych pochodzących z innych źródeł niż domena naszej strony.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Żądania i odpowiedzi</h3>

        <p class="article__paragraph">Dokładnej strukturze żądania i odpowiedzi przyjrzymy się w kolejnym wpisie. Dzisiaj natomiast powiemy sobie ogólnie z czego się składa żądanie i odpowiedź. Oraz omówimy statusy otrzymanych odpowiedzi.</p>

        <p class="article__paragraph">Zarówno żądanie jak i odpowiedź zawierają wersję protokołu HTTP jaki jest wykorzystywany w komunikacji, nagłówki oraz ewentualne ciało wiadomości.</p>

        <p class="article__paragraph">Żądanie natomiast zawiera dodatkowo adres URL zasobu, do którego chcemy się odwołać oraz nazwę metody, określającej rodzaj wysyłanego żądania.</p>

        <p class="article__paragraph">Odpowiedź natomiast zawiera dodatkowo status, informujący czy dane żądanie zakończyło się sukcesem lub porażką oraz opis danego kodu statusu.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Statusy HTTP</h3>

        <p class="article__paragraph">Zostały podzielone na 5 grup. Pierwsza cyfra określa grupę do jakiej należy dany status. Mamy więc:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Statusy informacyjne – zaczynające się od 1 np. 101</li>
          <li class="ordered-list__item">Statusy sukcesu – zaczynające się od 2 np. 200</li>
          <li class="ordered-list__item">Statusy przekierowań – zaczynające się od 3 np. 301</li>
          <li class="ordered-list__item">Statusy błędów po stronie klienta – zaczynające się od 4 np. 404</li>
          <li class="ordered-list__item">Statusy błędów po stronie serwera – zaczynające się od 5 np. 500</li>
        </ol>

        <p class="article__paragraph">Najczęściej występujące kody statusu to:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item"><strong class="bold">200 OK</strong> – wszystko przebiegło pomyślnie</li>
          <li class="unordered-list__item"><strong class="bold">301 Moved Permanently</strong> – informuje klienta, że zasób został przeniesiony na stałe w inne miejsce. Taki status informuje wyszukiwarki o tym, że strona, która wcześniej była pod adresem X znajduje się w nowym miejscu</li>
          <li class="unordered-list__item"><strong class="bold">400 Bad Request</strong> – serwer informuje klienta o błędnym zapytaniu, które nie będzie przetworzone</li>
          <li class="unordered-list__item"><strong class="bold">403 Forbidden</strong> – zasób wymaga uwierzytelnienia, po potwierdzeniu tożsamości może być dostępny</li>
          <li class="unordered-list__item"><strong class="bold">404 Not Found</strong> – żądany zasób nie istnieje</li>
          <li class="unordered-list__item"><strong class="bold">500 Internal Server Error</strong> – serwer napotkał sytuacje, której nie umie poprawnie obsłużyć</li>
          <li class="unordered-list__item"><strong class="bold">502 Bad Gateway</strong> – ten status informuje o tym, że jeden z pośrednich węzłów dostał błędną odpowiedź od poprzedniego węzła</li>
          <li class="unordered-list__item"><strong class="bold">503 Service Unavailable</strong> – ten błąd informuje o tym, że serwer jest przeciążony, ponowna próba może zakończyć się poprawną odpowiedzią</li>
        </ul>
      </section>
    </article>


    <!-- Article 24 -->


    <article class="article">

      <header id="REST_API" class="article__header">
        <div class="decor">24</div>
        <h2 class="article__title">REST API</h2>
      </header>

      <p class="article__paragraph">Kontynuujemy temat rozpoczęty w poprzednim wpisie. Czym jest API już wiemy z postu o DOM. Natomiast REST (Representational State Transfer) odnosi się do sposobu tworzenia takiego API. Jest ono zbudowane na protokole HTTP, w oparciu o 5 zasad:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Jednolity interfejs (Uniform Interface) – oznacza, że istnieje jeden interfejs, który obsługuje wszystkie typy urządzeń, które się z nim łączą.</li>
        <li class="ordered-list__item">Klient-serwer (Client-Server) – oznacza rozdzielenie aplikacji po stronie klienta i po stronie serwera.</li>
        <li class="ordered-list__item">Pozbawiony stanu (Stateless) – każde żądanie jest nie zależne od innych żądań i posiada komplet informacji niezbędnych do jego przetworzenia.</li>
        <li class="ordered-list__item">Używa pamięci podręcznej (Cachable) – żeby odciążyć serwer część danych powinna być zapisywana w pamięci podręcznej i stamtąd pobierana.</li>
        <li class="ordered-list__item">Zbudowany warstwowo (Layered System) – wysyłając żądanie do serwera, nasz klient nie powinien wiedzieć dokąd odwołuje się serwer żeby wysłać nam gotową odpowiedź.</li>
      </ol>

      <section class="article__section">
        <h3 class="article__section__title">Zasoby</h3>

        <p class="article__paragraph">Celem istnienia naszego REST API jest dodawanie, pobieranie, modyfikowanie i kasowanie zasobów. Zasobami mogą być np. dane naszych użytkowników. Każdy zasób jest identyfikowany poprzez <strong class="bold">URI</strong> (Uniform Resource Identifier) czyli łańcuch znaków jak np. <strong class="bold">http://blog.tomasz-rybacki.pl</strong>. Dodatkowo zasoby znajdujące się w sieci posiadają swój <strong class="bold">URL</strong> (Uniform Resource Locator), który określa ich położenie.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Budowa adresu URL</h3>

        <span class="article__command">scheme://[user:password]@host:port]/path?query#fragment</span>

        <p class="article__paragraph"><strong class="bold">scheme</strong> – określa wykorzystywany protokół jak http lub https</p>

        <p class="article__paragraph"><strong class="bold">user:password</strong> – służy do potwierdzania tożsamości użytkownika, ze względów bezpieczeństwa nie jest jednak wykorzystywany, ponieważ z łatwością można odczytać informacje przesyłane w ten sposób</p>

        <p class="article__paragraph"><strong class="bold">host</strong> – określa nazwę domeny lub jej adres IP</p>

        <p class="article__paragraph"><strong class="bold">port</strong> – określa numer portu, który „nasłuchuje” serwer. Protokoły mają przypisane domyślne porty dla http wartość ta wynosi 80 natomiast dla https równa się 443</p>

        <p class="article__paragraph"><strong class="bold">path</strong> – ścieżka dostępu do zasobu np: /kurs-javascript/21-dom</p>

        <p class="article__paragraph"><strong class="bold">query</strong> – zaczyna się od znaku zapytania. Zawiera pary klucz=wartość połączone znakiem &amp;. Służy do podawania dodatkowych danych identyfikujących zasób</p>

        <p class="article__paragraph"><strong class="bold">fragment</strong> – oznacza fragment strony HTML, która powinna zostać wyświetlona użytkownikowi</p>

        <p class="article__paragraph">Przykładowy URL:</p>

        <span class="article__command">http://blog.tomasz-rybacki.pl/kurs-javascript/21-dom/#comments</span>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Metody HTTP</h3>

        <p class="article__paragraph">Wpisując powyższy URL do naszej przeglądarki zostaniemy przeniesieni do sekcji komentarzy wpisu o DOM na moim blogu. Stanie się tak ponieważ nasza przeglądarka użyje metody GET aby pobrać zasób jaki znajduje się pod wskazanym adresem. W odpowiedzi serwer zwróci jej wskazany plik HTML, na podstawie którego zostanie wyświetlona cała strona.</p>

        <p class="article__paragraph">Istnieje 8 metod http do przeprowadzania różnych operacji. Należą do nich:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">GET</li>
          <li class="ordered-list__item">POST</li>
          <li class="ordered-list__item">PUT</li>
          <li class="ordered-list__item">DELETE</li>
          <li class="ordered-list__item">OPTIONS</li>
          <li class="ordered-list__item">HEAD</li>
          <li class="ordered-list__item">TRACE</li>
          <li class="ordered-list__item">CONNECT</li>
        </ol>

        <p class="article__paragraph">Dzięki tym metodom możemy powiązać różne akcje jakie mają zostać wykonane dla naszego zasobu, zachowując ten sam adres URL np. GET /posts i POST /posts.</p>

        <p class="article__paragraph"><strong class="bold">GET</strong> – odczytuje wskazany zasób, może zawierać dodatkowe parametry w postaci query string</p>

        <p class="article__paragraph"><strong class="bold">POST</strong> – przesyła dane do wskazanego zasobu</p>

        <p class="article__paragraph"><strong class="bold">PUT</strong> – służy do aktualizacji danego zasobu</p>

        <p class="article__paragraph"><strong class="bold">DELETE</strong> – służy do usuwania zasobów</p>

        <p class="article__paragraph"><strong class="bold">OPTIONS</strong> – używane jest do sprawdzania jakie metody są obsługiwane przez serwer dla danego zasobu</p>

        <p class="article__paragraph"><strong class="bold">HEAD</strong> – służy do sprawdzania czy dany zasób się zmienił. Jest podobne do zapytania GET z tą różnicą, że nie zawiera ciała wiadomości.</p>

        <p class="article__paragraph"><strong class="bold">TRACE</strong> – służy do testowania. W odpowiedzi na nie serwer powinien wysłać zapytanie, które otrzymał. Nie zawiera ciała wiadomości.</p>

        <p class="article__paragraph"><strong class="bold">CONNECT</strong> – służy do utworzenia połączenia pomiędzy klientem a serwerem docelowym za pomocą węzłów pośrednich. W praktyce rzadko stosowane.</p>
      </section>
    </article>


    <!-- Article 25 -->


    <footer class="documentation__footer">
      <span class="footer__txt">designed &amp; coded with <span class="footer__icon">&#10084;</span> by <span class="footer__bold">&copy; Tomasz Rybacki</span> in 2018</span>
    </footer>
  </main>


  <script src="scripts/jquery-3.2.0.min.js"></script>
  <script src="scripts/code.js"></script>
</body>

</html>
