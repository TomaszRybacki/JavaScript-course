<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <meta name="author" content="Tomasz Rybacki">
  <meta name="description" content="Responsive Web Design Projects - Build a Technical Documentation Page">

  <title>Technical Documentation Page</title>
  <link rel="icon" type="image/png" sizes="96x96" href="img/favicon96x96.png">

  <link href="https://fonts.googleapis.com/css?family=Muli:400,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="stylesheet" href="css/main.css">

</head>

<body class="body">

  <button class="menu" id="menu-button">
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
  </button>

  <nav id="navbar" class="navigation">
    <header class="navigation__header">
      <h1 class="header__title">Kurs JavaScript</h1>
    </header>
    <ol class="navigation__list">
      <li class="nav-item"><a class="nav-link" href="#Czym_jest_javaScript">01. Czym jest javaScript ?</a></li>
      <li class="nav-item"><a class="nav-link" href="#Debugowanie_cz1">02. Debugowanie cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Debugowanie_cz2">03. Debugowanie cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Typy_wartosci">04. Typy wartoÅ›ci</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zmienne_cz1">05. Zmienne cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Zmienne_cz2">06. Zmienne cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Operatory">07. Operatory</a></li>
      <li class="nav-item"><a class="nav-link" href="#Konwersja_typow">08. Konwersja typÃ³w</a></li>
      <li class="nav-item"><a class="nav-link" href="#Instrukcje_warunkowe">09. Instrukcje warunkowe</a></li>
      <li class="nav-item"><a class="nav-link" href="#Tablice">10. Tablice</a></li>
      <li class="nav-item"><a class="nav-link" href="#Podstawowe_petle">11. Podstawowe pÄ™tle</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz1">12. Funkcje cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz2">13. Funkcje cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Funkcje_cz3">14. Funkcje cz.3</a></li>
      <li class="nav-item"><a class="nav-link" href="#Objekty_cz1">15. Objekty cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#Objekty_cz2">16. Objekty cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#Klasy">17. Klasy</a></li>
      <li class="nav-item"><a class="nav-link" href="#Obiekty_opakowujace">18. Obiekty opakowujÄ…ce</a></li>
    </ol>
  </nav>

  <div class="push"></div>

  <main id="main-doc" class="documentation">

    <header class="documentation__header">
      <img class="header__banner" src="img/JavaScript-banner.jpg" alt="banner javaScript">
      <span class="header__txt">Kurs ten powstaÅ‚ w ramach mojego <a class="blog-link" href="http://blog.tomasz-rybacki.pl">bloga</a>.<br> ZachÄ™cam CiÄ™ do jego odwiedzenia oraz Å¼yczÄ™ owocnej nauki programowania w JavaScript.</span>
    </header>


    <!-- Article 01 -->


    <article class="article">

      <header id="Czym_jest_javaScript" class="article__header">
        <div class="decor">01</div>
        <h2 class="article__title">Czym jest javaScript ?</h2>
      </header>

      <p class="article__paragraph">W wikipedii czytamy, Å¼e jest to skryptowy jÄ™zyk programowania. WyjaÅ›nijmy sobie co to oznacza.</p>

      <p class="article__paragraph">Programy napisane w tym jÄ™zyku nie wymagajÄ… kompilacji do kodu maszynowego, ktÃ³ry jest zapisywany w postaci binarnej (same zera i jedynki). Kod ten jest bezpoÅ›rednio wykonywany przez procesor komputera. Zamiast tego nasze skrypty sÄ… wykonywane za pomocÄ… interpretera, ktÃ³ry analizuje kaÅ¼de wyraÅ¼enie przed jego wykonaniem.</p>

      <p class="article__paragraph">JavaScript jest jÄ™zykiem wysokiego poziomu co oznacza, Å¼e piszÄ…c w nim nie przejmujemy siÄ™ wszystkim tym co dzieje siÄ™ â€pod maskÄ…â€ jak: zarzÄ…dzanie pamiÄ™ciÄ…, przechowywanie danych, wewnÄ™trzne typy danych. DziÄ™ki temu moÅ¼na dosyÄ‡ szybko poznaÄ‡ jego podstawy i zaczÄ…Ä‡ samodzielnie pisaÄ‡ skrypty. UÅ¼ywamy w nim abstrakcji do ukrycia technicznych detali. Kod piszemy przy pomocy angielskich sÅ‚Ã³w, dziÄ™ki temu odczytywanie go jest proste, niczym czytanie instrukcji obsÅ‚ugi nowo zakupionego urzÄ…dzenia AGD ğŸ™‚</p>

      <p class="article__paragraph">Skrypty, ktÃ³re w nim piszemy sÄ… wykonywane w caÅ‚oÅ›ci od poczÄ…tku do koÅ„ca. Z gÃ³ry na dÃ³Å‚, od lewej do prawej. SÄ… to zasady, ktÃ³re wszyscy dobrze znamy i z ktÃ³rych korzystamy na co dzieÅ„ podczas czytania. Nasz kod JavaScript dziaÅ‚a w pewnym Å›rodowisku. MoÅ¼e byÄ‡ to przeglÄ…darka internetowa (na tym Å›rodowisku skupimy siÄ™ w tym kursie) lub np. Node.js, w ktÃ³rym to moÅ¼emy uruchamiaÄ‡ kod JavaScript po stronie serwera lub w wierszu poleceÅ„ naszego komputera. Od naszego Å›rodowiska zaleÅ¼y do jakich obiektÃ³w globalnych bÄ™dziemy mieli dostÄ™p. Z niego wynika zastosowanie naszego kodu. MogÄ… byÄ‡ to wszystkie interakcje uÅ¼ytkownika ze stronÄ… internetowÄ… lub logika wykonywana po stronie serwera.</p>

      <p class="article__paragraph">WspÃ³Å‚czesne narzÄ™dzia jak silnik JavaScript V8 w Google Chrome, kompilujÄ… nasz kod w chwili wykonania. Pozwala to na jeszcze szybsze dziaÅ‚anie naszych programÃ³w.</p>

      <p class="article__paragraph">CiekawostkÄ… jest sama nazwa tego jÄ™zyka programowania. PoczÄ…tkowo nazywaÅ‚ siÄ™ LiveScript, jednak na fali rosnÄ…cej popularnoÅ›ci i sukcesu jakim cieszyÅ‚ siÄ™ jÄ™zyk Java. ZostaÅ‚ przemianowany na JavaScript. ZostaÅ‚ wiÄ™c jego mÅ‚odszym bratem i przedmiotem Å¼artÃ³w. PoniewaÅ¼ osoby kompletnie zielone czÄ™sto utoÅ¼samiajÄ… te dwa rÃ³Å¼ne jÄ™zyki programowania ze sobÄ…. MyÅ›lÄ…c, Å¼e sÄ… tym samym.</p>

    </article>


    <!-- Article 02 -->


    <article class="article">

      <header id="Debugowanie_cz1" class="article__header">
        <div class="decor">02</div>
        <h2 class="article__title">Debugowanie cz.1</h2>
      </header>


      <p class="article__paragraph">Dzisiaj skonfigurujemy nasz projekt, w ktÃ³rym bÄ™dziemy uczyÄ‡ siÄ™ kolejnych zagadnieÅ„ zwiÄ…zanych z JavaScript. Powiemy sobie rÃ³wnieÅ¼ na temat bÅ‚Ä™dÃ³w i sposobÃ³w radzenia sobie z nimi. ZakÅ‚adam, Å¼e masz juÅ¼ zainstalowanego Bracketsa oraz przeglÄ…darkÄ™ Chrome.</p>

      <section class="article__section">
        <h3 class="article__section__title">Projekt</h3>
        <p class="article__paragraph">Tworzymy nowy folder do przechowywania naszych plikÃ³w. Ja nazwaÅ‚em swÃ³j <strong class="bold">Kurs.</strong> WewnÄ…trz tworzymy nowy folder scripts, w ktÃ³rym bÄ™dÄ… znajdowaÄ‡ siÄ™ wszystkie nasze skrypty. Tworzymy tam nowy plik o nazwie <strong class="bold">code.js.</strong> Teraz potrzebujemy utworzyÄ‡ podstawowy plik html o nazwie <strong class="bold">index.html</strong> w folderze gÅ‚Ã³wnym.</p>

        <pre class="article__code">
        <code>
    &lt;!DOCTYPE html&gt;
    &lt;html lang="pl"&gt;

      &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;

        &lt;meta name="author" content="Tomasz Rybacki"&gt;
        &lt;meta name="description" content="Kurs JavaScript dla poczÄ…tkujÄ…cych."&gt;

        &lt;title&gt;Kurs JavaScript&lt;/title&gt;
      &lt;/head&gt;

      &lt;body&gt;

        &lt;script src="scripts/code.js"&gt;&lt;/script&gt;
      &lt;/body&gt;

    &lt;/html&gt;
        </code>
      </pre>

        <p class="article__paragraph">WewnÄ…trz znacznika <strong class="bold">&lt;script&gt;</strong> umieszczamy Å›cieÅ¼kÄ™ dostÄ™pu do naszego pliku z kodem js. Znacznik ten umieszczamy zawsze na koÅ„cu naszego body tuÅ¼ przed znacznikiem zamykajÄ…cym <strong class="bold">&lt;/body&gt;</strong>. Robimy tak poniewaÅ¼ nie chcemy Å¼eby podczas wczytywania strony, Å‚adujÄ…cy siÄ™ kod JavaScript blokowaÅ‚ wyÅ›wietlanie pozostaÅ‚ej czÄ™Å›ci strony. SprawiajÄ…c wraÅ¼enie wolnego dziaÅ‚ania strony i pozostawiajÄ…c uÅ¼ytkownika z biaÅ‚ym ekranem.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">ESLint</h3>
        <p class="article__paragraph">Pierwszym narzÄ™dziem jakie wykorzystamy do pisania kodu dobrej jakoÅ›ci bÄ™dzie <a class="article__link" href="https://eslint.org" target="_blank">ESLint</a> ze zbiorem zasad airbnb-base. NarzÄ™dzie to pokazuje nam bÅ‚Ä™dy jakie popeÅ‚niliÅ›my oraz daje pomocne wskazÃ³wki, jeszcze przed uruchomieniem naszego kodu w przeglÄ…darce.</p>

        <p class="article__paragraph">Å»eby je zainstalowaÄ‡, najpierw potrzebujemy zainstalowaÄ‡ <a class="article__link" href="https://nodejs.org/en/" target="_blank">Node.js.</a> Pobieramy i instalujemy wersjÄ™ rekomendowanÄ… dla wiÄ™kszoÅ›ci uÅ¼ytkownikÃ³w, w chwili pisania tego postu jest to wersja 8.11.1 LTS.</p>

        <p class="article__paragraph">Teraz uruchamiamy wiersz poleceÅ„ i za jego pomocÄ… nawigujemy do folderu z naszym projektem. (Wszystkie moje polecenia sÄ… dla systemu operacyjnego Windows 10) W moim przypadku sÄ… to komendy:</p>

        <span class="article__command">E:</span>
        <span class="article__command">cd E:\11 Programowanie\Blog\Kurs</span>

        <p class="article__paragraph">Teraz inicjalizujemy plik package.json, za pomocÄ… komendy:</p>

        <span class="article__command">npm init</span>

        <p class="article__paragraph">Wszystkie opcje zatwierdzamy enterem. Nie musimy nic wpisywaÄ‡ i zmieniaÄ‡. NastÄ™pnie instalujemy ESLint wpisujÄ…c polecenie:</p>

        <span class="article__command">npm install â€“save-dev eslint eslint-config-airbnb eslint-plugin-import</span>

        <p class="article__paragraph">Teraz dodajemy plik o nazwie .eslintrc. Zawiera on ustawienia z jakich korzystamy w naszym projekcie.</p>

        <pre class="article__code">
        <code>
    {
        "extends": "airbnb-base",
        "parserOptions": {
        "ecmaVersion": 6
        },
        "env": {
        "node": true,
        "browser": true,
        "es6": true
        },
        "rules": {
        "comma-dangle": ["error", "never"],
        "no-unused-vars": ["error", {"vars": "local", "args": "none"}]
        }
    }
      </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e nasz zbiÃ³r zasad jest rozszerzeniem zasad opracowanych przez airbnb-base. DomyÅ›lnie ESLint wspiera tylko skÅ‚adniÄ™ ECMAScript 5, poniewaÅ¼ zamierzamy korzystaÄ‡ rÃ³wnieÅ¼ z wersji ECMAScript 6 dodajemy to moÅ¼liwoÅ›Ä‡ w parserOptions. Nie przejmuj siÄ™ jeÅ›li nie wiesz co to oznacza. Wszystko wyjaÅ›nimy w dalszej czÄ™Å›ci kursu.</p>

        <p class="article__paragraph">â€envâ€ przechowuje Å›rodowiska w jakich bÄ™dzie dziaÅ‚aÅ‚ nasz kod. Natomiast â€rulesâ€ zawiera nasze wÅ‚asne ustawienia obecnie obowiÄ…zujÄ…cych zasad. DodajÄ…c tu kolejne pozycje, moÅ¼emy wyÅ‚Ä…czyÄ‡ lub zmieniÄ‡ status zgÅ‚aszanego bÅ‚Ä™du na ostrzeÅ¼enie lub na odwrÃ³t. Wszystkie rodzaje bÅ‚Ä™dÃ³w i ich moÅ¼liwÄ… konfiguracje znajdziemy w dokumentacji ESLint.</p>

        <img class="article__img" src="img/Linter.jpg" alt="zrzut ekranu edytora Brackets">

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Nasze drzewko plikÃ³w w projekcie powinno wyglÄ…daÄ‡ tak.</li>
          <li class="ordered-list__item">PrzykÅ‚adowy kod, obok widzimy ikony wyÅ›wietlane przez ESLint zgÅ‚aszajÄ…ce ostrzeÅ¼enie i bÅ‚Ä…d w danej linijce kodu.</li>
          <li class="ordered-list__item">Za pomocÄ… tej ikony wÅ‚Ä…czamy i wyÅ‚Ä…czamy podglÄ…d zgÅ‚oszonych bÅ‚Ä™dÃ³w (okno nr 4)</li>
          <li class="ordered-list__item">Lista zgÅ‚oszonych bÅ‚Ä™dÃ³w. ZaczynajÄ…c od lewej mamy:
            <ul class="article__unordered-list">
              <li class="unordered-list__item">nr linii kodu z bÅ‚Ä™dem</li>
              <li class="unordered-list__item">typ bÅ‚Ä™du i informacjÄ™ na jego temat</li>
              <li class="unordered-list__item">nazwÄ™ zasady podanÄ… w nawiasie kwadratowym</li>
            </ul>
          </li>
        </ol>

        <p class="article__paragraph">Kod z tej lekcji moÅ¼na pobraÄ‡ z <a class="article__link" href="https://github.com/TomaszRybacki/Kurs" target="_blank">GitHuba</a>.</p>
      </section>

    </article>


    <!-- Article 03 -->


    <article class="article">

      <header id="Debugowanie_cz2" class="article__header">
        <div class="decor">03</div>
        <h2 class="article__title">Debugowanie cz.2</h2>
      </header>

      <p class="article__paragraph">Dzisiaj dokoÅ„czymy temat radzenia sobie z bÅ‚Ä™dami. OmÃ³wimy obiekt console, punkty kontrolne i typy pojawiajÄ…cych siÄ™ bÅ‚Ä™dÃ³w.</p>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt console</h3>
      </section>

      <p class="article__paragraph">PrzeglÄ…darka internetowa Chrome ma wbudowanÄ… konsolÄ™ JavaScript, moÅ¼emy w niej pisaÄ‡ bezpoÅ›rednio kod js. RÃ³wnieÅ¼ w niej bÄ™dÄ… siÄ™ nam wyÅ›wietlaÅ‚y wszystkie bÅ‚Ä™dy jakie napotka interpreter. BÄ™dziemy mieli podanÄ… nazwÄ™ bÅ‚Ä™du, jego opis i numer linii kodu, w ktÃ³rym wystÄ…piÅ‚. DziÄ™ki temu moÅ¼emy szybko zlokalizowaÄ‡ i poprawiÄ‡ wystÄ™pujÄ…ce bÅ‚Ä™dy.</p>

      <p class="article__paragraph">Aby jÄ… otworzyÄ‡ klikamy prawym przyciskiem myszy na stronie internetowej i wybieramy przycisk Zbadaj. NastÄ™pnie przechodzimy do zakÅ‚adki Console.</p>

      <img class="article__img" src="img/console.jpg" alt="zrzut ekranu konsoli w przeglÄ…darce Chrome">

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Pasek boczny konsoli. KlikajÄ…c odpowiednio kategoriÄ™ wyÅ›wietlamy tylko powiadomienia danego typu.</li>
        <li class="ordered-list__item">Konsola. To tutaj bÄ™dÄ… pojawiaÄ‡ siÄ™ informacje o bÅ‚Ä™dach z ich opisem. RÃ³wnieÅ¼ tutaj moÅ¼emy pisaÄ‡ nasz kod JS oraz wyÅ›wietlaÄ‡ informacje za pomocÄ… obiektu console.</li>
        <li class="ordered-list__item">Nazwa pliku oraz numer linii kodu z tego pliku, ktÃ³ry generuje danÄ… informacjÄ™.</li>
      </ol>

      <p class="article__paragraph">KonsolÄ™ wykorzystujemy rÃ³wnieÅ¼ do sprawdzania jakie wartoÅ›ci przyjmujÄ… nasze zmienne w danym fragmencie skryptu. Przyjrzyjmy siÄ™ teraz metodom jakie zapewnia obiekt console. NajwaÅ¼niejsze z nich to:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.log()</strong> â€“ sÅ‚uÅ¼Ä…ce do wyÅ›wietlania treÅ›ci w konsoli</li>
      </ul>

      <p class="article__paragraph">Metoda ta ma trzy bliÅºniacze metody, ktÃ³re rÃ³wnieÅ¼ wyÅ›wietlajÄ… nasz tekst w konsoli ale dodatkowo zapewniajÄ… stylowanie. DziÄ™ki czemu moÅ¼emy filtrowaÄ‡ wyÅ›wietlane informacje i wyÅ›wietlaÄ‡ tylko te, ktÃ³re w danym momencie sÄ… dla nas istotne.</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.info()</strong> â€“ wyÅ›wietla tekst jako informacjÄ™</li>
        <li class="unordered-list__item"><strong class="bold">console.warn()</strong> â€“ wyÅ›wietla tekst jako ostrzeÅ¼enie</li>
        <li class="unordered-list__item"><strong class="bold">console.error()</strong> â€“ wyÅ›wietla tekst jako bÅ‚Ä…d</li>
      </ul>

      <p class="article__paragraph">KolejnÄ… przydatnÄ… metodÄ… jest:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.group(), console.groupCollapsed()</strong> â€“ sÅ‚uÅ¼y do grupowania wyÅ›wietlanych informacji pod wspÃ³lnÄ… etykietÄ…, coÅ› w stylu rozpoczynajÄ…cego znacznika HTML</li>
        <li class="unordered-list__item"><strong class="bold">console.groupEnd()</strong> â€“ zamyka naszÄ… grupÄ™, coÅ› w stylu zamykajÄ…cego znacznika HTML</li>
      </ul>

      <p class="article__paragraph">OprÃ³cz tych podstawowych metod, mamy jeszcze kilka, ktÃ³re mogÄ… byÄ‡ przydatne, oto one:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.assert()</strong> â€“ sprawdza warunek, jeÅ›li nie jest speÅ‚niony, dopiero wtedy wyÅ›wietla wiadomoÅ›Ä‡ do konsoli</li>
        <li class="unordered-list__item"><strong class="bold">console.count()</strong> â€“ wyÅ›wietla ile razy zostaÅ‚o uÅ¼yte wywoÅ‚anie tej metody z danÄ… etykietÄ…. Taki zwykÅ‚y licznik.</li>
        <li class="unordered-list__item"><strong class="bold">console.time() </strong> â€“ rozpoczyna odliczanie czasu jaki minÄ…Å‚ od wywoÅ‚ania tej metody, dziÄ™ki temu moÅ¼emy sprawdziÄ‡ czas wykonania danego fragmentu naszego kodu</li>
        <li class="unordered-list__item"><strong class="bold">console.timeEnd()</strong> â€“ koÅ„czy odliczanie czasu i wyÅ›wietla ile czasu (milisekund) upÅ‚ynÄ™Å‚o od jego rozpoczÄ™cia</li>
      </ul>

      <strong class="bold">PrzykÅ‚ad</strong>

      <pre class="article__code">
        <code>
    // Obiekt console

    console.time('Timer');
    console.count('Counter');

    console.group('names');
    console.info('Tomasz');
    console.warn('Daniel');
    console.error('Marcin');
    console.log('Adam');
    console.groupEnd();

    console.count('Counter');

    console.groupCollapsed('age');
    console.log(28);
    console.log(25);
    console.log(32);
    console.log(32);
    console.groupEnd();

    console.count('Counter');

    const myName = 777;
    console.assert(typeof myName === 'string', 'Niepoprawny typ zmiennej, oczekiwano wartoÅ›ci typu "string".');

    console.timeEnd('Timer');
        </code>
      </pre>

      <section class="article__section">
        <h3 class="article__section__title">Punkty kontrolne</h3>

        <p class="article__paragraph">MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e bÄ™dziemy potrzebowaÄ‡ przeanalizowaÄ‡ jak dziaÅ‚a nasz skrypt kawaÅ‚ek po waÅ‚ku. W tym celu moÅ¼emy wstawiÄ‡ sÅ‚owo kluczowe debugger w kaÅ¼dym miejscu, w ktÃ³rym chcemy Å¼eby nastÄ…piÅ‚a pauza w wykonywaniu naszego skryptu. NastÄ™pnie w zakÅ‚adce Sources przeglÄ…darki moÅ¼emy przeÅ‚Ä…czaÄ‡ siÄ™ pomiÄ™dzy utworzonymi punktami kontrolnymi i obserwowaÄ‡ w jaki sposÃ³b jest wykonywany nasz skrypt, jakie wartoÅ›ci przyjmujÄ… zmienne w danym miejscu i jaki jest stos wywoÅ‚aÅ„.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Typy bÅ‚Ä™dÃ³w</h3>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">SyntaxError â€“ nieprawidÅ‚owa skÅ‚adnia np.: niedopasowane lub brakujÄ…ce znaki cytowania, brakujÄ…ce nawiasy, nieprawidÅ‚owe nazwy wÅ‚aÅ›ciwoÅ›ci lub zmiennych</li>
          <li class="unordered-list__item">ReferenceError â€“ zmienna nie istnieje np.: niezadeklarowana zmienna, niezdefiniowana nazwa funkcji</li>
          <li class="unordered-list__item">TypeError â€“ nieoczekiwany typ danych np.: metoda nie istnieje, nieprawidÅ‚owa wielkoÅ›Ä‡ znaku w nazwie metody</li>
          <li class="unordered-list__item">RangeError â€“ liczba spoza zakresu np.: nie moÅ¼na utworzyÄ‡ tablicy zawierajÄ…cej -x elementÃ³w</li>
          <li class="unordered-list__item">EvalError â€“ nieprawidÅ‚owe uÅ¼ycie funkcji eval()</li>
          <li class="unordered-list__item">URIError â€“ nieprawidÅ‚owe uÅ¼ycie funkcji URI</li>
        </ul>

        <p class="article__paragraph">Najbardziej interesujÄ… nas pierwsze cztery typy bÅ‚Ä™dÃ³w bo to wÅ‚aÅ›nie je bÄ™dziemy spotykaÄ‡ najczÄ™Å›ciej piszÄ…c nasze programy.</p>
      </section>

    </article>


    <!-- Article 04 -->


    <article class="article">

      <header id="Typy_wartosci" class="article__header">
        <div class="decor">04</div>
        <h2 class="article__title">Typy wartoÅ›ci</h2>
      </header>

      <p class="article__paragraph">W JavaScript mamy siedem typÃ³w wartoÅ›ci, sÄ… to:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">string</li>
        <li class="ordered-list__item">number</li>
        <li class="ordered-list__item">boolean</li>
        <li class="ordered-list__item">undefined</li>
        <li class="ordered-list__item">null</li>
        <li class="ordered-list__item">symbol</li>
        <li class="ordered-list__item">object</li>
      </ol>

      <p class="article__paragraph">Typ przechowywanej wartoÅ›ci moÅ¼emy sprawdziÄ‡ za pomocÄ… polecenia <strong class="bold">typeof()</strong>. JS jest jÄ™zykiem dynamicznym, zmienne nie sÄ… zwiÄ…zane z konkretnym typem danych jaki mogÄ… przechowywaÄ‡. To wartoÅ›ci przechowywane w zmiennych majÄ… swÃ³j typ i mogÄ… siÄ™ zmieniaÄ‡ w trakcje wykonywania naszego programu. DziÄ™ki czemu zmienna o nazwie <strong class="bold">name</strong> moÅ¼e przechowywaÄ‡ na poczÄ…tku liczbÄ™ (typ number), potem ciÄ…g znakÃ³w (typ string), Å¼eby ostatecznie zostaÄ‡ obiektem (typ object) na koÅ„cu dziaÅ‚ania naszego programu.</p>


      <section class="article__section">
        <h3 class="article__section__title">String</h3>
        <p class="article__paragraph">Jest to ciÄ…g znakÃ³w tekstowych, ktÃ³ry zapisujemy w cudzysÅ‚owie podwÃ³jnym lub pojedynczym lub za pomocÄ… znaku apostrof (tego na klawiszu pod Esc). Ten typ sÅ‚uÅ¼y do przechowywania informacji w postaci sÅ‚Ã³w np.: â€Å»ycie to sztuka wyborÃ³wâ€, â€šLubiÄ™ siÄ™ uczyÄ‡.â€™, `Kodowanie jest fajne.`. WybÃ³r <strong class="bold">â€œ â€</strong> lub <strong class="bold">â€˜ â€™</strong> naleÅ¼y do ciebie. Natomiast <strong class="bold">Â´ Â´</strong> daje dodatkowe moÅ¼liwoÅ›ci, o ktÃ³rych powiemy w dalszych lekcjach kursu JS.</p>

        <p class="article__paragraph">String w JS jest niezmienny co oznacza, Å¼e po jego utworzeniu nie moÅ¼emy go modyfikowaÄ‡. MoÅ¼emy jedynie tworzyÄ‡ nowe wartoÅ›ci typu string na podstawie utworzonej wczeÅ›niej wartoÅ›ci np. poprzez wyciÄ™cie jego czÄ™Å›ci. MajÄ…c sÅ‚owo â€šdomekâ€™, moÅ¼emy wyciÄ…Ä‡ pierwsze trzy litery tworzÄ…c sÅ‚owo â€šdomâ€™.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Number</h3>
        <p class="article__paragraph">Przechowuje liczby, pozwala przeprowadzaÄ‡ operacje matematyczne. Typ ten zawiera zarÃ³wno liczby caÅ‚kowite jak i uÅ‚amkowe liczby dziesiÄ™tne.</p>

        <p class="article__paragraph">W JS wykorzystuje siÄ™ 64-bitowy binarny format podwÃ³jnej precyzji oparty na standardzie IEEE 754. Oznacza to, Å¼e liczby sÄ… przechowywane w 64 bitach, gdzie 1 bit przechowuje znak liczby (+ lub -), 11 bitÃ³w przechowuje wykÅ‚adnik potÄ™gowy (dla 2Â³ = 2 * 2 * 2 wykÅ‚adnikiem jest liczba 3), natomiast pozostaÅ‚e 52 bity przechowujÄ… czÄ™Å›Ä‡ uÅ‚amkowÄ….</p>

        <p class="article__paragraph">Z tego powodu nie moÅ¼emy operowaÄ‡ na dowolnych liczbach, jesteÅ›my zmuszeni do ograniczenia siÄ™ do liczb caÅ‚kowitych z przedziaÅ‚u od 9007199254740991 do -9007199254740991. Dodatkowo uÅ‚amki dziesiÄ™tne nie sÄ… reprezentowane w sposÃ³b dokÅ‚adny i dziaÅ‚anie 0.1 + 0.2 = 0.30000000000000004. Z matematycznego punktu widzenia nie jest to wynik, ktÃ³rego byÅ›my siÄ™ spodziewali. Dlatego musimy zachowaÄ‡ ostroÅ¼noÅ›Ä‡ przy operacjach na uÅ‚amkach i stosowaÄ‡ zaokrÄ…glenia przy porÃ³wnywaniu wynikÃ³w z sobÄ…. KolejnÄ… ciekawostkÄ… jest teÅ¼ fakt istnienia zera dodatniego i zera ujemnego. Gdy podzielimy 2 / 0 otrzymamy nieskoÅ„czonoÅ›Ä‡, natomiast dla dziaÅ‚ania 2 / -0 otrzymamy minus nieskoÅ„czonoÅ›Ä‡.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Boolean</h3>
        <p class="article__paragraph">Typ ten pozwala na podejmowanie decyzji. Jest to typ logiczny, moÅ¼e przyjmowaÄ‡ tylko dwie wartoÅ›ci: true (prawda) i false (faÅ‚sz).</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Undefined</h3>
        <p class="article__paragraph">Typ undefined zawiera tylko jednÄ… wartoÅ›Ä‡, wartoÅ›Ä‡ undefined. WartoÅ›Ä‡ nie zdefiniowana zostaje automatycznie przypisana zmiennej, ktÃ³ra zostaÅ‚a tylko zadeklarowana przy pomocy sÅ‚owa kluczowego var lub let (powiemy na ten temat przy okazji omawiania zmiennych).</p>

        <p class="article__paragraph">Dodatkowo sprawdzajÄ…c typ zmiennej, ktÃ³ra nie zostaÅ‚a zadeklarowana rÃ³wnieÅ¼ otrzymamy wartoÅ›Ä‡ undefined np. console.log(typeof(c)); zwraca undefined gdy zmienna c nie wystÄ™puje w naszym kodzie.</p>

        <p class="article__paragraph">WartoÅ›Ä‡ undefined zwraca rÃ³wnieÅ¼:</p>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">funkcja, w ktÃ³rej nie zastosowano polecenia return</li>
          <li class="unordered-list__item">wÅ‚aÅ›ciwoÅ›Ä‡ obiektu, ktÃ³ra nie jest zadeklarowana</li>
        </ul>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Null</h3>
        <p class="article__paragraph">Typ null zawiera tylko jednÄ… wartoÅ›Ä‡. Jest niÄ… null. WartoÅ›Ä‡ ta reprezentuje celowy brak danej wartoÅ›ci w obiekcie. Wynika z tego, Å¼e musimy jÄ… przypisaÄ‡ do wÅ‚aÅ›ciwoÅ›ci danego obiektu.</p>
        <p class="article__paragraph">WaÅ¼nÄ… rzeczÄ…, o ktÃ³rej trzeba wiedzieÄ‡ to bÅ‚Ä…d jaki istnieje w JS od czasu powstania tego jÄ™zyka.</p>

        <pre class="article__code">
        <code>
    let a = null;
    console.log(typeof(a)); // zwraca typ object
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Symbol</h3>
        <p class="article__paragraph">Jest to nie powtarzalna wartoÅ›Ä‡ sÅ‚uÅ¼Ä…ca do identyfikacji wÅ‚aÅ›ciwoÅ›ci w obiekcie. Tworzymy go za pomocÄ… funkcji Symbol(â€šopisâ€™). Opis sÅ‚uÅ¼y wyÅ‚Ä…cznie do celÃ³w debugowania abyÅ›my my potrafili rozrÃ³Å¼niÄ‡ symbole od siebie. MoÅ¼emy nadaÄ‡ dwÃ³m symbolom takie same opisy. Nie sprawi to jednak, Å¼e oba symbole bÄ™dÄ… takie same i rÃ³wne sobie. Za kaÅ¼dym razem tworzÄ…c symbol tworzymy nowy unikatowy symbol.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Podsumowanie</h3>
        <p class="article__paragraph">OmÃ³wione do tej pory typy to wartoÅ›ci typu prostego, co oznacza, Å¼e sÄ… niezmienne. SÄ… to takie podstawowe klocki, z ktÃ³rych budujemy bardziej zÅ‚oÅ¼one konstrukcje.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Object</h3>
        <p class="article__paragraph">Object natomiast jest wartoÅ›ciÄ… zÅ‚oÅ¼onÄ… skÅ‚adajÄ…cÄ… siÄ™ z par klucz: wartoÅ›Ä‡. Gdzie kluczem moÅ¼e byÄ‡ string lub symbol. Natomiast wÅ‚aÅ›ciwoÅ›ciÄ… mogÄ… byÄ‡ wszystkie wyÅ¼ej wymienione typy. Object dodatkowo zawiera w sobie podtypy takie jak: function (funkcja â€“ obiekt, ktÃ³ry ma moÅ¼liwoÅ›Ä‡ wywoÅ‚ania), array (tablica â€“ obiekt, ktÃ³ry wykorzystuje liczby jako klucze oraz ma automatycznie uaktualnianÄ… wÅ‚aÅ›ciwoÅ›Ä‡ length, ktÃ³ra wskazuje wielkoÅ›Ä‡ tablicy).</p>

        <p class="article__paragraph">Gdy myÅ›limy o obiekcie moÅ¼emy go sobie wyobraziÄ‡ jako uproszczony model opisujÄ…cy coÅ› co znamy z rzeczywistoÅ›ci. WeÅºmy przykÅ‚ad czÅ‚owieka. KaÅ¼dy czÅ‚owiek ma imiÄ™, wzrost, wagÄ™, kolor oczu itp. SÄ… to wÅ‚aÅ›ciwoÅ›ci naszego obiektu. Dodatkowo kaÅ¼dy czÅ‚owiek potrafi robiÄ‡ rÃ³Å¼ne rzeczy, np. mÃ³wiÄ‡, chodziÄ‡ itp. CzynnoÅ›ci wykonywane przez obiekt nazywamy metodami tego obiektu. Oto przykÅ‚ad obiektu o nazwie person.</p>

        <pre class="article__code">
        <code>
    const person = {
        name: 'Tomasz',
        height: 174,
        weight: 70,
        eyeColor: 'gray',

        sayHello() {
          return 'Hello';
        },
        walk() {
          return 'I go for a walk to a park';
        }
    }

    console.log(person.name); // Tomasz
    console.log(person.walk()); // 'I go for a walk to a park'

    console.log(typeof(person.name)); // string
    console.log(typeof(person.walk)); // function
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WartoÅ›Ä‡ specjalna NaN</h3>
        <p class="article__paragraph">Typ number zawiera wartoÅ›Ä‡ NaN (not a number). Oznacza wartoÅ›Ä‡, ktÃ³ra nie jest poprawnÄ… liczbÄ…. Powstaje w wyniku operacji matematycznej, ktÃ³ra siÄ™ nie powiodÅ‚a np: 2 * 'ja'. Mamy typ number mnoÅ¼ony przez typ string. PoniewaÅ¼ JS nie ma pojÄ™cia w jaki sposÃ³b przeprowadziÄ‡ takÄ… operacjÄ™ otrzymamy NaN.</p>

        <p class="article__paragraph">Dodatkowo wartoÅ›Ä‡ NaN nie jest rÃ³wna innej wartoÅ›ci NaN. Dlatego Å¼eby sprawdziÄ‡ czy coÅ› jest wartoÅ›ciÄ… NaN musimy uÅ¼yÄ‡ metody <strong class="bold">Number.isNaN()</strong>.</p>
      </section>


    </article>


    <!-- Article 05 -->


    <article class="article">

      <header id="Zmienne_cz1" class="article__header">
        <div class="decor">05</div>
        <h2 class="article__title">Zmienne cz.1</h2>
      </header>

      <p class="article__paragraph">W kodzie JS istniejÄ… trzy sÅ‚owa kluczowe sÅ‚uÅ¼Ä…ce do deklarowania zmiennych. SÄ… to sÅ‚owa <strong class="bold">var, let, const</strong>. Dzisiaj przyjrzymy siÄ™ rÃ³Å¼nicom jakie wystÄ™pujÄ… pomiÄ™dzy nimi oraz powiemy sobie czym jest zakres i wynoszenie.</p>

      <p class="article__paragraph">NaleÅ¼y pamiÄ™taÄ‡, Å¼e w JS wystÄ™puje typowanie dynamiczne co oznacza, Å¼e to wartoÅ›ci przechowywane w zmiennych majÄ… swoje typy. Same zmienne nie wymuszajÄ… typu wartoÅ›ci jakie mogÄ… przechowywaÄ‡ i moÅ¼na w nich przechowywaÄ‡ wartoÅ›ci rÃ³Å¼nego typu.</p>

      <section class="article__section">
        <h3 class="article__section__title">var</h3>

        <p class="article__paragraph">Jest to najstarszy sposÃ³b deklarowania zmiennej. Poprzez zadeklarowanie zmiennej rozumiemy nastÄ™pujÄ…cÄ… linijkÄ™ kodu:</p>

        <pre class="article__code">
        <code>
    var myName;
        </code>
      </pre>

        <p class="article__paragraph">WÅ‚aÅ›nie utworzyliÅ›my zmiennÄ… o nazwie <strong class="bold">myName</strong>. W tym momencie przechowuje ona wartoÅ›Ä‡ undefined. Zmienne utworzone w ten sposÃ³b sÄ… dodawane do obiektu globalnego <strong class="bold">window</strong>. Przy pomocy polecenia:</p>

        <pre class="article__code">
        <code>
    console.log(window);
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy wyÅ›wietliÄ‡ jego wszystkie wstÄ™pnie zdefiniowane wÅ‚aÅ›ciwoÅ›ci. Zobaczymy, Å¼e nasza zmienna zostaÅ‚a dodana i moÅ¼emy jÄ… odszukaÄ‡ na tej liÅ›cie.</p>

        <p class="article__paragraph">Tutaj jako ciekawostkÄ™ napiszÄ™, Å¼e na poczÄ…tku zadeklarowaÅ‚em zmiennÄ… o nazwie <strong class="bold">name</strong> a nastÄ™pnie byÅ‚em zdziwiony, Å¼e jej wartoÅ›Ä‡ poczÄ…tkowa wynosiÅ‚a â€œâ€, czyli byÅ‚a pustym ciÄ…giem tekstowym (string). Jak moÅ¼emy zobaczyÄ‡ obiekt <strong class="bold">window</strong> posiada wstÄ™pnie zdefiniowanÄ… wÅ‚aÅ›ciwoÅ›Ä‡ o nazwie <strong class="bold">name</strong>. Zagadka rozwiÄ…zana, wszystko dziaÅ‚a jak naleÅ¼y.</p>

        <strong class="bold">Zasady nadawania nazw zmiennym:</strong>
        <ol class="article__ordered-list">
          <li class="ordered-list__item">nazwa nie moÅ¼e zaczynaÄ‡ siÄ™ od cyfry</li>
          <li class="ordered-list__item">nie moÅ¼e zawieraÄ‡ myÅ›lnika ani krpoki</li>
          <li class="ordered-list__item">nie wolno uÅ¼ywaÄ‡ sÅ‚Ã³w kluczowych jak np.: var, let, const</li>
          <li class="ordered-list__item">wielkoÅ›Ä‡ liter ma znaczenie, zmienna <strong class="bold">name</strong> nie rÃ³wna siÄ™ zmiennej <strong class="bold">Name</strong></li>
          <li class="ordered-list__item">gdy nazwa skÅ‚ada siÄ™ z kilku sÅ‚Ã³w zapisujemy je w notacji wielbÅ‚Ä…dziej (camelCase). Czyli kolejne wyrazy pisane sÄ… Å‚Ä…cznie, rozpoczynajÄ…c kaÅ¼dy nastÄ™pny wielkÄ… literÄ…. np. <strong class="bold">myName</strong></li>
          <li class="ordered-list__item">nazwa powinna wskazywaÄ‡ na rodzaj informacji jaki jest przechowywany w zmiennej</li>
        </ol>

        <p class="article__paragraph">WracajÄ…c do naszego przykÅ‚adu, jeÅ›li chcÄ™ zainicjowaÄ‡ zmiennÄ… myName i przypisaÄ‡ jej wartoÅ›Ä‡, mogÄ™ to zrobiÄ‡ za pomocÄ… znaku rÃ³wnoÅ›ci.</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">MogÄ™ wykonaÄ‡ obie te czynnoÅ›ci w tej samej linijce kodu. NaleÅ¼y jednak pamiÄ™taÄ‡, Å¼e interpreter JS, wykonuje te dwie czynnoÅ›ci oddzielnie najpierw deklaruje zmiennÄ… a dopiero potem przypisuje jej wartoÅ›Ä‡.</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    // ten kod zostanie wykonany jako:

    var myName;
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy przypisaÄ‡ wartoÅ›Ä‡ do zmiennej bez jej deklaracji. Jest to jednak bardzo zÅ‚y pomysÅ‚. W takim przypadku dochodzi bowiem do automatycznego utworzenia zmiennej globalnej w chwili wykonywania danej linii kodu przez interpreter.</p>
      </section>


      <section class="article__section">
        <h3 class="article__section__title">Zakres</h3>

        <p class="article__paragraph">Kolejnym pojÄ™ciem jakie musimy zrozumieÄ‡ jest zakres zmiennej. Zakres oznacza zasiÄ™g w jakim jest widoczna nasza zmienna. W przypadku var jest to zakres lokalny funkcji, w ktÃ³rej zostaÅ‚a zadeklarowana zmienna lub jest to zakres globalny dla zmiennych zadeklarowanych poza funkcjÄ….</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    function getMyFullName() {
      var mySurname = 'Rybacki';
      console.log(myName);
      console.log(mySurname);
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // ReferenceError
    getMyFullName(); // Tomasz Rybacki
        </code>
      </pre>

        <p class="article__paragraph">Zakres lokalny funkcji oznacza, Å¼e zmienna jest widoczna tylko wewnÄ…trz funkcji, w ktÃ³rej zostaÅ‚a zadeklarowana. Natomiast zmienne z zakresu globalnego sÄ… widoczne w caÅ‚ym naszym skrypcie. Dlatego w powyÅ¼szym przykÅ‚adzie funkcja getMyFullName wyÅ›wietli zarÃ³wno moje imiÄ™ jak i nazwisko.</p>

        <p class="article__paragraph">Jednak gdy sprÃ³bujÄ™ dostaÄ‡ siÄ™ do zmiennej mySurname poza funkcjÄ… otrzymam bÅ‚Ä…d ReferenceError. Dzieje siÄ™ tak poniewaÅ¼, reszta mojego skryptu nie widzi tej zmiennej i nie ma pojÄ™cia o jej istnieniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wynoszenie</h3>

        <p class="article__paragraph">Przed wykonaniem naszego kodu interpreter przeszukuje caÅ‚y nasz kod w poszukiwaniu deklaracji zmiennych i funkcji. Odnalezione deklaracje sÄ… nastÄ™pnie wynoszone na poczÄ…tek naszego skryptu, dziÄ™ki temu sÄ… widoczne w caÅ‚ym naszym skrypcie.</p>

        <pre class="article__code">
        <code>
    console.log(myName); // undefined

    // nie otrzymamy w tym momencie bÅ‚Ä™du ReferenceError
    // poniewaÅ¼ zmienna zostaÅ‚a wyniesiona na poczÄ…tek skryptu

    var myName = 'Tomasz';

    // zauwaÅ¼my, Å¼e dopiero w tym momencie zostaÅ‚a przypisana wartoÅ›Ä‡

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">PowyÅ¼szy kod zostanie wykonany przez interpreter w nastÄ™pujÄ…cy sposÃ³b:</p>

        <pre class="article__code">
        <code>
    var myName;

    console.log(myName); // undefined

    myName = 'Tomasz';

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Z tego teÅ¼ powodu powinniÅ›my deklarowaÄ‡ wszystkie nasze zmienne na poczÄ…tku naszego skryptu (zakres globalny) lub funkcji (zakres lokalny). DziÄ™ki temu nasz kod jest czytelniejszy, od razu widzimy, jakie zmienne majÄ… jaki zakres.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Dlaczego nie chcemy deklarowaÄ‡ wszystkich naszych zmiennych globalnie ?</h3>

        <p class="article__paragraph">Nasza aplikacja lub strona internetowa moÅ¼e wspÃ³Å‚pracowaÄ‡ z wieloma bibliotekami napisanymi w JS przez kogoÅ› innego. Wynika z tego, Å¼e ktoÅ› inny mÃ³gÅ‚ by nadaÄ‡ takie same nazwy swoim zmiennym jak zrobiliÅ›my to my w naszym skrypcie. PowstaÅ‚o by wtedy wiele zamieszania, a wyniki dziaÅ‚ania naszej aplikacji byÅ‚y by nieprzewidywalne. Dlatego staramy siÄ™ unikaÄ‡ wspÃ³Å‚dzielenia przestrzeni nazw i gdy tylko to moÅ¼liwe ukrywamy nasze zmienne.</p>
      </section>
    </article>


    <!-- Article 06 -->

    <article class="article">

      <header id="Zmienne_cz2" class="article__header">
        <div class="decor">06</div>
        <h2 class="article__title">Zmienne cz.2</h2>
      </header>

      <p class="article__paragraph">Kontynuujemy temat zmiennych. Dzisiaj przyjrzymy siÄ™ zmiennym wprowadzonym przez ECMAScript 6. SÄ… to sÅ‚owa kluczowe <strong class="bold">let</strong> i <strong class="bold">const</strong>. Dodatkowo zobaczymy w jaki sposÃ³b wartoÅ›ci sÄ… przechowywane w zmiennych.</p>

      <section class="article__section">
        <h3 class="article__section__title">let</h3>

        <p class="article__paragraph">Za pomocÄ… sÅ‚owa <strong class="bold">let</strong> deklarujemy zmiennÄ…, ktÃ³rej zakres jest ograniczony do bloku kodu. Blokiem kodu nazywamy wszystko co zawiera siÄ™ w nawiasach klamrowych { }, moÅ¼emy w ten sposÃ³b zgrupowaÄ‡ ze sobÄ… kilka wyraÅ¼eÅ„.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    var mySurname = 'Rybacki';

    {
      let myName = 'Marcin';
      var mySurname = 'Kazanowski'

      console.log(myName); // Marcin
      console.log(mySurname); // Kazanowski
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // Kazanowski
        </code>
      </pre>

        <p class="article__paragraph">let nie tworzy wÅ‚aÅ›ciwoÅ›ci na obiekcie globalnym</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';
    let mySurname = 'Rybacki';

    console.log(window.myName); // Tomasz
    console.log(window.mySurname); // undefined
        </code>
      </pre>

        <p class="article__paragraph">nie moÅ¼na ponownie zadeklarowaÄ‡ zmiennej o tej samej nazwie w danym zakresie</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myName = 'Marcin'; // SyntaxError
        </code>
      </pre>

        <p class="article__paragraph">nie ulega wynoszeniu â€“ tak zwana tymczasowa martwa strefa (Temporal Dead Zone)</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz'; // ReferenceError
    console.log(typeof(myName)); // ReferenceError
    let myName;
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">const</h3>

        <p class="article__paragraph">Przy uÅ¼yciu sÅ‚owa kluczowego <strong class="bold">const</strong> deklarujemy zmiennÄ…, ktÃ³ra jest staÅ‚Ä…. Co oznacza, Å¼e nie moÅ¼na jej przypisaÄ‡ nowej wartoÅ›ci. Dodatkowo musimy przypisaÄ‡ jej wartoÅ›Ä‡ w chwili deklaracji.</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"> PoniÅ¼sze prÃ³by zakoÅ„czÄ… siÄ™ bÅ‚Ä™dem</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
    const myName = 'Marcin'; // SyntaxError

    const myName; // SyntaxError
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">const</strong> tak samo jak <strong class="bold">let</strong> ma zakres bloku, nie tworzy wÅ‚aÅ›ciwoÅ›ci na obiekcie globalnym, nie moÅ¼na ponownie zadeklarowaÄ‡ zmiennej o tej samej nazwie w danym zakresie i nie ulega wynoszeniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Przechowywanie wartoÅ›ci w zmiennych</h3>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieÄ‡ w jaki sposÃ³b wartoÅ›ci sÄ… przechowywane w zmiennych. OtÃ³Å¼ wartoÅ›ci typu prostego sÄ… przechowywane bezpoÅ›rednio w danej zmiennej. MoÅ¼emy wiÄ™c kopiowaÄ‡ wartoÅ›ci jakie przechowujÄ… do innych zmiennych.</p>

        <pre class="article__code">
        <code>
    let a = 2;
    console.log(a); // 2

    let b = a;
    console.log(b); // 2

    b = b + 2;
    console.log(b); // 4
    console.log(a); // 2
        </code>
      </pre>

        <p class="article__paragraph"> WyobraÅºmy sobie, Å¼e zmienna <strong class="bold">a</strong> jest pudeÅ‚kiem, w ktÃ³rym znajduje siÄ™ cyfra <strong class="bold">2</strong>. W momencie zadeklarowania zmiennej <strong class="bold">b</strong> i przypisania jej wartoÅ›ci <strong class="bold">a</strong> powstaje nowe pudeÅ‚ko z nowÄ… cyfrÄ… <strong class="bold">2</strong>. W efekcie mamy dwa pudeÅ‚ka i dwie oddzielne cyfry <strong class="bold">2</strong>, ktÃ³re moÅ¼emy niezaleÅ¼nie od siebie modyfikowaÄ‡.</p>

        <p class="article__paragraph">Natomiast wartoÅ›ci typu zÅ‚oÅ¼onego sÄ… zapisywane w zmiennych jako referencja do miejsca w pamiÄ™ci, w ktÃ³rej sÄ… przechowywane dane informacje. MoÅ¼emy to sobie wyobraziÄ‡ jako jedno pudeÅ‚ko, w ktÃ³rym znajduje siÄ™ obiekt <strong class="bold">me</strong>. W chwili utworzenia obiektu <strong class="bold">myBrother</strong> nie nastÄ™puje skopiowanie obiektu <strong class="bold">me</strong> i przypisanie go do nowej zmiennej. Powstaje natomiast nowa referencja (czyli taka strzaÅ‚ka wskazujÄ…ca gdzie znajduje siÄ™ obiekt <strong class="bold">me</strong>). Mamy wiÄ™c dwie oddzielne strzaÅ‚ki, ktÃ³re wskazujÄ… te same pudeÅ‚ko. ModyfikujÄ…c wiÄ™c dowolnÄ… ze strzaÅ‚ek, tak naprawdÄ™ modyfikujemy ten sam pojemnik. Dlatego w poniÅ¼szym przykÅ‚adzie zmieniliÅ›my zarÃ³wno moje imiÄ™ jak i imiÄ™ mojego brata.</p>

        <pre class="article__code">
        <code>
    let me = {
      name: 'Tomasz',
      age: 28
    }

    let myBrother = me;

    myBrother.name = 'Daniel';

    console.log(myBrother.name); // Daniel
    console.log(me.name); // Daniel
        </code>
      </pre>

        <p class="article__paragraph">Gdy zadeklarujemy staÅ‚Ä…, ktÃ³ra przechowuje wartoÅ›Ä‡ typu zÅ‚oÅ¼onego jak np. obiekt. MoÅ¼emy zmieniÄ‡ wÅ‚aÅ›ciwoÅ›ci tego obiektu. Nie moÅ¼emy jednak przypisaÄ‡ jej nowej wartoÅ›ci.</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28
    }

    person.name = 'Daniel';
    person.age = 25;

    console.log(person); // {name: Daniel, age: 25}

    person = 'Daniel'; // TypeError
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 07 -->

    <article class="article">

      <header id="Operatory" class="article__header">
        <div class="decor">07</div>
        <h2 class="article__title">Operatory</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Operatory matematyczne</h3>

        <p class="article__paragraph">SÄ… nam dobrze znane z lekcji matematyki. SÄ… to:</p>

        <pre class="article__code">
        <code>
    // dodawanie (+)

    console.log(2 + 3); // 5

    // odejmowanie (-)

    console.log(5 - 4); // 1

    // mnoÅ¼enie (*)

    console.log(2 * 3); // 6

    // dzielenie (/)

    console.log(8 / 2); // 4

    // reszta z dzielenia (%)

    console.log(6 % 5); // 1
        </code>
      </pre>

        <p class="article__paragraph">NowoÅ›ciÄ… dla nas mogÄ… byÄ‡ operatory inkrementacji (++) i dekrementacji (--). Czyli odpowiednio zwiÄ™kszenia i zmniejszenia danej wartoÅ›ci o 1. MoÅ¼emy je stosowaÄ‡ za rÃ³wno z lewej strony jak i prawej strony naszej zmiennej. Gdy wystÄ™pujÄ… z lewej to zmiana wartoÅ›ci nastÄ…pi juÅ¼ w danej linijce kodu, gdy wystÄ™pujÄ… z prawej to zmiana wartoÅ›ci nastÄ…pi w nastÄ™pnej linijce kodu.</p>

        <pre class="article__code">
        <code>
    // inkrementacja (++) - czyli zwiÄ™kszenie wartoÅ›ci o 1

    let someNumber = 2;

    console.log(someNumber++); // 2
    console.log(someNumber); // 3

    someNumber = 2;

    console.log(++someNumber); // 3
    console.log(someNumber); // 3

    // dekrementacja (--) - czyli zmniejszenie wartoÅ›ci o 1

    let otherNumber = 6;

    console.log(otherNumber--); // 6
    console.log(otherNumber); // 5

    otherNumber = 6;

    console.log(--otherNumber); // 5
    console.log(otherNumber); // 5
        </code>
      </pre>

        <p class="article__paragraph">OsobiÅ›cie wolÄ™ ich nie stosowaÄ‡ i uÅ¼ywaÄ‡ operatorÃ³w przypisania <strong class="bold">someNumber += 1</strong> lub <strong class="bold">someNumber -=1</strong>, co wedÅ‚ug mnie jest o wiele bardziej czytelne.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory przypisania</h3>

        <p class="article__paragraph">Znamy juÅ¼ operator rÃ³wna siÄ™ (=) z poprzednich wpisÃ³w. Nie wiemy jednak, Å¼e ma on kilka wariantÃ³w, ktÃ³re pozwalajÄ… najpierw wykonaÄ‡ dziaÅ‚anie a nastÄ™pnie przypisaÄ‡ wynik tego dziaÅ‚ania np. <strong class="bold">someNumber += 1</strong> jest rÃ³wnoznaczne z <strong class="bold">someNumber = someNumber + 1</strong></p>

        <pre class="article__code">
        <code>
    let number = 6;

    // przypisanie dodawania (+=)

    console.log(number += 2); // 8

    // przypisanie odejmowania (-=)

    console.log(number -= 2); // 6

    // przypisanie mnoÅ¼enia

    console.log(number *= 2); // 12

    // przypisanie dzielenia (/=)

    console.log(number /= 2); // 6

    // przypisanie reszty z dzielenia

    console.log(number %= 2); // 0
        </code>
      </pre>
      </section>
      <section class="article__section">
        <h3 class="article__section__title">Operatory porÃ³wnania</h3>

        <p class="article__paragraph">SÅ‚uÅ¼Ä… do sprawdzenia czy obie strony rÃ³wnania sÄ… sobie rÃ³wne czy rÃ³Å¼ne.</p>

        <p class="article__paragraph"><strong class="bold">1 PorÃ³wnanie luÅºne (==)</strong></p>

        <p class="article__paragraph">Zezwala na konwersjÄ™ typÃ³w porÃ³wnywanych wartoÅ›ci. Czyli gdy porÃ³wnujemy ze sobÄ… dwie wartoÅ›ci rÃ³Å¼nych typÃ³w jak np. '2' == 2 otrzymamy wartoÅ›Ä‡ <strong class="bold">true</strong>. Czyli obie wartoÅ›ci sÄ… sobie rÃ³wne, poniewaÅ¼ typ string zostaÅ‚ zamieniony na typ number i dopiero wÃ³wczas dokonano porÃ³wnania 2 == 2, co jak wiemy jest prawdÄ….</p>

        <p class="article__paragraph"><strong class="bold">2 PorÃ³wnanie Å›cisÅ‚e (===)</strong></p>

        <p class="article__paragraph">Nie zezwala na konwersjÄ™ typÃ³w porÃ³wnywanych wartoÅ›ci. Czyli '2' === 2 da nam w wyniku <strong class="bold">false</strong>. DokÅ‚adnie na temat konwersji typÃ³w powiemy w kolejnym wpisie. PozostaÅ‚e operatory porÃ³wnania to:</p>

        <pre class="article__code">
        <code>
    // wiÄ™kszy od (&gt;)

    console.log(4 &gt; 2); // true

    // mniejszy od (&lt;)

    console.log(1 &lt; 3); // true

    // wiÄ™kszy rÃ³wny od (&gt;=)

    console.log(2 &gt;= 2); // true

    // mniejszy rÃ³wny od (&lt;=)

    console.log(6 &lt;= 9); // true

    // nie rÃ³wny - porÃ³wnanie luÅºne (!=)

    console.log(2 != 3); // true

    // nie rÃ³wny - porÃ³wnanie Å›cisÅ‚e (!==)

    console.log('3' !== 3); // true
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory logiczne</h3>

        <p class="article__paragraph">Gdy chcemy podjÄ…Ä‡ bardziej skomplikowanÄ… decyzjÄ™ stosujemy operatory logiczne, ktÃ³re pozwalajÄ… nam sprawdziÄ‡ kilka warunkÃ³w jednoczeÅ›nie.</p>

        <p class="article__paragraph">Warto wiedzieÄ‡, Å¼e operator <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong> zwraca jednÄ… ze sprawdzanych wartoÅ›ci, a poniewaÅ¼ najczÄ™Å›ciej jest stosowany w kontekÅ›cie sprawdzania wartoÅ›ci boolowskich jest nastÄ™pnie konwertowany do wartoÅ›ci <strong class="bold">true</strong> lub <strong class="bold">false</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myAge = 28;
    let isSleeping = true;

    // logiczne i (&amp;&amp;) - zwraca prawdÄ™ gdy oba warunki sÄ… speÅ‚nione

    console.log(myAge &gt;= 18 &amp;&amp; myName === 'Tomasz'); // true
    console.log(myAge &amp;&amp; myName); // Tomasz
    // logiczne lub (||) - zwraca prawdÄ™ gdy jeden z warunkÃ³w jest speÅ‚niony

    console.log(myName === 'Tomasz' || myName === 'Marcin'); // true

    // negacja (!) - odwraca wartoÅ›Ä‡ z prawdy na faÅ‚sz lub na odwrÃ³t

    console.log(!isSleeping); // false
        </code>
      </pre>

        <p class="article__paragraph">WyraÅ¼enia logiczne sÄ… sprawdzane od lewej do prawej strony. Staramy siÄ™ pisaÄ‡ je w taki sposÃ³b Å¼eby warunek, ktÃ³ry ma wiÄ™ksze prawdopodobieÅ„stwo oblaÄ‡ nasz test byÅ‚ umieszczony z lewej strony. PoniewaÅ¼ dalsza czÄ™Å›Ä‡ naszego wyraÅ¼enia nie jest wtedy sprawdzana, tylko od razu otrzymujemy nasz wynik np. dla <strong class="bold">warunek1 &amp;&amp; warunek2</strong> gdy <strong class="bold">warunek1</strong> zwrÃ³ci <strong class="bold">false</strong>, caÅ‚e nasze wyraÅ¼enie zwrÃ³ci wartoÅ›Ä‡ <strong class="bold">false</strong> bez sprawdzania <strong class="bold">warunek2</strong>. Analogicznie dla <strong class="bold">warunek1 || warunek2</strong>, gdy <strong class="bold">warunek1</strong> zwraca <strong class="bold">true</strong>, caÅ‚e wyraÅ¼enie zwraca wartoÅ›Ä‡ <strong class="bold">true</strong>.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Konkatenacja</h3>

        <p class="article__paragraph">Operator (+) ma dodatkowe dziaÅ‚anie w postaci Å‚Ä…czenia ze sobÄ… Å‚aÅ„cuchÃ³w znakÃ³w.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log('Mam na' + ' imiÄ™ ' + myName + '.'); // Mam na imiÄ™ Tomasz.
        </code>
      </pre>

        <p class="article__paragraph">Wraz z wprowadzeniem przez ES6 szablonÃ³w ciÄ…gÃ³w znakÃ³w, zamiast uÅ¼ywaÄ‡ plusa do Å‚Ä…czenia ze sobÄ… Å‚aÅ„cuchÃ³w znakÃ³w korzystamy ze znaku apostrofu (pod klawiszem Esc). Jest to o wiele bardziej czytelniejszy sposÃ³b na umieszczanie tekstu ze zmiennych w generowanych przez nas zdaniach. Zmienne umieszczamy w nawiasach klamrowych poprzedzonych znakiem dolara <strong class="bold">${}</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log(`Mam na imiÄ™ ${myName}.`); // Mam na imiÄ™ Tomasz.
        </code>
      </pre>
      </section>


    </article>


    <!-- Article 08 -->


    <article class="article">

      <header id="Konwersja_typow" class="article__header">
        <div class="decor">08</div>
        <h2 class="article__title">Konwersja typÃ³w</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Czym jest konwersja typÃ³w ?</h3>

        <p class="article__paragraph">Jest to zamiana typu jednej wartoÅ›ci na inny typ. Kyle Simpson uÅ¼ywa okreÅ›lenia <strong class="bold">jawnej konwersji typÃ³w</strong>, gdy w naszym kodzie widaÄ‡, Å¼e konwersja przeprowadzana jest celowo. Oraz okreÅ›lenia <strong class="bold">niejawnej konwersji typÃ³w</strong>, gdy nastÄ™puje ona jako efekt dodatkowy innej przeprowadzanej operacji.</p>

        <p class="article__paragraph">Nie bÄ™dÄ™ dokÅ‚adnie opisywaÅ‚ mechanizmu jej dziaÅ‚ania, Å¼eby nie komplikowaÄ‡. W koÅ„cu z zaÅ‚oÅ¼enia kurs ten jest przeznaczony dla osÃ³b poczÄ…tkujÄ…cych.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Jawna konwersja typÃ³w.</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczby (number) na ciÄ…g znakÃ³w (string) lub na odwrÃ³t.</strong></p>

        <p class="article__paragraph">Najbardziej przejrzystym sposobem dokonania tej konwersji jest uÅ¼ycie wbudowanych funkcji <strong class="bold">String()</strong> i <strong class="bold">Number()</strong>:</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(Number(age)); // 28
    console.log(typeof(Number(age))); // number

    console.log(String(birthday)); // '1989'
    console.log(typeof(String(birthday))); // string
        </code>
      </pre>

        <p class="article__paragraph">Kolejnym jawnym sposobem na zamianÄ™ ciÄ…gu znakÃ³w na liczbÄ™ jest uÅ¼ycie operatora +</p>

        <pre class="article__code">
        <code>
    let age = '28';

    console.log(+age); // 28
    console.log(typeof(+age)); // number
        </code>
      </pre>

        <p class="article__paragraph"> <strong class="bold">- zamiana na typ boolean</strong></p>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieÄ‡ na temat wartoÅ›ci prawdziwych (truthy) i faÅ‚szywych (falsy).</p>

        <p class="article__paragraph">WartoÅ›ciÄ… faÅ‚szywÄ… jest wszystko to co zostaje zamienione na wartoÅ›Ä‡ <strong class="bold">false</strong> podczas konwersji na typ boolean. Jest to krÃ³tka, Å›ciÅ›le okreÅ›lona lista wartoÅ›ci, ktÃ³rÄ… Å‚atwo zapamiÄ™taÄ‡.</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">undefined</li>
          <li class="ordered-list__item">null</li>
          <li class="ordered-list__item">0</li>
          <li class="ordered-list__item">NaN</li>
          <li class="ordered-list__item">'' pusty ciÄ…g znakÃ³w</li>
        </ol>

        <p class="article__paragraph">WartoÅ›ci prawdziwe moÅ¼emy zapamiÄ™taÄ‡ jeszcze proÅ›ciej, sÄ… to wszystkie wartoÅ›ci, ktÃ³re nie znajdujÄ… siÄ™ na powyÅ¼szej liÅ›cie.</p>

        <p class="article__paragraph">Tak samo jak wczeÅ›niej najbardziej czytelnym sposobem na konwersjÄ™ jest uÅ¼ycie wbudowanej funkcji <strong class="bold">Boolean()</strong></p>

        <pre class="article__code">
        <code>
    let object = {};
    console.log(Boolean(object)); // true

    let array = [];
    console.log(Boolean(array)); // true

    let string = '0';
    console.log(Boolean(string)); // true

    let number = 6;
    console.log(Boolean(number)); // true


    let zero = 0;
    console.log(Boolean(zero)); // false

    let something;
    console.log(Boolean(something)); // false

    let empty = null;
    console.log(Boolean(empty)); // false

    let emptyString = '';
    console.log(Boolean(emptyString)); // false

    let invalidNumber = NaN;
    console.log(Boolean(invalidNumber)); // false
        </code>
      </pre>

        <p class="article__paragraph"> Kolejnym sposobem na konwersjÄ™ jest uÅ¼ycie operatora podwÃ³jnej negacji !!</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(!!age); // true
    console.log(typeof(!!age)); // boolean

    console.log(!!birthday); // true
    console.log(typeof(!!birthday)); // boolean
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana wartoÅ›ci zÅ‚oÅ¼onych (obiektÃ³w) na wartoÅ›ci proste</strong></p>

        <p class="article__paragraph">W tym przypadku sprawa siÄ™ nieco komplikuje, poniewaÅ¼ sami musimy okreÅ›liÄ‡ w jaki sposÃ³b chcemy zamieniÄ‡ obiekt na liczbÄ™ lub ciÄ…g znakÃ³w. KaÅ¼dy obiekt dziedziczy metodÄ™ <strong class="bold">toString()</strong> i <strong class="bold">valueOf()</strong>, wÅ‚aÅ›nie te dwie metody okreÅ›lajÄ… w jaki sposÃ³b zostanie dokonana konwersja na <strong class="bold">string</strong> i <strong class="bold">number</strong>.</p>

        <pre class="article__code">
        <code>
    // zostanÄ… wykorzystane domyÅ›lne metody odziedziczone po prototypie

    const person = {
      name: 'Tomasz',
      age: 28
    };

    // funkcje wbudowane Number() i String() wywoÅ‚ujÄ… metody valueOf() i toString()

    console.log(Number(person)); // NaN

    console.log(String(person)); // [object Object]
    console.log(typeof(String(person))); // string

    // moÅ¼emy sami wywoÅ‚aÄ‡ metodÄ™ toString() bezpoÅ›rednio

    console.log(person.toString()); // [object Object]
        </code>
      </pre>

        <p class="article__paragraph">PrzesÅ‚aniamy domyÅ›lne metody i sami decydujemy w jaki sposÃ³b ma nastÄ…piÄ‡ konwersja:</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28,

      valueOf() {
        return this.age;
      },

      toString() {
        return `{name: ${this.name}, age: ${this.age}}`;
      }
    };

    console.log(Number(person)); // 28

    console.log(String(person)); // {name: Tomasz, age: 28}
    console.log(person.toString()); // {name: Tomasz, age: 28}
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Niejawna konwersja typÃ³w</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczb na ciÄ…gi znakÃ³w</strong></p>

        <p class="article__paragraph">JeÅ›li dowolny argument operatora + to wartoÅ›Ä‡ typu string, otrzymamy konkatenacjÄ™ Å‚aÅ„cuchÃ³w znakÃ³w.</p>

        <pre class="article__code">
        <code>
    let birthday = 1989;

    console.log(birthday + ''); // 1989
    console.log(typeof(birthday + '')); // string
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana ciÄ…gÃ³w znakÃ³w na liczby</strong></p>

        <pre class="article__code">
        <code>
    let a = '1';
    let b = 3;

    console.log(a - b); // -2
    console.log(a * b); // 3
    console.log(a / b); // 0.3333333333333333
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- konwersja dowolnej wartoÅ›ci na typ boolean</strong></p>

        <p class="article__paragraph">KaÅ¼da wartoÅ›Ä‡ uÅ¼yta w kontekÅ›cie poniÅ¼szych wyraÅ¼eÅ„ zostanie zamieniona na typ boolean:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">wyraÅ¼enie testowe w instrukcji <strong class="bold">if</strong></li>
          <li class="ordered-list__item">wyraÅ¼enie testowe w nagÅ‚Ã³wku pÄ™tli <strong class="bold">for</strong></li>
          <li class="ordered-list__item">wyraÅ¼enie testowe w pÄ™tlach <strong class="bold">while</strong> i <strong class="bold">do while</strong></li>
          <li class="ordered-list__item">wyraÅ¼enie testowe w operatorze warunkowym</li>
          <li class="ordered-list__item">argument z lewej strony operatorÃ³w <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong></li>
        </ol>


        <p class="article__paragraph">OmÃ³wimy wszystkie te wyraÅ¼enia w kolejnych lekcjach, wiÄ™c nie przejmuj siÄ™, Å¼e nie wiesz jeszcze co oznaczajÄ….</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Korzystanie z rÃ³wnoÅ›ci luÅºnej ==</h3>

        <p class="article__paragraph">WartoÅ›Ä‡ NaN nigdy nie jest rÃ³wna NaN. MoÅ¼emy to sobie wytÅ‚umaczyÄ‡ w nastÄ™pujÄ…cy sposÃ³b.</p>

        <pre class="article__code">
        <code>
    console.log('a' * 2); // NaN
    console.log('b' * 2); // NaN
        </code>
      </pre>

        <p class="article__paragraph">Obie wartoÅ›ci nie sÄ… prawidÅ‚owymi liczbami, ale kaÅ¼da z nich powstaÅ‚a w inny sposÃ³b, dlatego nie sÄ… sobie rÃ³wne. Å»eby sprawdziÄ‡ czy dana wartoÅ›Ä‡ jest NaN, korzystamy z wbudowanej funkcji <strong class="bold">Number.isNaN()</strong>. WaÅ¼ne jest Å¼eby nie pomyliÄ‡ z globalnÄ… funkcjÄ… <strong class="bold">isNaN()</strong>. Jest to starsza wersja tej funkcji, ktÃ³ra wymusza konwersjÄ™ na typ number przed dokonaniem sprawdzenia.</p>

        <pre class="article__code">
        <code>
    console.log(NaN == NaN); // false
    console.log(('a' * 2) == NaN); // false

    console.log(Number.isNaN(NaN)); // true
    console.log(Number.isNaN('a' * 2)); // true

    let a = 'NaN';

    console.log(Number.isNaN(a)); // false
    console.log(isNaN(a)); // true
        </code>
      </pre>

        <p class="article__paragraph">RÃ³wnoÅ›Ä‡ luÅºna ma kilka przypadkÃ³w, ktÃ³re bez znajomoÅ›ci mechanizmu przeprowadzanej konwersji dajÄ… nam zaskakujÄ…ce rezultaty. Dlatego teÅ¼ gdy korzystamy z operatora ==, naleÅ¼y przestrzegaÄ‡ poniÅ¼szych zasad:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">JeÅ›li po ktÃ³rejÅ› ze stron wystÄ™puje wartoÅ›Ä‡ <strong class="bold">true</strong> lub <strong class="bold">false</strong>, nigdy nie uÅ¼ywaj operatora ==</li>
          <li class="ordered-list__item">JeÅ›li po ktÃ³rejÅ› ze stron moÅ¼e wystÄ…piÄ‡ wartoÅ›Ä‡ <strong class="bold">[], â€²â€² lub 0</strong>, nie uÅ¼ywaj operatora ==</li>
        </ol>

        <p class="article__paragraph">Oto lista szalonych wynikÃ³w, ktÃ³rych chcemy uniknÄ…Ä‡ w naszym kodzie:</p>

        <pre class="article__code">
        <code>
    console.log('0' == false); // true
    console.log(false == 0); // true
    console.log(false == ''); // true
    console.log(false == []); // true

    console.log('' == 0); // true
    console.log('' == []); // true
    console.log(0 == []); // true
        </code>
      </pre>

      </section>

    </article>


    <!-- Article 09 -->


    <article class="article">

      <header id="Instrukcje_warunkowe" class="article__header">
        <div class="decor">09</div>
        <h2 class="article__title">Instrukcje warunkowe</h2>
      </header>

      <p class="article__paragraph">Do podejmowania decyzji w kodzie JS sÅ‚uÅ¼Ä… instrukcje warunkowe <strong class="bold">if â€¦ else, switch</strong> oraz operator warunkowy.</p>

      <section class="article__section">
        <h3 class="article__section__title">if â€¦ else</h3>

        <p class="article__paragraph">Nasz warunek jest zamieniany na typ boolean. W zaleÅ¼noÅ›ci od otrzymanego wyniku, wykonamy dany fragment kodu.</p>

        <pre class="article__code">
        <code>
    if (warunek) {
      // jeÅ›li prawda wykonaj ten blok kodu
    } else {
      // jeÅ›li faÅ‚sz wykonaj ten blok kodu
    }
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy w ten sposÃ³b sprawdzaÄ‡ czy dana wartoÅ›Ä‡ istnieje lub czy speÅ‚nia dany warunek np.</p>

        <pre class="article__code">
        <code>
    // sprawdzamy czy obiekt user posiada wÅ‚aÅ›ciwoÅ›Ä‡ myName
    const user = {
      name: 'Tomasz',
      age: 29,
      country: 'Poland'
    };
    if (user.myName) {
      console.log(`WÅ‚aÅ›ciwoÅ›Ä‡ myName zostaÅ‚a odnaleziona, jej wartoÅ›Ä‡ wynosi ${user.myName}`);
    } else {
      console.log('WÅ‚aÅ›ciwoÅ›Ä‡ myName nie zostaÅ‚a odnaleziona w obiekcie user.');
    }
    /*
    Nasz wynik:
    WÅ‚aÅ›ciwoÅ›Ä‡ myName nie zostaÅ‚a odnaleziona w obiekcie user.
    */
    // sprawdzamy czy uÅ¼ytkownik moÅ¼e kupiÄ‡ legalnie piwo w Polsce
    if (user.age &gt;= 18 &amp;&amp; user.country === 'Poland') {
      console.log('MoÅ¼esz legalnie kupiÄ‡ piwo bÄ™dÄ…c w Polsce.');
    } else {
      console.log('W Polsce, nie sprzedajemy alkoholu nieletnim!');
    }
    /*
    Nasz wynik:
    MoÅ¼esz legalnie kupiÄ‡ piwo bÄ™dÄ…c w Polsce
    */
        </code>
      </pre>

        <p class="article__paragraph">JeÅ›li chcemy wykonaÄ‡ tylko jednÄ… linijkÄ™ kodu moÅ¼emy pominÄ…Ä‡ nawiasy klamrowe. Nie jest to zalecana praktyka, ale czasami bywa przydatna i warto o niej wiedzieÄ‡.</p>

        <pre class="article__code">
        <code>
    if (user.name === 'Tomasz') console.log('CzeÅ›Ä‡ Tomasz!'); // CzeÅ›Ä‡ Tomasz!
    if (user.age &gt;= 18) console.log('JesteÅ› peÅ‚noletni.'); // JesteÅ› peÅ‚noletni.
        </code>
      </pre>

        <p class="article__paragraph">Dodatkowo moÅ¼emy zagnieÅ¼dÅ¼aÄ‡ warunki jeden w drugim i sprawdzaÄ‡ kilka warunkÃ³w po sobie</p>

        <pre class="article__code">
        <code>
    if (user.country === 'Poland') {
      if (user.name === 'Janek') {
        if (user.age &gt;= 18) {
          console.log('UÅ¼ytkownik przeszedÅ‚ test prawdziwego Polaka.');
        }
      }
    } else if (user.country === 'Germany') {
      if (user.name === 'Hans') {
        if (user.age &gt;= 18) {
          console.log('UÅ¼ytkownik przeszedÅ‚ test prawdziwego Niemca.');
        }
      }
    } else {
      console.log('UÅ¼ytkownik nie jest ani prawdziwym Polakiem ani prawdziwym Niemcem.');
    }
        </code>
      </pre>

        <p class="article__paragraph">Jak moÅ¼emy zobaczyÄ‡ w powyÅ¼szym przykÅ‚adzie jest to maÅ‚o czytelny sposÃ³b prezentowania logiki naszego kodu. Dodatkowo Å‚atwo w nim popeÅ‚niÄ‡ bÅ‚Ä…d. Dlatego korzystajmy z operatorÃ³w logicznych, Å¼eby nie stosowaÄ‡ zbyt wielu poziomÃ³w zagnieÅ¼dÅ¼enia kodu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">switch</h3>

        <p class="article__paragraph">Gdy chcemy wybraÄ‡ co ma siÄ™ staÄ‡ na podstawie kilku moÅ¼liwych odpowiedzi, korzystamy ze switcha. Jego dziaÅ‚anie polega na sprawdzeniu kaÅ¼dej zdefiniowanej odpowiedzi do naszego warunku. NastÄ™pnie wykonywany jest kod, ktÃ³ry przeszedÅ‚ nasz warunek aÅ¼ do sÅ‚owa kluczowego <strong class="bold">break</strong>. SÅ‚uÅ¼y ono do przerwania dziaÅ‚ania wykonywanego kodu i wyjÅ›cie z bloku kodu <strong class="bold">switch</strong>. Musimy je dodaÄ‡ po kaÅ¼dej moÅ¼liwej odpowiedzi, w przeciwnym razie zostanie wykonany caÅ‚y pozostaÅ‚y kod. Na koÅ„cu instrukcji <strong class="bold">switch</strong> zawsze podajemy przypadek domyÅ›lny (<strong class="bold">default</strong>), ktÃ³ry ma zostaÄ‡ wykonany w przypadku braku dopasowania Å¼adnej z powyÅ¼szych odpowiedzi.</p>

        <pre class="article__code">
        <code>
    switch (warunek) {
      case odpowiedÅº1:
        // wykonaj ten kod gdy odpowiedÅ¼1 jest poprawna
        break;
      case odpowiedÅº2:
        // wykonaj ten kod gdy odpowiedÅ¼2 jest poprawna
        break;
      case odpowiedÅº3:
        // wykonaj ten kod gdy odpowiedÅ¼3 jest poprawna
        break;
      default:
        // gdy Å¼adna z powyÅ¼szych odpowiedzi nie jest wÅ‚aÅ›ciwa, wykonaj ten kod
    }
        </code>
      </pre>

        <strong class="bold">PrzykÅ‚ad</strong>

        <pre class="article__code">
        <code>
    // Jaka jest stolica paÅ„stwa, w ktÃ³rym mieszka nasz uÅ¼ytkownik ?
    switch (user.country) {
      case 'Poland':
        console.log('StolicÄ… paÅ„stwa uÅ¼ytkownika jest Warszawa.');
        break;
      case 'Germany':
        console.log('StolicÄ… paÅ„stwa uÅ¼ytkownika jest Berlin.');
        break;
      case 'Italy':
        console.log('StolicÄ… paÅ„stwa uÅ¼ytkownika jest Rzym.');
        break;
      default:
        console.log('UÅ¼ytkownik mieszka poza EuropÄ….');
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operator warunkowy</h3>

        <p class="article__paragraph">Gdy mamy tylko dwie moÅ¼liwoÅ›ci do wyboru, moÅ¼emy skrÃ³ciÄ‡ nasz kod, przez zastosowanie operatora warunkowego (nazywanego teÅ¼ operatorem trÃ³jkowym).</p>

        <pre class="article__code">
        <code>
    (warunek) ? (wykonaj gdy prawda) : (wykonaj gdy faÅ‚sz)
        </code>
      </pre>
      </section>

      <strong class="bold">PrzykÅ‚ad</strong>

      <pre class="article__code">
        <code>
    let a = 8;
    let b = 5;
    const biggerNumber = (a &gt;= b) ? a : b;
    console.log(biggerNumber); // 8
        </code>
      </pre>

    </article>


    <!-- Article 10 -->


    <article class="article">

      <header id="Tablice" class="article__header">
        <div class="decor">10</div>
        <h2 class="article__title">Tablice</h2>
      </header>

      <p class="article__paragraph">Tablice sÄ… specjalnym typem obiektu w JS. MajÄ… wiÄ™c dostÄ™p do wielu metod pozwalajÄ…cych na manipulowanie nimi. W tym wpisie nie bÄ™dÄ™ omawiaÅ‚ wszystkich dostÄ™pnych dla nich metod. SkupiÄ™ siÄ™ na podstawie ich dziaÅ‚ania. Tablice sÅ‚uÅ¼Ä… do wygodnego przechowywania wiÄ™kszych iloÅ›ci danych typu prostego.</p>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie tablic</h3>

        <p class="article__paragraph">TablicÄ™ moÅ¼emy utworzyÄ‡ za pomocÄ… literaÅ‚u tablicy.</p>

        <pre class="article__code">
        <code>
    // tworzymy pustÄ… tablicÄ™
    const emptyArray = [];
    // tworzymy tablicÄ™ przechowujÄ…cÄ… imiona
    const namesArray = ['Tomasz', 'Daniel', 'Mateusz'];
        </code>
      </pre>

        <p class="article__paragraph">Drugim sposobem na stworzenie tablicy jest uÅ¼ycie konstruktora <strong class="bold">new</strong>.</p>

        <pre class="article__code">
        <code>
    // tworzymy pustÄ… tablicÄ™
    const emptyArray = new Array();
    // tworzymy tablicÄ™ przechowujÄ…cÄ… imiona
    const namesArray = new Array('Tomasz', 'Daniel', 'Mateusz');
    // tworzymy pustÄ… tablicÄ™ o dÅ‚ugoÅ›ci 10 elementÃ³w
    const undefinedElementsArray = new Array(10);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WÅ‚aÅ›ciwoÅ›Ä‡ length</h3>

        <p class="article__paragraph">Opisuje ona dÅ‚ugoÅ›Ä‡ tablicy, czyli liczbÄ™ elementÃ³w jakie siÄ™ w niej znajdujÄ…. NaleÅ¼y pamiÄ™taÄ‡, Å¼e w tablicy mogÄ… znajdowaÄ‡ siÄ™ puste miejsca.</p>

        <pre class="article__code">
        <code>
    // w tablicy znajdujÄ… siÄ™ 3 imiona i jedno puste miejsce zawierajÄ…ce wartoÅ›Ä‡ undefined
    const namesArray = ['Tomasz', 'Daniel', , 'Mateusz'];
    console.log(namesArray.length); // 4
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">DostÄ™p do przechowywanych wartoÅ›ci</h3>

        <p class="article__paragraph">Wszystkie wartoÅ›ci w tablicy posiadajÄ… swÃ³j indeks, czyli liczbÄ™, ktÃ³ra okreÅ›la poÅ‚oÅ¼enie danej wartoÅ›ci w tablicy. Indeksy zaczynamy liczyÄ‡ od zera. Dla tablicy o dÅ‚ugoÅ›ci 3 liczymy (0, 1, 2). Aby pobraÄ‡ wartoÅ›Ä‡ z tablicy wpisujemy jej nazwÄ™ oraz indeks w nawiasie kwadratowym. <strong class="bold">nazwa[indeks]</strong></p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">pierwszy element w tablicy ma zawsze indeks zero: <strong class="bold">nazwa[0]</strong></li>
          <li class="unordered-list__item">ostatni element w tablicy ma indeks: <strong class="bold">nazwa[nazwa.length â€“ 1]</strong></li>
        </ul>

        <pre class="article__code">
        <code>
    // pobieranie wartoÅ›ci z tablicy
    const namesArray = ['Tomasz', 'Daniel', , 'Mateusz'];
    console.log(namesArray[0]); // 'Tomasz'
    console.log(namesArray[1]); // 'Daniel'
    console.log(namesArray[2]); // undefined
    console.log(namesArray[namesArray.length - 1]); // 'Mateusz'
    // nadpisywanie wartoÅ›ci w tablicy
    namesArray[2] = 'Przemek';
    console.log(namesArray); // ["Tomasz", "Daniel", "Przemek", "Mateusz"]
    // usuwanie wartoÅ›ci z tablicy
    delete namesArray[0];
    console.log(namesArray); // [empty, "Daniel", "Przemek", "Mateusz"]
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy najpierw utworzyÄ‡ pustÄ… tablicÄ™ a nastÄ™pnie dodawaÄ‡ do niej wartoÅ›ci za pomocÄ… indeksÃ³w. W takim przypadku musimy byÄ‡ ostroÅ¼ni, poniewaÅ¼ moÅ¼emy utworzyÄ‡ wiele pustych miejsc w naszej tablicy.</p>

        <pre class="article__code">
        <code>
    const animalsArray = [];
    animalsArray[2] = 'cat';
    animalsArray[22] = 'dog';
    console.log(animalsArray); // [empty Ã— 2, "cat", empty Ã— 19, "dog"]
    console.log(animalsArray.length); // 23
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tablice wielowymiarowe</h3>

        <p class="article__paragraph">W tablicy moÅ¼emy przechowywaÄ‡ dowolne wartoÅ›ci, nie muszÄ… to byÄ‡ jedynie wartoÅ›ci typu prostego. MoÅ¼emy w nich umieszczaÄ‡ teÅ¼ obiekty i inne tablice. Gdy tablica zawiera inne tablice jest nazywana tablicÄ… wielowymiarowÄ…. Aby dostaÄ‡ siÄ™ do jej wartoÅ›ci tworzymy ciÄ…g nawiasÃ³w, ktÃ³re okreÅ›lajÄ… kolejno indeksy danej tablicy. <strong class="bold">nazwa[indeks tablicy nr 1][indeks tablicy nr 2][indeks tablicy nr 3] itd.</strong></p>

        <pre class="article__code">
        <code>
    const multidimensionalArray = [['rekin', 'sum'], ['delfin', 'wieloryb'], ['zÃ³Å‚w', 'homar']];
    console.log(multidimensionalArray[0][1]); // 'sum'
    console.log(multidimensionalArray[1][0]); // 'delfin'
    console.log(multidimensionalArray[2][0]); // 'Å¼Ã³Å‚w'
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla forEach</h3>
      </section>

      <p class="article__paragraph">JedynÄ… metodÄ… o jakiej chcÄ™ wspomnieÄ‡ w tym wpisie jest pÄ™tla forEach, poniewaÅ¼ jest to temat powiÄ…zany z tym co bÄ™dzie w kolejnym wpisie, czyli dokÅ‚adnym omÃ³wieniem pÄ™tli w JavaScrpit.</p>

      <p class="article__paragraph">PiszÄ…c w skrÃ³cie, pÄ™tle pozwalajÄ… nam na wykonanie danego fragmentu kodu wielokrotnie, dopÃ³ki jest speÅ‚niony okreÅ›lony przez nas warunek. PÄ™tle sÄ… czÄ™sto wykorzystywane do przeglÄ…dania i manipulowania wartoÅ›ciami w tablicach.</p>

      <p class="article__paragraph">CechÄ… wyrÃ³Å¼niajÄ…cÄ… tÄ… metodÄ™ jest fakt, Å¼e pÄ™tla ta zostanie wykonana tylko dla tych elementÃ³w, ktÃ³re majÄ… przypisanÄ… wartoÅ›Ä‡. Wszystkie puste miejsca w tablicy sÄ… pomijane, mimo Å¼e ich wartoÅ›Ä‡ rÃ³wnieÅ¼ wynosi <strong class="bold">undefined</strong>.</p>

      <pre class="article__code">
        <code>
    const numbersArray = [0, 1, undefined, null, 4, , 6, 7, , 9];
    numbersArray.forEach((num) =&gt; {
      console.log(num * 2);
    });
    /*
    otrzymamy:
    0
    2
    NaN
    0
    8
    12
    14
    18
    */
    console.log(numbersArray[2]); // undefined
    console.log(numbersArray[5]); // undefined
        </code>
      </pre>

    </article>


    <!-- Article 11 -->


    <article class="article">

      <header id="Podstawowe_petle" class="article__header">
        <div class="decor">11</div>
        <h2 class="article__title">Podstawowe pÄ™tle</h2>
      </header>

      <p class="article__paragraph">Gdy chcemy wykonaÄ‡ dany kawaÅ‚ek kodu wielokrotnie, stosujemy w tym celu pÄ™tle. Pozwala nam to na pisanie krÃ³tszego i bardziej czytelnego kodu, ktÃ³ry jest Å‚atwiejszy w utrzymaniu i debugowaniu. W tym wpisie przyjrzymy siÄ™ trzem podstawowym pÄ™tlom dostÄ™pnym w JS. SÄ… to pÄ™tle: <strong class="bold">for, while, doâ€¦while</strong>.</p>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla for</h3>

        <pre class="article__code">
        <code>
    for ([wyraÅ¼enieInicjalizacji]; [warunek]; [wyraÅ¼enieInkrementacji]) {
        Instrukcja
     }
        </code>
      </pre>

        <p class="article__paragraph">ZaÅ‚Ã³Å¼my, Å¼e nie moÅ¼emy spaÄ‡ i Å›piewamy sobie w myÅ›lach piosenkÄ™ <a class="article__link" href="https://www.youtube.com/watch?v=aI3k7X78-KY" target="_blank">Manifest DzieciÄ™cy</a> â€“ Witka Muzyka Ulicy. Za pomocÄ… kodu odliczanie z tej piosenki moÅ¼emy napisaÄ‡ tak:</p>

        <pre class="article__code">
        <code>
    for (let i = 1; i  &lt; 11; i += 1) {
      console.log('i', i);
    }

    /*
     Co da nam w wyniku:

      i 1
      i 2
      i 3
      i 4
      i 5
      i 6
      i 7
      i 8
      i 9
      i 10
    */
        </code>
      </pre>

        <p class="article__paragraph">Jest ogÃ³lnie przyjÄ™tym zwyczajem, Å¼e w pÄ™tlach wykorzystujemy zmienne o nazwie <strong class="bold">i</strong> lub <strong class="bold">j</strong> do iteracji. Jak moÅ¼emy zauwaÅ¼yÄ‡ najpierw inicjalizujemy naszÄ… zmiennÄ… <strong class="bold">i</strong> i przypisujemy jej wartoÅ›Ä‡ poczÄ…tkowÄ…, w naszym przypadku jest to liczba 1.</p>

        <pre class="article__code">
        <code>
    for (let i = 1; --; --) {
      --
    }
        </code>
      </pre>

        <p class="article__paragraph">NastÄ™pnie jest sprawdzany warunek, jeÅ›li jego wynik da nam wartoÅ›Ä‡ <strong class="bold">true</strong> wykonywany jest kod wewnÄ…trz nawiasÃ³w klamrowych (blok kodu pÄ™tli).</p>

        <pre class="article__code">
        <code>
    for (--; i &lt; 11; --) {
      console.log('i', i);
    }
        </code>
      </pre>

        <p class="article__paragraph">Ostatnim krokiem jest zwiÄ™kszenie lub zmniejszenie wartoÅ›ci zmiennej <strong class="bold">i</strong>.</p>

        <pre class="article__code">
        <code>
    for (--; --; i += 1) {
      --
    }
        </code>
      </pre>

        <p class="article__paragraph">CaÅ‚a procedura powtarza siÄ™ ponownie aÅ¼ do momentu gdy warunek zwrÃ³ci nam wartoÅ›Ä‡ <strong class="bold">false</strong>. NaleÅ¼y uwaÅ¼aÄ‡ Å¼eby nie utworzyÄ‡ pÄ™tli dziaÅ‚ajÄ…cej w nieskoÅ„czonoÅ›Ä‡. PoniewaÅ¼ nasza przeglÄ…darka siÄ™ zawiesi, uÅ¼ycie procesora skoczy do 100% i pozostanie nam jedynie <strong class="bold">ctrl + alt + del</strong>, Å¼eby wyjÅ›Ä‡ z tej patowej sytuacji ğŸ™‚</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla while</h3>

        <pre class="article__code">
        <code>
    while (warunek) {
         instrukcja
     }
        </code>
      </pre>

        <p class="article__paragraph">DziaÅ‚a podobnie do pÄ™tli for. TeÅ¼ jest wykonywana dopÃ³ki jest speÅ‚niony jej warunek. Tym razem jednak bardziej musimy pamiÄ™taÄ‡ o zmianie jej licznika, poniewaÅ¼ zmieniamy go w jej wnÄ™trzu.</p>

        <pre class="article__code">
        <code>
    let i = 1;
    while (i &lt; 11) {
        console.log('i', i);
        i += 1;
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla doâ€¦while</h3>

        <pre class="article__code">
        <code>
    do {
        instrukcja
     }
    while (warunek);
        </code>
      </pre>

        <p class="article__paragraph">Jej cechÄ… charakterystycznÄ… jest to, Å¼e zawsze zostanie wykonana przynajmniej raz, poniewaÅ¼ jej warunek jest sprawdzany na koÅ„cu za jej blokiem kodu.</p>

        <pre class="article__code">
        <code>
    let i = 1;
    do {
      console.log('i', i);
      i += 1;
    } while (i &lt; 11);
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tle a tablice</h3>

        <p class="article__paragraph">Bardzo czÄ™sto pÄ™tle sÄ… wykorzystywane do dziaÅ‚ania na tablicach. WracajÄ…c do naszej piosenki, tym razem chcemy wypisywaÄ‡ sÅ‚owa zamiast cyfr w jej refrenie. MoÅ¼emy to zrobiÄ‡ w nastÄ™pujÄ…cy sposÃ³b:</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡', 'siedem', 'osiem', 'dziewiÄ™Ä‡', 'dziesiÄ™Ä‡']
    for (let i = 0; i &lt; words.length; i += 1) {
      console.log('i', words[i]);
    }
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e zaczynamy od 0, poniewaÅ¼ jak wiemy z poprzedniej lekcji elementy w tablicach sÄ… indeksowane od 0. NastÄ™pnie chcemy iterowaÄ‡ przez wszystkie elementy jakie siÄ™ w niej znajdujÄ…, w tym celu wykorzystujemy wÅ‚aÅ›ciwoÅ›Ä‡ <strong class="bold">length</strong> aby pobraÄ‡ dÅ‚ugoÅ›Ä‡ tablicy. Oto nasz wynik:</p>

        <pre class="article__code">
        <code>
    /*
        i raz
        i dwa
        i trzy
        i cztery
        i piÄ™Ä‡
        i szeÅ›Ä‡
        i siedem
        i osiem
        i dziewiÄ™Ä‡
        i dziesiÄ™Ä‡
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">break</h3>

        <p class="article__paragraph">Do przerwania wykonywania pÄ™tli w trakcie jej dziaÅ‚ania sÅ‚uÅ¼y sÅ‚owo kluczowe <strong class="bold">break</strong>. ZaÅ‚Ã³Å¼my, Å¼e szukamy w tablicy danej wartoÅ›ci i gdy tylko jÄ… znajdziemy chcemy przerwaÄ‡ wykonywanie naszej pÄ™tli, Å¼eby nie marnowaÄ‡ czasu na czekanie aÅ¼ sprawdzi wszystkie jej elementy. Å»eby byÅ‚o jeszcze ciekawiej tym razem zaczniemy pÄ™tle od koÅ„ca tablicy i bÄ™dziemy szli w kierunku jej pierwszego elementu.</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡', 'siedem', 'osiem', 'dziewiÄ™Ä‡', 'dziesiÄ™Ä‡'];
    for (let i = words.length - 1; i &gt;= 0; i -= 1) {
      if (words[i] === 'osiem') {
        break;
      }
      console.log('i', words[i]);
    }
    /*
    Nasz wynik:
    i dziesiÄ™Ä‡
    i dziewiÄ™Ä‡
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">continue</h3>

        <p class="article__paragraph">Do pomijania wybranych iteracji sÅ‚uÅ¼y sÅ‚owo kluczowe continue. Tym razem jesteÅ›my pijani podczas Å›piewania naszej piosenki i mamy problemy z liczeniem wstecz. Przez co umknÄ™Å‚o nam kilka liczb ğŸ™‚</p>

        <pre class="article__code">
        <code>
    const words = ['raz', 'dwa', 'trzy', 'cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡', 'siedem', 'osiem', 'dziewiÄ™Ä‡', 'dziesiÄ™Ä‡'];
    for (let i = words.length - 1; i &gt;= 0; i -= 1) {
      if (words[i] === 'osiem' || words[i] === 'trzy' || words[i] === 'piÄ™Ä‡') {
        continue;
      }
      console.log('i', words[i]);
    }
    /*
    i dziesiÄ™Ä‡
    i dziewiÄ™Ä‡
    i siedem
    i szeÅ›Ä‡
    i cztery
    i dwa
    i raz
    */
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PÄ™tla w pÄ™tli</h3>

        <p class="article__paragraph">MoÅ¼e siÄ™ zdarzyÄ‡, Å¼e jedna pÄ™tla nam nie wystarczy i bÄ™dziemy potrzebowali zagnieÅ¼dÅ¼aÄ‡ jednÄ… pÄ™tle w drugiej. W takiej sytuacji koniecznie trzeba pamiÄ™taÄ‡ o zastosowaniu rÃ³Å¼nych zmiennych dla kaÅ¼dej z pÄ™tli. W pierwszej pÄ™tli korzystamy z iteratora o nazwie <strong class="bold">i</strong>, a w drugiej z iteratora o nazwie <strong class="bold">j</strong>.</p>

        <pre class="article__code">
        <code>
    const arrayOfArrays = [['raz', 'dwa', 'trzy'], ['cztery', 'piÄ™Ä‡', 'szeÅ›Ä‡'], ['siedem', 'osiem', 'dziewiÄ™Ä‡']];
    for (let i = 0; i &lt; arrayOfArrays.length; i += 1) {
      console.log('---------')
      for (let j = 0; j &lt; arrayOfArrays[0].length; j += 1) {
        console.log(arrayOfArrays[i][j]);
      }
    }
    /*
    Nasz wynik:
    ---------
    raz
    dwa
    trzy
    ---------
    cztery
    piÄ™Ä‡
    szeÅ›Ä‡
    ---------
    siedem
    osiem
    dziewiÄ™Ä‡
    */
        </code>
      </pre>
      </section>

    </article>


    <!-- Article 12 -->


    <article class="article">

      <header id="Funkcje_cz1" class="article__header">
        <div class="decor">12</div>
        <h2 class="article__title">Funkcje cz.1</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Czym sÄ… funkcje ?</h3>

        <p class="article__paragraph">Funkcje moÅ¼emy sobie wyobraziÄ‡ jako maszyny do przetwarzania, jako przykÅ‚ad weÅºmy drukarkÄ™. Å»eby coÅ› wydrukowaÄ‡ musimy wÅ‚oÅ¼yÄ‡ do drukarki papier, toner i przesÅ‚aÄ‡ informacje, ktÃ³re chcemy przenieÅ›Ä‡ na papier. W rezultacie otrzymujemy zadrukowane strony naszego dokumentu. Tak samo jest z funkcjami, wkÅ‚adamy do nich argumenty. One przetwarzajÄ… je w swoim wnÄ™trzu i zwracajÄ… nam jakiÅ› wynik.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Po co sÄ… funkcje ?</h3>

        <p class="article__paragraph">DziÄ™ki nim mamy moÅ¼liwoÅ›Ä‡ wielokrotnego uÅ¼ywania tego samego fragmentu kodu bez koniecznoÅ›ci powtarzania go. Pozwala to nam na Å‚atwiejsze dokonywanie zmian w naszym programie, znajdowanie bÅ‚Ä™dÃ³w i znacznie skraca dÅ‚ugoÅ›Ä‡ kodu. W programowaniu istnieje zasada DRY ( Donâ€™t Repeat Yourself ) czyli nie powtarzaj siÄ™ i warto jÄ… stosowaÄ‡.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Deklaracja funkcji</h3>

        <pre class="article__code">
        <code>
    function nazwa(parametry) {
        ciaÅ‚o funkcji â€“ dzieje siÄ™ tu caÅ‚a logika i przetwarzanie parametrÃ³w
        return  zwracany przez funkcjÄ™ wynik
    }
        </code>
      </pre>

        <p class="article__paragraph">Jest to pierwszy ze sposobÃ³w na utworzenie funkcji. PowstaÅ‚a w ten sposÃ³b funkcja ulega mechanizmowi wynoszenia, czyli jest przenoszona na poczÄ…tek skryptu, przez co jest dostÄ™pna w caÅ‚ym naszym programie. Sztampowym przykÅ‚adem jest funkcja, ktÃ³ra sumuje dwie liczby.</p>

        <pre class="article__code">
        <code>
    function sum(a, b) {
      return a + b;
    }

    console.log(sum(2, 3)); // 5
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WyraÅ¼enie funkcyjne</h3>

        <p class="article__paragraph">Drugim sposobem stworzenia funkcji jest wyraÅ¼enie funkcyjne, czyli utworzenie zmiennej, ktÃ³ra bÄ™dzie przechowywaÅ‚a referencjÄ™ do funkcji (strzaÅ‚ka wskazujÄ…ca, gdzie znajduje siÄ™ nasza funkcja). W odrÃ³Å¼nieniu od deklaracji funkcji, funkcje stworzone w ten sposÃ³b nie sÄ… wynoszone, wiÄ™c moÅ¼emy ich uÅ¼ywaÄ‡ tylko w tej czÄ™Å›ci naszego skryptu, ktÃ³ra wystÄ™puje za miejscem ich utworzenia.</p>

        <pre class="article__code">
        <code>
    const sum = function (a, b) {
      return a + b;
    };

    console.log(sum(2, 3)); // 5
        </code>
      </pre>

        <p class="article__paragraph">PoniÅ¼szy kod generuje bÅ‚Ä…d.</p>

        <pre class="article__code">
        <code>
    console.log(sum(2, 3)); // 5

    const sum = function (a, b) {
      return a + b;
    };
    // Uncaught ReferenceError: sum is not defined
        </code>
      </pre>

        <p class="article__paragraph">Jak moÅ¼emy zauwaÅ¼yÄ‡ funkcja ta nie ma swojej nazwy, dlatego nazywana jest funkcjÄ… anonimowÄ…. OdwoÅ‚ujemy siÄ™ do niej za poÅ›rednictwem nazwy naszej zmiennej. MoÅ¼emy jednak nadaÄ‡ jej nazwÄ™ jeÅ›li chcemy.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WywoÅ‚ywanie funkcji</h3>

        <p class="article__paragraph">Aby wywoÅ‚aÄ‡ funkcjÄ™ wpisujemy jej nazwÄ™ oraz parÄ™ nawiasÃ³w <strong class="bold">nazwa()</strong>, w tym momencie nasza funkcja zostaje uruchomiona. KontynuujÄ…c nasz przykÅ‚ad z funkcjÄ… sum. MoÅ¼emy jÄ… wywoÅ‚aÄ‡ bez przekazania argumentÃ³w do jej wnÄ™trza.</p>

        <pre class="article__code">
        <code>
    console.log(sum()); // NaN
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w rezultacie otrzymamy Not a Number. PoniewaÅ¼ nie przekazaliÅ›my do niej Å¼adnych argumentÃ³w, wartoÅ›Ä‡ a i b wynosi <strong class="bold">undefined</strong>. DodajÄ…c obie te wartoÅ›ci do siebie otrzymamy <strong class="bold">NaN</strong>, czyli nie prawidÅ‚owÄ… wartoÅ›Ä‡ liczbowÄ….</p>

        <p class="article__paragraph">MoÅ¼emy siÄ™ przed tym zabezpieczyÄ‡ przypisujÄ…c domyÅ›lne wartoÅ›ci parametrÃ³w. Wtedy za kaÅ¼dym razem gdy, ktÃ³ryÅ› z nich zostanie pominiÄ™ty w wywoÅ‚aniu, zostanie uÅ¼yta jego wartoÅ›Ä‡ domyÅ›lna.</p>

        <p class="article__paragraph">Pierwszy ze sposobÃ³w takiego zabezpieczenia wykorzystuje ES6.</p>

        <pre class="article__code">
        <code>
    function sum(a = 0, b = 0) {
      return a + b;
    }
    console.log(sum()); // 0
        </code>
      </pre>

        <p class="article__paragraph"> Nim wprowadzono ES6 stosowano poniÅ¼szÄ… metodÄ™:</p>

        <pre class="article__code">
        <code>
    function sum(a, b) {
      a = a || 0;
      b = b || 0;
      return a + b;
    }
    console.log(sum()); // 0
        </code>
      </pre>

        <p class="article__paragraph">Gdy nie przekaÅ¼emy Å¼adnego argumentu wartoÅ›Ä‡ a wynosi <strong class="bold">undefined</strong>, nastÄ™pnie operator logiczny (lub) sprawdza wartoÅ›Ä‡ po jego lewej stronie, poniewaÅ¼ jest to wartoÅ›Ä‡ faÅ‚szywa wybiera wartoÅ›Ä‡ po swojej prawej stronie i przypisuje jÄ… do zmiennej <strong class="bold">a</strong>. W tym momencie <strong class="bold">a = 0</strong>.</p>

        <p class="article__paragraph">MoÅ¼emy teÅ¼ przekazaÄ‡ do funkcji wiÄ™cej argumentÃ³w niÅ¼ wymaga przez niÄ… iloÅ›Ä‡ parametrÃ³w. Argumentem jest to co wkÅ‚adamy do funkcji w momencie jej wywoÅ‚ania np. <strong class="bold">sum(2, 3)</strong>, argumenty to liczby <strong class="bold">2</strong> i <strong class="bold">3</strong>. Parametrem natomiast jest nazwa zmiennej wykorzystywana do operacji wewnÄ…trz funkcji, czyli <strong class="bold">a</strong> i <strong class="bold">b</strong> w naszym przykÅ‚adzie. Gdy przekaÅ¼emy wiÄ™kszÄ… iloÅ›Ä‡ argumentÃ³w do funkcji niÅ¼ wymagana, wszystkie dodatkowe sÄ… ignorowane.</p>

        <pre class="article__code">
        <code>
    console.log(sum(2, 3, 5, 66)); // 5
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">return</h3>

        <p class="article__paragraph">Aby zwrÃ³ciÄ‡ wartoÅ›Ä‡ z funkcji wykorzystujemy sÅ‚owo kluczowe return. KoÅ„czy ono dziaÅ‚anie funkcji i zwraca wartoÅ›Ä‡. W funkcji moÅ¼e wystÄ™powaÄ‡ kilka sÅ‚Ã³w return, zawsze jednak dziaÅ‚anie funkcji jest koÅ„czone w chwili dotarcia do pierwszego z nich.</p>

        <pre class="article__code">
        <code>
    function checkAge(age) {
      if (age &gt;= 18) {
        return 'MoÅ¼esz wejÅ›Ä‡ do klubu.';
      }
      return 'MÅ‚odocianym wstÄ™p wzbroniony!';
    }
    console.log(checkAge(29)); // MoÅ¼esz wejÅ›Ä‡ do klubu.
        </code>
      </pre>

        <p class="article__paragraph">JeÅ›li pominiemy sÅ‚owo <strong class="bold">return</strong>, funkcja zwrÃ³ci wartoÅ›Ä‡ <strong class="bold">undefined</strong>. PrzewaÅ¼nie chcemy przechowaÄ‡ wynik dziaÅ‚a naszej funkcji w jakiejÅ› zmiennej aby mÃ³c go pÃ³Åºniej wykorzystaÄ‡.</p>

        <pre class="article__code">
        <code>
    let guest = checkAge(16);
    console.log(guest); // MÅ‚odocianym wstÄ™p wzbroniony!

    function printUserName(name) {
      console.log(`Mam na imiÄ™ ${name}`);
    }

    let printMyName = printUserName('Tomasz') // Mam na imiÄ™ Tomasz
    console.log(printMyName); // undefined
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 13 -->


    <article class="article">

      <header id="Funkcje_cz2" class="article__header">
        <div class="decor">13</div>
        <h2 class="article__title">Funkcje cz.2</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Zakres lokalny funkcji</h3>

        <p class="article__paragraph">Z wczeÅ›niejszego wpisu na temat zmiennej var, wiemy, Å¼e jej zakresem moÅ¼e byÄ‡ zakres lokalny funkcji. Oznacza to, Å¼e moÅ¼emy tworzyÄ‡ zmienne, ktÃ³re sÄ… zamkniÄ™te w ciele naszej funkcji i nie da siÄ™ do nich odwoÅ‚aÄ‡ spoza niej. Za kaÅ¼dym razem gdy dana funkcja jest wywoÅ‚ywana, zostaje utworzona zmienna w niej zadeklarowana, ktÃ³ra jest usuwana po zakoÅ„czeniu jej dziaÅ‚ania przez mechanizm usuwania nieuÅ¼ytkÃ³w aby zwolniÄ‡ miejsce w pamiÄ™ci.</p>

        <pre class="article__code">
        <code>
    function defineMyName() {
      let myName = 'Tomasz';
    }

    defineMyName();
    console.log(myMame); // Uncaught ReferenceError: myMame is not defined
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Zakres zagnieÅ¼dÅ¼ony</h3>

        <p class="article__paragraph">Gdy mamy kilka funkcji zagnieÅ¼dÅ¼onych jedna w drugiej. Najpierw silnik JS sprawdza bieÅ¼Ä…cy zakres leksykalny funkcji, wykonywanego kodu. JeÅ›li zmienna nie zostanie w nim odnaleziona, sprawdza kolejny zakres zewnÄ™trzny i kontynuuje sprawdzanie tak dÅ‚ugo aÅ¼ znajdzie szukanÄ… zmiennÄ… lub dotrze do zakresu globalnego. W tym momencie jeÅ›li zmienna nie zostaÅ‚a odnaleziona zgÅ‚aszany jest bÅ‚Ä…d.</p>

        <pre class="article__code">
        <code>
    let someString = null;
    let anotherString = null;

    function globalFunction() {
      let someString = 'Hello';

      function internalFunction1() {
        let anotherString = 'Word';
        console.group('internalFunction1');
        console.log(someString);
        console.log(anotherString);
        console.groupEnd();
      }

      function internalFunction2() {
        console.group('internalFunction2');
        console.log(someString);
        console.log(anotherString);
        console.groupEnd();
      }

      console.group('globalFunction');
      console.log(someString);
      console.log(anotherString);
      console.groupEnd();
      internalFunction1();
      internalFunction2();
    }

    globalFunction();

    /*
    globalFunction
      Hello
      null
    internalFunction1
      Hello
      Word
    internalFunction2
      Hello
      null
    */
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">DomkniÄ™cia</h3>

        <p class="article__paragraph">Funkcje w JavaScript sÄ… wartoÅ›ciami pierwszej klasy co oznacza, Å¼e mogÄ… byÄ‡ przekazywane i zwracane przez inne funkcje.</p>

        <p class="article__paragraph">DomkniÄ™cia pozwalajÄ… nam na dostÄ™p do zmiennych zadeklarowanych w zakresie leksykalnym funkcji nawet gdy wywoÅ‚amy danÄ… funkcjÄ™ poza jej zakresem leksykalnym.</p>

        <pre class="article__code">
        <code>
    function globalFunction() {
      let myName = 'Tomasz';

      function internalFunction() {
        return `CzeÅ›Ä‡, ${myName}!`;
      }
      return internalFunction;
    }

    let sayHello = globalFunction();
    console.log(sayHello()); // CzeÅ›Ä‡, Tomasz!
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyÅ¼szym przykÅ‚adzie funkcji <strong class="bold">sayHello</strong> przypisujemy wynik wykonania funkcji <strong class="bold">globalFunction</strong>. PoniewaÅ¼ <strong class="bold">globalFunction</strong> zwraca nam funkcjÄ™ wewnÄ™trznÄ… <strong class="bold">internalFunction</strong>. Zatem funkcja <strong class="bold">sayHello</strong> jest referencjÄ… do funkcji <strong class="bold">internalFunction</strong>.</p>

        <p class="article__paragraph">W tym momencie moÅ¼emy wywoÅ‚aÄ‡ funkcjÄ™ wewnÄ™trznÄ… za pomocÄ… <strong class="bold">sayHello()</strong>, poza jej zakresem leksykalnym, mimo, Å¼e funkcja <strong class="bold">globalFunction</strong> zostaÅ‚a juÅ¼ wykonana nadal mamy dostÄ™p do jej zmiennej <strong class="bold">myName</strong>. WÅ‚aÅ›nie na tym polega mechanizm domkniÄ™cia.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">IIFE</h3>

        <p class="article__paragraph">To skrÃ³t od Immediately Invoked Function Expression, sÄ… to funkcje anonimowe, ktÃ³re sÄ… wywoÅ‚ywane zaraz po ich deklaracji.</p>

        <pre class="article__code">
        <code>
    let getMyName = (function() {
        let myName = 'Tomasz';
        return myName;
    })();

    console.log(getMyName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyÅ¼szym przykÅ‚adzie aby wykonaÄ‡ funkcjÄ™ natychmiast po jej deklaracji bierzemy jÄ… w dodatkowy nawias, a nastÄ™pnie dodajemy parÄ™ pustych nawiasÃ³w na jej koÅ„cu. Tak samo jak wywoÅ‚ujemy zwykÅ‚a funkcjÄ™.</p>

        <p class="article__paragraph">IIFE sÄ… wykorzystywane we wzorcu moduÅ‚u, ktÃ³ry pozwala nam na zgrupowanie podobnej funkcjonalnoÅ›ci w jednym obiekcie oraz na stworzenie prywatnych zmiennych, ktÃ³re mogÄ… byÄ‡ modyfikowane jedynie za poÅ›rednictwem udostÄ™pnionych przez nas metod.</p>

        <pre class="article__code">
        <code>
    const myModule = (function () {
      let myName = 'Tomasz';
      let myAge = 29;

      return {
        increaseMyAge: function() {
          return myAge += 1;
        },
        getMyAge: function() {
          return myAge;
        }
      };
    })();
    console.log(myModule.myName); // undefined
    console.log(myModule.myAge); // undefined
    myModule.increaseMyAge();
    console.log(myModule.getMyAge()); // 30
        </code>
      </pre>
      </section>

    </article>


    <!-- Article 14 -->


    <article class="article">

      <header id="Funkcje_cz3" class="article__header">
        <div class="decor">14</div>
        <h2 class="article__title">Funkcje cz.3</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Funkcje strzaÅ‚kowe</h3>

        <p class="article__paragraph">W ES6 zostaÅ‚y wprowadzone funkcje strzaÅ‚kowe. MajÄ… krÃ³tszÄ… skÅ‚adnie, dziÄ™ki czemu idealnie nadajÄ… siÄ™ do stosowania jako wyraÅ¼enia zwrotne (o nich w dalszej czÄ™Å›ci tego wpisu) . SÄ… bardziej czytelne niÅ¼ standardowe funkcje przy prostych operacjach. Dodatkowo nie majÄ… wiÄ…zania <strong class="bold">this</strong>. MoÅ¼emy je tylko tworzyÄ‡ jako wyraÅ¼enia funkcyjne, nie podlegajÄ… wiÄ™c wynoszeniu.</p>

        <pre class="article__code">
        <code>
    (parametr1, parametr2, itd.) =&gt; { return wynik; }
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy pomijamy sÅ‚owo kluczowe <strong class="bold">function</strong>, dodajemy natomiast strzaÅ‚kÄ™ za nawiasami z parametrami funkcji. NastÄ™pnie tworzymy ciaÅ‚o funkcji w nawiasach klamrowych.</p>

        <pre class="article__code">
        <code>
    const mathOperation = (a, b, c) =&gt; {
      if (c &gt; 0) {
        return a + b;
      }
      return a - b;
    };
        </code>
      </pre>

        <p class="article__paragraph">W przypadku gdy nasza funkcja przyjmuje tylko jeden parametr i jej jedynym zadaniem jest zwrÃ³ciÄ‡ nam wynik. MoÅ¼emy uproÅ›ciÄ‡ nasz zapis jeszcze bardziej i pominÄ…Ä‡ nawiasy na okoÅ‚o parametrÃ³w oraz nawiasy klamrowe ciaÅ‚a funkcji i sÅ‚owo kluczowe <strong class="bold">return</strong>.</p>

        <pre class="article__code">
        <code>
    const greetings = name =&gt; `CzeÅ›Ä‡ ${name}!`;
    console.log(greetings('Tomasz')); // CzeÅ›Ä‡ Tomasz!

    const difference = (a, b) =&gt; a - b;
    console.log(difference(10, 4)); // 6
        </code>
      </pre>

        <p class="article__paragraph">Brak wiÄ…zania <strong class="bold">this</strong>. Na temat sÅ‚owa kluczowego <strong class="bold">this</strong> napisaÅ‚em juÅ¼ wpis, ktÃ³ry moÅ¼na przeczytaÄ‡ <a class="article__link" target="_blank" href="http://blog.tomasz-rybacki.pl/javascript/this/">tutaj</a>. W odniesieniu do funkcji strzaÅ‚kowych sÅ‚owo <strong class="bold">this</strong> odnosi siÄ™ do zakresu nadrzÄ™dnego funkcji lub zakresu globalnego.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WyraÅ¼enia zwrotne</h3>

        <p class="article__paragraph">W poprzednim wpisie wspomniaÅ‚em, Å¼e do funkcji moÅ¼emy przekazywaÄ‡ rÃ³wnieÅ¼ inne funkcje jako parametry. WÅ‚aÅ›nie takie funkcje nazywamy wyraÅ¼eniami zwrotnymi (ang. callback). Mamy dostÄ™pnych wiele wbudowanych metod, ktÃ³re przyjmujÄ… inne funkcje jako parametry. Jako przykÅ‚ad weÅºmy funkcjÄ™ <strong class="bold">setTimeout</strong>.</p>

        <pre class="article__code">
        <code>
    window.setTimeout(callback, opÃ³Åºnienie)
        </code>
      </pre>

        <p class="article__paragraph">Funkcja ta wykonuje dostarczonÄ… przez nas funkcjÄ™ po upÅ‚ywie okreÅ›lonej liczby milisekund.</p>

        <pre class="article__code">
        <code>
    function printMessage() {
      console.log('ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.');
    }
    window.setTimeout(printMessage, 1000);

    // ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy rÃ³wnieÅ¼ wykorzystaÄ‡ wÅ‚aÅ›nie poznane przez nas funkcje strzaÅ‚kowe, zamiast deklarowania oddzielnej funkcji <strong class="bold">printMessage</strong>, moÅ¼emy przekazaÄ‡ anonimowÄ… funkcjÄ™ strzaÅ‚kowÄ… zapisanÄ… wprost w metodzie <strong class="bold">setTimeout</strong>.</p>


        <pre class="article__code">
        <code>
    window.setTimeout(() =&gt; {
      console.log('ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.')
    }, 1000);

    // ZostaÅ‚am wykonana po upÅ‚ywie 1 sekundy.
        </code>
      </pre>

        <p class="article__paragraph">MoÅ¼emy teÅ¼ pisaÄ‡ wÅ‚asne funkcje, ktÃ³re przyjmujÄ… inne funkcje jako parametry.</p>

        <pre class="article__code">
        <code>
    function randomBetween(callback, min, max) {
      const randomNumber = Math.floor(Math.random() * (max - min + 1) + min);
      callback(randomNumber);
    }

    randomBetween((number) =&gt; {
      console.log(`WylosowanÄ… liczbÄ… jest ${number}!`);
    }, 10, 20);
    // WylosowanÄ… liczbÄ… jest 12!
        </code>
      </pre>

        <p class="article__paragraph"> W powyÅ¼szym przykÅ‚adzie funkcja randomBetween losujÄ™ liczbÄ™ z podanego przedziaÅ‚u. Jako pierwszy argument przyjmuje funkcjÄ™, ktÃ³ra wyÅ›wietla wiadomoÅ›Ä‡. Kolejne dwa argumenty okreÅ›lajÄ… do jakiego przedziaÅ‚u ma naleÅ¼eÄ‡ wylosowana liczba. Widzimy, Å¼e funkcja zwrotna zostaje wywoÅ‚ana w ciele funkcji randomBetween z wylosowanÄ… wczeÅ›niej liczbÄ…. Liczba ta jest przekazywana do anonimowej funkcji strzaÅ‚kowej, ktÃ³ra nastÄ™pnie wyÅ›wietla jÄ… w konsoli naszej przeglÄ…darki.</p>
      </section>

    </article>


    <!-- Article 15 -->


    <article class="article">

      <header id="Objekty_cz1" class="article__header">
        <div class="decor">15</div>
        <h2 class="article__title">Obiekty cz.1</h2>
      </header>

      <p class="article__paragraph">W JavaScript prawie wszystko jest obiektem (funkcje, tablice, obiekty wbudowane). W kilku kolejnych wpisach opiszÄ™ w jaki sposÃ³b dziaÅ‚ajÄ… obiekty i na czym polega programowanie obiektowe w JS.</p>

      <p class="article__paragraph">Obiekty sÄ… kolekcjÄ… wartoÅ›ci skÅ‚adajÄ…cych siÄ™ z par <strong class="bold">nazwa: wartoÅ›Ä‡</strong>, sÅ‚uÅ¼Ä…cych do opisywania dowolnej rzeczy np. ludzi, samochodÃ³w, zwierzÄ…t itd.</p>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie obiektu</h3>

        <p class="article__paragraph">Najprostszym sposobem utworzenia pojedynczego obiektu jest opakowanie naszych par <strong class="bold">nazwa: wartoÅ›Ä‡</strong> w nawiasy klamrowe <strong class="bold">{}</strong>, jest to tak zwany literaÅ‚ obiektu. WartoÅ›ci przechowywane w obiekcie nazywamy <strong class="bold">wÅ‚aÅ›ciwoÅ›ciami</strong> natomiast funkcje przechowywane w obiekcie to <strong class="bold">metody</strong> tego obiektu.</p>

        <pre class="article__code">
        <code>
    const myFamilyHouse = {
      city: 'OstroÅ‚Ä™ka',
      inhabitants: 2,
      floors: 2,

      neighborhood: function () {
        return 'Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgieÅ‚ku.';
      }
    };
        </code>
      </pre>

        <p class="article__paragraph">PowyÅ¼szy obiekt opisujÄ…cy mÃ³j rodzinny dom ma 3 wÅ‚aÅ›ciwoÅ›ci: <strong class="bold">city, inhabitants, floors</strong>. Posiada teÅ¼ jednÄ… metodÄ™: <strong class="bold">neighborhood</strong>.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">DostÄ™p do wartoÅ›ci</h3>

        <p class="article__paragraph">Aby odczytaÄ‡ wartoÅ›Ä‡ wÅ‚aÅ›ciwoÅ›ci lub wywoÅ‚aÄ‡ metodÄ™ uÅ¼ywamy notacji z kropkÄ… lub notacji z nawiasami.</p>

        <pre class="article__code">
        <code>
    console.log(myFamilyHouse.city); // OstroÅ‚Ä™ka
    console.log(myFamilyHouse.floors); // 2

    console.log(myFamilyHouse.neighborhood());
    // Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgieÅ‚ku.

    console.log(myFamilyHouse['inhabitants']); // 2
    console.log(myFamilyHouse['neighborhood']())
    // Cicha i spokojna okolica. Idealna do odpoczynku od miejskiego zgieÅ‚ku.
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy w powyÅ¼szym przykÅ‚adzie notacja z kropkÄ… jest o wiele bardziej czytelna dlatego jest najczÄ™Å›ciej stosowana. Ma jednak swoje ograniczenia w postaci:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">nazwy wÅ‚aÅ›ciwoÅ›ci muszÄ… byÄ‡ znakami alfanumerycznymi (z uwzglÄ™dnieniem znakÃ³w _ i $)</li>
          <li class="unordered-list__item">nie mogÄ… zaczynaÄ‡ siÄ™ od cyfry</li>
          <li class="unordered-list__item">nie mogÄ… zawieraÄ‡ nazw zmiennych</li>
        </ul>

        <p class="article__paragraph">Natomiast w przypadku notacji z nawiasami moÅ¼emy uÅ¼ywaÄ‡:</p>

        <ul class="article__unordered-list">
          <li class="unordered-list__item">znaku spacji w nazwach</li>
          <li class="unordered-list__item">nazw zmiennych</li>
          <li class="unordered-list__item">cyfr na poczÄ…tku Å‚aÅ„cucha znakÃ³w</li>
        </ul>

        <p class="article__paragraph">Musimy pamiÄ™taÄ‡, Å¼e identyfikatory w notacji z nawiasami muszÄ… byÄ‡ wartoÅ›ciÄ… typu 'string' lub zmiennÄ…, ktÃ³ra zawiera wartoÅ›ci typu 'string'.</p>
      </section>


      <section class="article__section">
        <h3 class="article__section__title">Nadpisanie wartoÅ›ci</h3>

        <p class="article__paragraph">Aby zmieniÄ‡ istniejÄ…cÄ… wartoÅ›Ä‡ lub dodaÄ‡ nowÄ…, stosujemy zwykÅ‚e przypisanie. Obiekty sÄ… modyfikowalne (mutable data), w kaÅ¼dej chwili moÅ¼emy modyfikowaÄ‡ ich zawartoÅ›Ä‡. JeÅ›li obiekt zawiera juÅ¼ podany klucz jego wartoÅ›Ä‡ zostanie nadpisana, w przeciwnym razie zostanie on dodany do naszego obiektu.</p>

        <pre class="article__code">
        <code>
    myFamilyHouse.garden = true;
    myFamilyHouse.inhabitants = 3;

    myFamilyHouse.income = function () {
      return myFamilyHouse.inhabitants * 1000;
    };

    console.log(myFamilyHouse.income()); // 3000
    console.log(myFamilyHouse);
    // { city: "OstroÅ‚Ä™ka", inhabitants: 3, floors: 2, neighborhood: Æ’, garden: true, income: Æ’ }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Usuwanie wÅ‚aÅ›ciwoÅ›ci i metod</h3>

        <p class="article__paragraph">Aby pozbyÄ‡ siÄ™ wÅ‚aÅ›ciwoÅ›ci lub metody korzystamy z operatora <strong class="bold">delete</strong>.</p>

        <pre class="article__code">
        <code>
    delete myFamilyHouse.garden;
    delete myFamilyHouse.income;

    console.log(myFamilyHouse);
    // { city: "OstroÅ‚Ä™ka", inhabitants: 3, floors: 2, neighborhood: Æ’ }
        </code>
      </pre>

        <p class="article__paragraph">W tym momencie omÃ³wiliÅ›my podstawy funkcjonowania obiektÃ³w. Wystarczy na dzisiaj, wiedza przyswajana w maÅ‚ych dawkach lepiej siÄ™ wchÅ‚ania ğŸ™‚</p>
      </section>
    </article>



    <!-- Article 16 -->


    <article class="article">

      <header id="Objekty_cz2" class="article__header">
        <div class="decor">16</div>
        <h2 class="article__title">Obiekty cz.2</h2>
      </header>

      <p class="article__paragraph">Dzisiejszy wpis nie naleÅ¼y do najÅ‚atwiejszych dlatego warto przeczytaÄ‡ go kilkukrotnie i samemu przeÄ‡wiczyÄ‡ w edytorze. BÄ™dzie za to ciekawie, poniewaÅ¼ poznamy podstawowy mechanizm dziaÅ‚ania jÄ™zyka JavaScript.</p>

      <section class="article__section">
        <h3 class="article__section__title">Konstruktory</h3>

        <p class="article__paragraph">SÄ… to zwyczajne funkcje, ktÃ³rych nazwÄ™ piszemy z wielkiej litery (jest to ogÃ³lnie przyjÄ™ta konwencja). PozwalajÄ… nam tworzyÄ‡ wiele podobnych do siebie obiektÃ³w (o tych samych wÅ‚aÅ›ciwoÅ›ciach i metodach). Konstruktor moÅ¼emy sobie wyobraziÄ‡ jako formÄ™ do ciastek, przy pomocy ktÃ³rej wyciskamy wiele podobnych ciasteczek. KaÅ¼de z powstaÅ‚ych ciasteczek jest nowÄ… instancjÄ… obiektu. Czyli samodzielnym obiektem, ktÃ³ry powstaÅ‚ na bazie danego konstruktora.</p>

        <pre class="article__code">
        <code>
    function User(name, age, location) {
      this.name = name;
      this.age = age;
      this.location = location;

      this.greetings = function () {
        console.log(`Witaj ${this.name}, dobrze ciÄ™ widzieÄ‡!`);
      };
    }

    const user1 = new User('Tomasz', 29, 'Poland');
    const user2 = new User('Daniel', 26, 'Poland');

    user1.greetings(); // Witaj Tomasz, dobrze ciÄ™ widzieÄ‡!
    console.log(user1);
    // {name: "Tomasz", age: 29, location: "Poland", greetings: Æ’}
        </code>
      </pre>

        <p class="article__paragraph">W powyÅ¼szym przykÅ‚adzie utworzyliÅ›my funkcjÄ™ konstruktora o nazwie <strong class="bold">User</strong>, nastÄ™pnie przy jej pomocy stworzyliÅ›my dwÃ³ch uÅ¼ytkownikÃ³w. Aby to zrobiÄ‡ korzystamy z operatora <strong class="bold">new</strong>. DziaÅ‚a on w nastÄ™pujÄ…cy sposÃ³b:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Tworzy nowy pusty obiekt, ktÃ³ry dziedziczy po <strong class="bold">User.prototype</strong></li>
          <li class="ordered-list__item">Sprawia, Å¼e <strong class="bold">this</strong> odnosi siÄ™ do nowo utworzonego obiektu.</li>
          <li class="ordered-list__item">Ustawia jaki konstruktor zostaÅ‚ uÅ¼yty do utworzenia obiektu.</li>
          <li class="ordered-list__item">Na koniec zwraca nam referencjÄ™ do nowo utworzonego obiektu, ktÃ³ry jest zapisywany w naszej zmiennej np. <strong class="bold">user1</strong>.</li>
        </ol>

        <p class="article__paragraph">Adnotacja do punktu nr 3. DziÄ™ki temu moÅ¼emy sprawdziÄ‡ czy dany obiekt zostaÅ‚ stworzony za pomocÄ… danego konstruktora.</p>

        <pre class="article__code">
        <code>
    const user3 = {
      name: 'Marcin',
      age: 29,
      location: 'Cuba'
    };

    console.log(user1 instanceof User); // true
    console.log(user3 instanceof User); // false
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Prototypy i dziedziczenie</h3>

        <p class="article__paragraph">Model obiektowy jÄ™zyka JavaScript bazuje na prototypach. Wszystkie obiekty, ktÃ³re tworzymy powstajÄ… na bazie innych obiektÃ³w. UmoÅ¼liwia to dziedziczenie wÅ‚aÅ›ciwoÅ›ci i metod po innych obiektach. Prototypem nazywamy obiekt po ktÃ³rym sÄ… dziedziczone wÅ‚aÅ›ciwoÅ›ci i metody.</p>

        <p class="article__paragraph">MoÅ¼emy to sobie wyobraziÄ‡ jako drzewo, gdzie pniem jest prototyp obiektu <strong class="bold">Object</strong>, to na jego podstawie powstajÄ… wszystkie inne obiekty, ktÃ³re tworzÄ… strukturÄ™ rozgaÅ‚Ä™zieÅ„ niczym w prawdziwym drzewie. Prototyp <strong class="bold">Object</strong> zawiera podstawowe metody, ktÃ³re dziedziczÄ… wszystkie inne obiekty, dziÄ™ki ktÃ³rym funkcjonuje nasz system obiektÃ³w.</p>

        <pre class="article__code">
        <code>
    console.log(user3)

    //  {name: "Marcin", age: 29, location: "Cuba"}
    //  age: 29
    //  location: "Cuba"
    //  name: "Marcin"
    //  __proto__:
    //      constructor: Æ’ Object()
    //      hasOwnProperty: Æ’ hasOwnProperty()
    //      isPrototypeOf: Æ’ isPrototypeOf()
    //      propertyIsEnumerable: Æ’ propertyIsEnumerable()
    //      toLocaleString: Æ’ toLocaleString()
    //      toString: Æ’ toString()
    //      valueOf: Æ’ valueOf()
    //      __defineGetter__: Æ’ __defineGetter__()
    //      __defineSetter__: Æ’ __defineSetter__()
    //      __lookupGetter__: Æ’ __lookupGetter__()
    //      __lookupSetter__: Æ’ __lookupSetter__()
    //      get __proto__: Æ’ __proto__()
    //      set __proto__: Æ’ __proto__()
        </code>
      </pre>

        <p class="article__paragraph">W powyÅ¼szym przykÅ‚adzie widzimy, Å¼e nasz obiekt user3 ma dostÄ™pne metody takie jak np: hasOwnProperty, toString, valueOf itd. Wszystkie te metody zostaÅ‚y odziedziczone po jego prototypie i mamy do nich dostÄ™p z poziomu obiektu user3.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Jak dziaÅ‚a dziedziczenie ?</h3>

        <p class="article__paragraph">Chcemy ulepszyÄ‡ nasz wczeÅ›niejszy kod i przenieÅ›Ä‡ metodÄ™ greetings wyÅ¼ej w naszym Å‚aÅ„cuchu prototypÃ³w. Nie ma potrzeby, Å¼eby kaÅ¼dy z naszych obiektÃ³w uÅ¼ytkownikÃ³w miaÅ‚ swojÄ… wÅ‚asnÄ… metodÄ™ powitania. DuÅ¼o lepszym rozwiÄ…zaniem jest utworzenie jednej metody greetings, z ktÃ³rej bÄ™dzie mÃ³gÅ‚ korzystaÄ‡ kaÅ¼dy z uÅ¼ytkownikÃ³w.</p>

        <pre class="article__code">
        <code>
    function User(name, age, location) {
      this.name = name;
      this.age = age;
      this.location = location;
    }

    User.prototype.greetings = function () {
        console.log(`Witaj ${this.name}, dobrze ciÄ™ widzieÄ‡!`);
      };

    const user1 = new User('Tomasz', 29, 'Poland');
    const user2 = new User('Daniel', 26, 'Poland');

    user1.greetings(); // Witaj Tomasz, dobrze ciÄ™ widzieÄ‡!
    user2.greetings(); // Witaj Daniel, dobrze ciÄ™ widzieÄ‡!

    console.log(user1); // {name: "Tomasz", age: 29, location: "Poland"}
    console.log(Object.getPrototypeOf(user1)); // {greetings: Æ’, constructor: Æ’}
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy powyÅ¼ej, obiekt <strong class="bold">user1</strong> nie ma wÅ‚asnej metody <strong class="bold">greetings</strong>. Mimo to moÅ¼e jÄ… wywoÅ‚aÄ‡. Dzieje siÄ™ tak poniewaÅ¼ odziedziczyÅ‚ jÄ… po swoim prototypie. W chwili wywoÅ‚ania tej metody JavaScript sprawdza czy istnieje ona w danym obiekcie. JeÅ›li nie zostaÅ‚a znaleziona, nastÄ™puje przesuniÄ™cie siÄ™ w dÃ³Å‚ naszej gaÅ‚Ä™zi do prototypu danego obiektu. JeÅ›li i tu nie zostaÅ‚a odnaleziona caÅ‚y proces siÄ™ powtarza, aÅ¼ do momentu znalezienia metody lub dotarcia do pnia naszego drzewa jakim jest obiekt <strong class="bold">Object</strong>. JeÅ›li i tu nie zostaje znaleziona nasza metoda, zgÅ‚aszany jest bÅ‚Ä…d.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">PrzesÅ‚anianie prototypu</h3>

        <p class="article__paragraph">PoniewaÅ¼ JS zaczyna sprawdzanie od obiektu, ktÃ³ry wywoÅ‚aÅ‚ danÄ… metodÄ™, moÅ¼emy utworzyÄ‡ w nim jego wÅ‚asnÄ… metodÄ™ o tej samej nazwie i tym samym przesÅ‚oniÄ‡ metodÄ™, ktÃ³ra juÅ¼ istnieje w Å‚aÅ„cuchu prototypÃ³w.</p>

        <pre class="article__code">
        <code>
    user1.greetings = function () {
      console.log(`Witaj ponownie ${this.name}, jak siÄ™ dzisiaj masz ?`);
    };

    user1.greetings(); // Witaj ponownie Tomasz, jak siÄ™ dzisiaj masz ?
    user2.greetings(); // Witaj Daniel, dobrze ciÄ™ widzieÄ‡!
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e <strong class="bold">user1</strong> ma swoje wÅ‚asne powitanie, ktÃ³re nie wpÅ‚ynÄ™Å‚o na uÅ¼ytkownika <strong class="bold">user2</strong>.</p>

        <p class="article__paragraph">JeÅ›li chcemy dodaÄ‡ kilka rzeczy naraz do prototypu, moÅ¼emy to zrobiÄ‡. PrzypisujÄ…c obiekt do prototypu. Musimy tylko pamiÄ™taÄ‡, Å¼e w takim przypadku musimy rÄ™cznie dodaÄ‡ wÅ‚aÅ›ciwoÅ›ci <strong class="bold">constructor</strong> do naszego prototypu.</p>

        <pre class="article__code">
        <code>
    User.prototype = {
      constructor: User, // UWAGA! - zawsze samemu ustawiamy tÄ… wÅ‚aÅ›ciwoÅ›Ä‡
      greetings: function () {
        console.log(`Witaj ${this.name}, dobrze ciÄ™ widzieÄ‡!`);
      },
      farewell: function () {
        console.log(`DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia ${this.name}`);
      }
    };
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Prototypy sÄ… dynamiczne</h3>

        <p class="article__paragraph">Oznacza to, Å¼e wszystkie obiekty utworzone na podstawie danego prototypu, te utworzone przed jak i po modyfikacji prototypu (np. dodanie nowej metody) majÄ… dostÄ™p do wszystkich jego wÅ‚aÅ›ciwoÅ›ci i metod.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Tworzenie Å‚aÅ„cucha prototypÃ³w</h3>

        <p class="article__paragraph">ZaÅ‚Ã³Å¼my, Å¼e chcemy utworzyÄ‡ nastÄ™pujÄ…cy Å‚aÅ„cuch <strong class="bold">Object -&gt; Human -&gt; User</strong>. KaÅ¼dy Å‚aÅ„cuch budujemy od bardziej ogÃ³lnej koncepcji do bardziej szczegÃ³Å‚owej. Na poczÄ…tku mamy wiÄ™c ogÃ³lne pojÄ™cie obiektu zdefiniowane przez sam jÄ™zyk JS. PÃ³Åºniej tworzymy obiekt CzÅ‚owieka, jest to dosyÄ‡ ogÃ³lna kategoria. NastÄ™pnie podkategoriÄ… CzÅ‚owieka moÅ¼e byÄ‡ UÅ¼ytkownik.</p>

        <pre class="article__code">
        <code>
    function Human() {}

    Human.prototype = {
      constructor: Human,
      greetings: function () {
        console.log(`Witaj ${this.login}, dobrze ciÄ™ widzieÄ‡!`);
      },
      farewell: function () {
        console.log(`DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia ${this.login}`);
      }
    };

    function User(login, email) {
      this.login = login;
      this.email = email;
    }

    User.prototype = Object.create(Human.prototype); // Tutaj nastÄ™puje poÅ‚Ä…czenie prototypÃ³w
    User.prototype.constructor = User; // UWAGA! - ustawiamy rÄ™cznie

    const user1 = new User('Tomasz', 'example@gmail.com');
    const human1 = new Human();

    user1.greetings(); // Witaj Tomasz, dobrze ciÄ™ widzieÄ‡!

    console.log(human1 instanceof User); // false
    console.log(user1 instanceof Human); // true
    console.log(user1 instanceof User); // true
        </code>
      </pre>

        <p class="article__paragraph">Przy pomocy <strong class="bold">Object.create()</strong>, tworzymy nowy obiekt, powstaje on na podstawie istniejÄ…cego i wybranego przez nas obiektu prototypu.</p>
      </section>
    </article>


    <!-- Article 17 -->


    <article class="article">

      <header id="Klasy" class="article__header">
        <div class="decor">17</div>
        <h2 class="article__title">Klasy</h2>
      </header>

      <p class="article__paragraph">W ES6 wprowadzono nowÄ… skÅ‚adnie <strong class="bold">class</strong>, jest to ukÅ‚on w stronÄ™ osÃ³b, ktÃ³re na co dzieÅ„ programujÄ… w jÄ™zykach opartych o klasy jak np. Java. DziÄ™ki temu nie muszÄ… uczyÄ‡ siÄ™ bardziej ogÃ³lnej koncepcji prototypÃ³w i dziedziczenia. MogÄ… od razu zaczÄ…Ä‡ pisaÄ‡ programy, w oparciu o to co dobrze znajÄ… i czego uÅ¼ywali na co dzieÅ„ do tej pory.</p>

      <p class="article__paragraph">Nie zmienia to mechanizmu w jaki dziaÅ‚a JavaScript. Wszystko to co poznaliÅ›my w poprzednim wpisie nadal funkcjonuje i dzieje siÄ™ pod pÅ‚aszczykiem nowej skÅ‚adni, ktÃ³rÄ… poznamy dzisiaj.</p>

      <section class="article__section">
        <h3 class="article__section__title">class</h3>

        <p class="article__paragraph">Klasy sÄ… specjalnymi funkcjami, ktÃ³re zawierajÄ… w swoim ciele konstruktor i metody dodawane do prototypu. DziÄ™ki temu mamy wszystko Å‚adnie pogrupowane. StwÃ³rzmy podobny przykÅ‚ad do tego z poprzedniego wpisu.</p>

        <pre class="article__code">
        <code>
    class Human {
      constructor(name) {
        this.name = name;
      }

      greetings() {
        console.log(`Witaj ${this.login || this.name}, dobrze ciÄ™ widzieÄ‡!`);
      }

      farewell() {
        console.log(`DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia ${this.login || this.name}.`);
      }
    }

    class User extends Human {
      constructor(name, login, email) {
        super(name);
        this.login = login;
        this.email = email;
      }
    }

    const user1 = new User('Tomasz', 'Tom89', 'TomaszRybacki1989@gmail.com');

    console.log(user1);
    // {name: "Tomasz", login: "Tom89", email: "TomaszRybacki1989@gmail.com"}

    user1.greetings(); // Witaj Tom89, dobrze ciÄ™ widzieÄ‡!
    user1.farewell(); // DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia Tom89.
        </code>
      </pre>

        <p class="article__paragraph">Widzimy, Å¼e nasz kod jest teraz o wiele bardziej czytelny. Nasza funkcja konstruktora jest zawarta wewnÄ…trz klasy. Dodatkowo sÅ‚owo kluczowe <strong class="bold">extends</strong> wyraÅºnie pokazuje zaleÅ¼noÅ›Ä‡ pomiÄ™dzy obiektami. Å»eby odwoÅ‚aÄ‡ siÄ™ do kodu konstruktora z klasy wyÅ¼szej i go rozszerzyÄ‡, uÅ¼ywamy sÅ‚owa kluczowego <strong class="bold">super()</strong>, w nawiasach podajÄ…c argumenty z jakimi chcemy go wywoÅ‚aÄ‡.</p>

        <p class="article__paragraph">OczywiÅ›cie caÅ‚y mechanizm dziaÅ‚ania pozostaje taki sam, moÅ¼emy nadal nadpisaÄ‡ odziedziczone metody i dodaÄ‡ nowe dostÄ™pne tylko w instancjach stworzonych przy uÅ¼yciu naszej klasy <strong class="bold">User</strong>.</p>

        <pre class="article__code">
        <code>
    class User extends Human {
      constructor(name, login, email) {
        super(name);
        this.login = login;
        this.email = email;
      }

      farewell() {
        console.log('MiÅ‚ego dnia.');
      }

      changeLogin() {
        console.log('TwÃ³j login zostaÅ‚ zmieniony.');
      }
    }

    const user1 = new User('Tomasz', 'Tom89', 'TomaszRybacki1989@gmail.com');
    const human1 = new Human('Daniel');

    user1.greetings(); // Witaj Tom89, dobrze ciÄ™ widzieÄ‡!
    user1.farewell(); // MiÅ‚ego dnia.
    user1.changeLogin(); // TwÃ³j login zostaÅ‚ zmieniony.

    human1.greetings(); // Witaj Daniel, dobrze ciÄ™ widzieÄ‡!
    human1.farewell(); // DziÄ™kujemy, Å¼e nas odwiedziÅ‚eÅ›. Do zobaczenia Daniel.
    human1.changeLogin(); // TypeError
        </code>
      </pre>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wynoszenie</h3>

        <p class="article__paragraph">IstotnÄ… rÃ³Å¼nicÄ… pomiÄ™dzy zwykÅ‚Ä… funkcjÄ… a klasÄ… jest to, Å¼e klasy nie sÄ… wynoszone na poczÄ…tek naszego skryptu. Musimy je wiÄ™c najpierw zadeklarowaÄ‡ a dopiero potem ich uÅ¼ywaÄ‡.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Deklaracja klasy i wyraÅ¼enie klasy</h3>

        <p class="article__paragraph">PowyÅ¼szy przykÅ‚ad zawiera deklaracjÄ™ klasy czyli:</p>

        <pre class="article__code">
        <code>
    class Human {}
        </code>
      </pre>

        <p class="article__paragraph">Tak samo jak w przypadku funkcji moÅ¼emy przypisaÄ‡ jÄ… do zmiennej, tak samo moÅ¼emy postÄ…piÄ‡ z klasÄ…. WyraÅ¼enia klas mogÄ… byÄ‡ anonimowe lub nazwane.</p>

        <pre class="article__code">
        <code>
    const Human = class {};

    const Human = class Human {};
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Metody statyczne</h3>

        <p class="article__paragraph">SÄ… to metody dostÄ™pne tylko z poziomu klasy. Nie moÅ¼na siÄ™ do nich odwoÅ‚aÄ‡ za pomocÄ… instancji utworzonych przy pomocy tej klasy. SÅ‚uÅ¼Ä… przewaÅ¼nie do tworzenia metod pomocniczych.</p>

        <pre class="article__code">
        <code>
    class Human {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }

      static youngerHuman(a, b) {
        if (a.age &gt; b.age) {
          return b.name;
        }
        return a.name;
      }
    }

    class User extends Human {
      constructor(name, age, login, email) {
        super(name, age);
        this.login = login;
        this.email = email;
      }
    }

    const user1 = new User('Tomasz', 29, 'Tom89', 'TomaszRybacki1989@gmail.com');
    const user2 = new User('Marcin', 32, 'Martin86', 'example@gmail.com');

    const human1 = new Human('Daniel', 26);

    user1.youngerHuman(); // TypeError
    human1.youngerHuman(); // TypeError

    console.log(Human.youngerHuman(user1, user2)); // Tomasz
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 18 -->


    <article class="article">

      <header id="Obiekty_opakowujace" class="article__header">
        <div class="decor">18</div>
        <h2 class="article__title">Obiekty opakowujÄ…ce</h2>
      </header>

      <p class="article__paragraph">Teraz gdy poznaÅ‚eÅ› obiekty i typy proste w JavaScript. BÄ™dziesz mÃ³gÅ‚ z Å‚atwoÅ›ciÄ… zrozumieÄ‡ co siÄ™ dzieje w poniÅ¼szej sytuacji:</p>

      <pre class="article__code">
        <code>
    let myName = 'Tomasz';

    console.log(myName.indexOf('s')); // 4
    console.log(typeof myName); // string
        </code>
      </pre>

      <p class="article__paragraph">PatrzÄ…c na powyÅ¼szy kod, moÅ¼esz podrapaÄ‡ siÄ™ w gÅ‚owÄ™ i pomyÅ›leÄ‡. Co jest grane ? PrzecieÅ¼ przy pomocy notacji z kropkÄ… odwoÅ‚ujemy siÄ™ do metody obiektu. Ale w nastÄ™pnej linijce kodu widzimy wyraÅºnie, Å¼e zmienna <strong class="bold">myName</strong> przechowuje wartoÅ›Ä‡ typu prostego.</p>

      <section class="article__section">
        <h3 class="article__section__title">Opakowanie przez silnik JS</h3>

        <p class="article__paragraph">RozwiÄ…zanie tej zagadki jest proste. Oto co siÄ™ wydarzyÅ‚o za kurtynÄ…:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Za kaÅ¼dym razem gdy chcemy wywoÅ‚aÄ‡ metodÄ™ na wartoÅ›ci typu prostego zostaje ona â€po cichuâ€ opakowana przy pomocy obiektu.</li>
          <li class="ordered-list__item">NastÄ™pnie zostaje wywoÅ‚ana nasza metoda.</li>
          <li class="ordered-list__item">Gdy tylko otrzymamy wynik jej dziaÅ‚ania nasz obiekt opakowujÄ…cy jest niszczony.</li>
        </ol>

        <p class="article__paragraph">Teraz powyÅ¼szy przykÅ‚ad jest dla nas zrozumiaÅ‚y i logiczny. Otrzymane wartoÅ›ci sÄ… dokÅ‚adnie tym czego siÄ™ spodziewaliÅ›my. Opakowaniu ulegajÄ… wartoÅ›ci proste typu: string, number i boolean.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">WÅ‚asnorÄ™czne opakowanie</h3>

        <p class="article__paragraph">To co zostaÅ‚o zrobione â€po cichuâ€ przez silnik JS. MoÅ¼emy rÃ³wnieÅ¼ zrobiÄ‡ samemu przy uÅ¼yciu konstruktora.</p>

        <pre class="article__code">
        <code>
    let myName = new String('Tomasz');

    console.log(myName.indexOf('s')); // 4

    console.log(myName); // {"Tomasz"}
    console.log(typeof myName); // object

    let myAge = new Number(29);

    console.log(myAge); // {29}
    console.log(typeof myAge); // object

    let codingIsCool = new Boolean(true);

    console.log(codingIsCool); // {true}
    console.log(typeof codingIsCool); // object
        </code>
      </pre>

        <p class="article__paragraph">Jak widzimy nasza wartoÅ›Ä‡ pozostaje caÅ‚y czas zapakowana i sprawdzenie jej typu zwraca object. MoÅ¼emy teÅ¼ rÄ™cznie rozpakowaÄ‡ naszÄ… wartoÅ›Ä‡ wykorzystujÄ…c mechanizm konwersji typÃ³w.</p>

        <pre class="article__code">
        <code>
    myName = myName + '';

    console.log(myName); // Tomasz
    console.log(typeof myName); // string

    myAge = myAge + 0;

    console.log(myAge); // 29
    console.log(typeof myAge); // number

    codingIsCool = !!codingIsCool;

    console.log(codingIsCool); // true
    console.log(typeof codingIsCool); // boolean
        </code>
      </pre>

        <p class="article__paragraph">Teraz gdy wiemy na czym polega opakowywanie typÃ³w prostych. ZapamiÄ™tajmy Å¼eby nigdy nie robiÄ‡ tego samemu. Zawsze twÃ³rz wartoÅ›ci typu prostego w postaci literaÅ‚u!</p>
      </section>

    </article>


    <footer class="documentation__footer">
      <span class="footer__txt">designed &amp; coded with <span class="footer__icon">&#10084;</span> by <span class="footer__bold">&copy; Tomasz Rybacki</span> in 2018</span>
    </footer>
  </main>


  <script src="scripts/jquery-3.2.0.min.js"></script>
  <script src="scripts/code.js"></script>
</body>

</html>
