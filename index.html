<!DOCTYPE html>
<html lang="pl">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <meta name="author" content="Tomasz Rybacki">
  <meta name="description" content="Responsive Web Design Projects - Build a Technical Documentation Page">

  <title>Technical Documentation Page</title>
  <link rel="icon" type="image/png" sizes="96x96" href="img/favicon96x96.png">

  <link href="https://fonts.googleapis.com/css?family=Muli:400,700,700i&amp;subset=latin-ext" rel="stylesheet">
  <link rel="stylesheet" href="css/main.css">

</head>

<body class="body">

  <button class="menu" id="menu-button">
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
    <span class="menu-bar"></span>
  </button>

  <nav id="navbar" class="navigation">
    <header class="navigation__header">
      <h1 class="header__title">Kurs JavaScript</h1>
    </header>
    <ol class="navigation__list">
      <li class="nav-item"><a class="nav-link" href="#01._Czym_jest_javaScript_?">01. Czym jest javaScript ?</a></li>
      <li class="nav-item"><a class="nav-link" href="#02._Debugowanie_cz.1">02. Debugowanie cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#03._Debugowanie_cz.2">03. Debugowanie cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#04._Typy_wartości">04. Typy wartości</a></li>
      <li class="nav-item"><a class="nav-link" href="#05._Zmienne_cz.1">05. Zmienne cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#06._Zmienne_cz.2">06. Zmienne cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#07._Operatory">07. Operatory</a></li>
      <li class="nav-item"><a class="nav-link" href="#08._Konwersja_typów">08. Konwersja typów</a></li>
      <li class="nav-item"><a class="nav-link" href="#09._Instrukcje_warunkowe">09. Instrukcje warunkowe</a></li>
      <li class="nav-item"><a class="nav-link" href="#10._Tablice">10. Tablice</a></li>
      <li class="nav-item"><a class="nav-link" href="#11._Podstawowe_pętle">11. Podstawowe pętle</a></li>
      <li class="nav-item"><a class="nav-link" href="#12._Funkcje_cz.1">12. Funkcje cz.1</a></li>
      <li class="nav-item"><a class="nav-link" href="#13._Funkcje_cz.2">13. Funkcje cz.2</a></li>
      <li class="nav-item"><a class="nav-link" href="#14._Funkcje_cz.3">14. Funkcje cz.3</a></li>
      <li class="nav-item"><a class="nav-link" href="#15._Objekty_cz.1">15. Objekty cz.1</a></li>
    </ol>
  </nav>

  <div class="push"></div>

  <main id="main-doc" class="documentation">

    <header class="documentation__header">
      <img class="header__banner" src="img/JavaScript-banner.jpg" alt="banner javaScript">
      <span class="header__txt">Kurs ten powstał w ramach mojego <a class="blog-link" href="http://blog.tomasz-rybacki.pl">bloga</a>.<br> Zachęcam Cię do jego odwiedzenia oraz życzę owocnej nauki programowania w JavaScript.</span>
    </header>


    <!-- Article 01 -->


    <article class="article">

      <header id="Czym_jest_javaScript_?" class="article__header">
        <div class="decor">01</div>
        <h2 class="article__title">Czym jest javaScript ?</h2>
      </header>

      <p class="article__paragraph">W wikipedii czytamy, że jest to skryptowy język programowania. Wyjaśnijmy sobie co to oznacza.</p>

      <p class="article__paragraph">Programy napisane w tym języku nie wymagają kompilacji do kodu maszynowego, który jest zapisywany w postaci binarnej (same zera i jedynki). Kod ten jest bezpośrednio wykonywany przez procesor komputera. Zamiast tego nasze skrypty są wykonywane za pomocą interpretera, który analizuje każde wyrażenie przed jego wykonaniem.</p>

      <p class="article__paragraph">JavaScript jest językiem wysokiego poziomu co oznacza, że pisząc w nim nie przejmujemy się wszystkim tym co dzieje się „pod maską” jak: zarządzanie pamięcią, przechowywanie danych, wewnętrzne typy danych. Dzięki temu można dosyć szybko poznać jego podstawy i zacząć samodzielnie pisać skrypty. Używamy w nim abstrakcji do ukrycia technicznych detali. Kod piszemy przy pomocy angielskich słów, dzięki temu odczytywanie go jest proste, niczym czytanie instrukcji obsługi nowo zakupionego urządzenia AGD 🙂</p>

      <p class="article__paragraph">Skrypty, które w nim piszemy są wykonywane w całości od początku do końca. Z góry na dół, od lewej do prawej. Są to zasady, które wszyscy dobrze znamy i z których korzystamy na co dzień podczas czytania. Nasz kod JavaScript działa w pewnym środowisku. Może być to przeglądarka internetowa (na tym środowisku skupimy się w tym kursie) lub np. Node.js, w którym to możemy uruchamiać kod JavaScript po stronie serwera lub w wierszu poleceń naszego komputera. Od naszego środowiska zależy do jakich obiektów globalnych będziemy mieli dostęp. Z niego wynika zastosowanie naszego kodu. Mogą być to wszystkie interakcje użytkownika ze stroną internetową lub logika wykonywana po stronie serwera.</p>

      <p class="article__paragraph">Współczesne narzędzia jak silnik JavaScript V8 w Google Chrome, kompilują nasz kod w chwili wykonania. Pozwala to na jeszcze szybsze działanie naszych programów.</p>

      <p class="article__paragraph">Ciekawostką jest sama nazwa tego języka programowania. Początkowo nazywał się LiveScript, jednak na fali rosnącej popularności i sukcesu jakim cieszył się język Java. Został przemianowany na JavaScript. Został więc jego młodszym bratem i przedmiotem żartów. Ponieważ osoby kompletnie zielone często utożsamiają te dwa różne języki programowania ze sobą. Myśląc, że są tym samym.</p>

    </article>


    <!-- Article 02 -->


    <article class="article">

      <header id="Debugowanie_cz.1" class="article__header">
        <div class="decor">02</div>
        <h2 class="article__title">Debugowanie cz.1</h2>
      </header>


      <p class="article__paragraph">Dzisiaj skonfigurujemy nasz projekt, w którym będziemy uczyć się kolejnych zagadnień związanych z JavaScript. Powiemy sobie również na temat błędów i sposobów radzenia sobie z nimi. Zakładam, że masz już zainstalowanego Bracketsa oraz przeglądarkę Chrome.</p>

      <section class="article__section">
        <h3 class="article__section__title">Projekt</h3>
        <p class="article__paragraph">Tworzymy nowy folder do przechowywania naszych plików. Ja nazwałem swój <strong class="bold">Kurs.</strong> Wewnątrz tworzymy nowy folder scripts, w którym będą znajdować się wszystkie nasze skrypty. Tworzymy tam nowy plik o nazwie <strong class="bold">code.js.</strong> Teraz potrzebujemy utworzyć podstawowy plik html o nazwie <strong class="bold">index.html</strong> w folderze głównym.</p>

        <pre class="article__code">
        <code>
    &lt;!DOCTYPE html&gt;
    &lt;html lang="pl"&gt;

      &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;

        &lt;meta name="author" content="Tomasz Rybacki"&gt;
        &lt;meta name="description" content="Kurs JavaScript dla początkujących."&gt;

        &lt;title&gt;Kurs JavaScript&lt;/title&gt;
      &lt;/head&gt;

      &lt;body&gt;

        &lt;script src="scripts/code.js"&gt;&lt;/script&gt;
      &lt;/body&gt;

    &lt;/html&gt;
        </code>
      </pre>

        <p class="article__paragraph">Wewnątrz znacznika <strong class="bold">&lt;script&gt;</strong> umieszczamy ścieżkę dostępu do naszego pliku z kodem js. Znacznik ten umieszczamy zawsze na końcu naszego body tuż przed znacznikiem zamykającym <strong class="bold">&lt;/body&gt;</strong>. Robimy tak ponieważ nie chcemy żeby podczas wczytywania strony, ładujący się kod JavaScript blokował wyświetlanie pozostałej części strony. Sprawiając wrażenie wolnego działania strony i pozostawiając użytkownika z białym ekranem.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">ESLint</h3>
        <p class="article__paragraph">Pierwszym narzędziem jakie wykorzystamy do pisania kodu dobrej jakości będzie <a class="article__link" href="https://eslint.org" target="_blank">ESLint</a> ze zbiorem zasad airbnb-base. Narzędzie to pokazuje nam błędy jakie popełniliśmy oraz daje pomocne wskazówki, jeszcze przed uruchomieniem naszego kodu w przeglądarce.</p>

        <p class="article__paragraph">Żeby je zainstalować, najpierw potrzebujemy zainstalować <a class="article__link" href="https://nodejs.org/en/" target="_blank">Node.js.</a> Pobieramy i instalujemy wersję rekomendowaną dla większości użytkowników, w chwili pisania tego postu jest to wersja 8.11.1 LTS.</p>

        <p class="article__paragraph">Teraz uruchamiamy wiersz poleceń i za jego pomocą nawigujemy do folderu z naszym projektem. (Wszystkie moje polecenia są dla systemu operacyjnego Windows 10) W moim przypadku są to komendy:</p>

        <span class="article__command">E:</span>
        <span class="article__command">cd E:\11 Programowanie\Blog\Kurs</span>

        <p class="article__paragraph">Teraz inicjalizujemy plik package.json, za pomocą komendy:</p>

        <span class="article__command">npm init</span>

        <p class="article__paragraph">Wszystkie opcje zatwierdzamy enterem. Nie musimy nic wpisywać i zmieniać. Następnie instalujemy ESLint wpisując polecenie:</p>

        <span class="article__command">npm install –save-dev eslint eslint-config-airbnb eslint-plugin-import</span>

        <p class="article__paragraph">Teraz dodajemy plik o nazwie .eslintrc. Zawiera on ustawienia z jakich korzystamy w naszym projekcie.</p>

        <pre class="article__code">
        <code>
    {
        "extends": "airbnb-base",
        "parserOptions": {
        "ecmaVersion": 6
        },
        "env": {
        "node": true,
        "browser": true,
        "es6": true
        },
        "rules": {
        "comma-dangle": ["error", "never"],
        "no-unused-vars": ["error", {"vars": "local", "args": "none"}]
        }
    }
      </code>
      </pre>

        <p class="article__paragraph">Widzimy, że nasz zbiór zasad jest rozszerzeniem zasad opracowanych przez airbnb-base. Domyślnie ESLint wspiera tylko składnię ECMAScript 5, ponieważ zamierzamy korzystać również z wersji ECMAScript 6 dodajemy to możliwość w parserOptions. Nie przejmuj się jeśli nie wiesz co to oznacza. Wszystko wyjaśnimy w dalszej części kursu.</p>

        <p class="article__paragraph">„env” przechowuje środowiska w jakich będzie działał nasz kod. Natomiast „rules” zawiera nasze własne ustawienia obecnie obowiązujących zasad. Dodając tu kolejne pozycje, możemy wyłączyć lub zmienić status zgłaszanego błędu na ostrzeżenie lub na odwrót. Wszystkie rodzaje błędów i ich możliwą konfiguracje znajdziemy w dokumentacji ESLint.</p>

        <img class="article__img" src="img/Linter.jpg" alt="zrzut ekranu edytora Brackets">

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Nasze drzewko plików w projekcie powinno wyglądać tak.</li>
          <li class="ordered-list__item">Przykładowy kod, obok widzimy ikony wyświetlane przez ESLint zgłaszające ostrzeżenie i błąd w danej linijce kodu.</li>
          <li class="ordered-list__item">Za pomocą tej ikony włączamy i wyłączamy podgląd zgłoszonych błędów (okno nr 4)</li>
          <li class="ordered-list__item">Lista zgłoszonych błędów. Zaczynając od lewej mamy:
            <ul class="article__unordered-list">
              <li class="unordered-list__item">nr linii kodu z błędem</li>
              <li class="unordered-list__item">typ błędu i informację na jego temat</li>
              <li class="unordered-list__item">nazwę zasady podaną w nawiasie kwadratowym</li>
            </ul>
          </li>
        </ol>

        <p class="article__paragraph">Kod z tej lekcji można pobrać z <a class="article__link" href="https://github.com/TomaszRybacki/Kurs" target="_blank">GitHuba</a>.</p>
      </section>

    </article>


    <!-- Article 03 -->


    <article class="article">

      <header id="Debugowanie_cz.2" class="article__header">
        <div class="decor">03</div>
        <h2 class="article__title">Debugowanie cz.2</h2>
      </header>

      <p class="article__paragraph">Dzisiaj dokończymy temat radzenia sobie z błędami. Omówimy obiekt console, punkty kontrolne i typy pojawiających się błędów.</p>

      <section class="article__section">
        <h3 class="article__section__title">Obiekt console</h3>
      </section>

      <p class="article__paragraph">Przeglądarka internetowa Chrome ma wbudowaną konsolę JavaScript, możemy w niej pisać bezpośrednio kod js. Również w niej będą się nam wyświetlały wszystkie błędy jakie napotka interpreter. Będziemy mieli podaną nazwę błędu, jego opis i numer linii kodu, w którym wystąpił. Dzięki temu możemy szybko zlokalizować i poprawić występujące błędy.</p>

      <p class="article__paragraph">Aby ją otworzyć klikamy prawym przyciskiem myszy na stronie internetowej i wybieramy przycisk Zbadaj. Następnie przechodzimy do zakładki Console.</p>

      <img class="article__img" src="img/console.jpg" alt="zrzut ekranu konsoli w przeglądarce Chrome">

      <ol class="article__ordered-list">
        <li class="ordered-list__item">Pasek boczny konsoli. Klikając odpowiednio kategorię wyświetlamy tylko powiadomienia danego typu.</li>
        <li class="ordered-list__item">Konsola. To tutaj będą pojawiać się informacje o błędach z ich opisem. Również tutaj możemy pisać nasz kod JS oraz wyświetlać informacje za pomocą obiektu console.</li>
        <li class="ordered-list__item">Nazwa pliku oraz numer linii kodu z tego pliku, który generuje daną informację.</li>
      </ol>

      <p class="article__paragraph">Konsolę wykorzystujemy również do sprawdzania jakie wartości przyjmują nasze zmienne w danym fragmencie skryptu. Przyjrzyjmy się teraz metodom jakie zapewnia obiekt console. Najważniejsze z nich to:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.log()</strong> – służące do wyświetlania treści w konsoli</li>
      </ul>

      <p class="article__paragraph">Metoda ta ma trzy bliźniacze metody, które również wyświetlają nasz tekst w konsoli ale dodatkowo zapewniają stylowanie. Dzięki czemu możemy filtrować wyświetlane informacje i wyświetlać tylko te, które w danym momencie są dla nas istotne.</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.info()</strong> – wyświetla tekst jako informację</li>
        <li class="unordered-list__item"><strong class="bold">console.warn()</strong> – wyświetla tekst jako ostrzeżenie</li>
        <li class="unordered-list__item"><strong class="bold">console.error()</strong> – wyświetla tekst jako błąd</li>
      </ul>

      <p class="article__paragraph">Kolejną przydatną metodą jest:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.group(), console.groupCollapsed()</strong> – służy do grupowania wyświetlanych informacji pod wspólną etykietą, coś w stylu rozpoczynającego znacznika HTML</li>
        <li class="unordered-list__item"><strong class="bold">console.groupEnd()</strong> – zamyka naszą grupę, coś w stylu zamykającego znacznika HTML</li>
      </ul>

      <p class="article__paragraph">Oprócz tych podstawowych metod, mamy jeszcze kilka, które mogą być przydatne, oto one:</p>

      <ul class="article__unordered-list">
        <li class="unordered-list__item"><strong class="bold">console.assert()</strong> – sprawdza warunek, jeśli nie jest spełniony, dopiero wtedy wyświetla wiadomość do konsoli</li>
        <li class="unordered-list__item"><strong class="bold">console.count()</strong> – wyświetla ile razy zostało użyte wywołanie tej metody z daną etykietą. Taki zwykły licznik.</li>
        <li class="unordered-list__item"><strong class="bold">console.time() </strong> – rozpoczyna odliczanie czasu jaki minął od wywołania tej metody, dzięki temu możemy sprawdzić czas wykonania danego fragmentu naszego kodu</li>
        <li class="unordered-list__item"><strong class="bold">console.timeEnd()</strong> – kończy odliczanie czasu i wyświetla ile czasu (milisekund) upłynęło od jego rozpoczęcia</li>
      </ul>

      <strong class="bold">Przykład</strong>

      <pre class="article__code">
        <code>
    // Obiekt console

    console.time('Timer');
    console.count('Counter');

    console.group('names');
    console.info('Tomasz');
    console.warn('Daniel');
    console.error('Marcin');
    console.log('Adam');
    console.groupEnd();

    console.count('Counter');

    console.groupCollapsed('age');
    console.log(28);
    console.log(25);
    console.log(32);
    console.log(32);
    console.groupEnd();

    console.count('Counter');

    const myName = 777;
    console.assert(typeof myName === 'string', 'Niepoprawny typ zmiennej, oczekiwano wartości typu "string".');

    console.timeEnd('Timer');
        </code>
      </pre>

      <section class="article__section">
        <h3 class="article__section__title">Punkty kontrolne</h3>

        <p class="article__paragraph">Może się zdarzyć, że będziemy potrzebować przeanalizować jak działa nasz skrypt kawałek po wałku. W tym celu możemy wstawić słowo kluczowe debugger w każdym miejscu, w którym chcemy żeby nastąpiła pauza w wykonywaniu naszego skryptu. Następnie w zakładce Sources przeglądarki możemy przełączać się pomiędzy utworzonymi punktami kontrolnymi i obserwować w jaki sposób jest wykonywany nasz skrypt, jakie wartości przyjmują zmienne w danym miejscu i jaki jest stos wywołań.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Typy błędów</h3>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">SyntaxError – nieprawidłowa składnia np.: niedopasowane lub brakujące znaki cytowania, brakujące nawiasy, nieprawidłowe nazwy właściwości lub zmiennych</li>
          <li class="unordered-list__item">ReferenceError – zmienna nie istnieje np.: niezadeklarowana zmienna, niezdefiniowana nazwa funkcji</li>
          <li class="unordered-list__item">TypeError – nieoczekiwany typ danych np.: metoda nie istnieje, nieprawidłowa wielkość znaku w nazwie metody</li>
          <li class="unordered-list__item">RangeError – liczba spoza zakresu np.: nie można utworzyć tablicy zawierającej -x elementów</li>
          <li class="unordered-list__item">EvalError – nieprawidłowe użycie funkcji eval()</li>
          <li class="unordered-list__item">URIError – nieprawidłowe użycie funkcji URI</li>
        </ul>

        <p class="article__paragraph">Najbardziej interesują nas pierwsze cztery typy błędów bo to właśnie je będziemy spotykać najczęściej pisząc nasze programy.</p>
      </section>

    </article>


    <!-- Article 04 -->


    <article class="article">

      <header id="Typy_wartości" class="article__header">
        <div class="decor">04</div>
        <h2 class="article__title">Typy wartości</h2>
      </header>

      <p class="article__paragraph">W JavaScript mamy siedem typów wartości, są to:</p>

      <ol class="article__ordered-list">
        <li class="ordered-list__item">string</li>
        <li class="ordered-list__item">number</li>
        <li class="ordered-list__item">boolean</li>
        <li class="ordered-list__item">undefined</li>
        <li class="ordered-list__item">null</li>
        <li class="ordered-list__item">symbol</li>
        <li class="ordered-list__item">object</li>
      </ol>

      <p class="article__paragraph">Typ przechowywanej wartości możemy sprawdzić za pomocą polecenia <strong class="bold">typeof()</strong>. JS jest językiem dynamicznym, zmienne nie są związane z konkretnym typem danych jaki mogą przechowywać. To wartości przechowywane w zmiennych mają swój typ i mogą się zmieniać w trakcje wykonywania naszego programu. Dzięki czemu zmienna o nazwie <strong class="bold">name</strong> może przechowywać na początku liczbę (typ number), potem ciąg znaków (typ string), żeby ostatecznie zostać obiektem (typ object) na końcu działania naszego programu.</p>


      <section class="article__section">
        <h3 class="article__section__title">String</h3>
        <p class="article__paragraph">Jest to ciąg znaków tekstowych, który zapisujemy w cudzysłowie podwójnym lub pojedynczym lub za pomocą znaku apostrof (tego na klawiszu pod Esc). Ten typ służy do przechowywania informacji w postaci słów np.: „Życie to sztuka wyborów”, ‚Lubię się uczyć.’, `Kodowanie jest fajne.`. Wybór <strong class="bold">“ ”</strong> lub <strong class="bold">‘ ’</strong> należy do ciebie. Natomiast <strong class="bold">´ ´</strong> daje dodatkowe możliwości, o których powiemy w dalszych lekcjach kursu JS.</p>

        <p class="article__paragraph">String w JS jest niezmienny co oznacza, że po jego utworzeniu nie możemy go modyfikować. Możemy jedynie tworzyć nowe wartości typu string na podstawie utworzonej wcześniej wartości np. poprzez wycięcie jego części. Mając słowo ‚domek’, możemy wyciąć pierwsze trzy litery tworząc słowo ‚dom’.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Number</h3>
        <p class="article__paragraph">Przechowuje liczby, pozwala przeprowadzać operacje matematyczne. Typ ten zawiera zarówno liczby całkowite jak i ułamkowe liczby dziesiętne.</p>

        <p class="article__paragraph">W JS wykorzystuje się 64-bitowy binarny format podwójnej precyzji oparty na standardzie IEEE 754. Oznacza to, że liczby są przechowywane w 64 bitach, gdzie 1 bit przechowuje znak liczby (+ lub -), 11 bitów przechowuje wykładnik potęgowy (dla 2³ = 2 * 2 * 2 wykładnikiem jest liczba 3), natomiast pozostałe 52 bity przechowują część ułamkową.</p>

        <p class="article__paragraph">Z tego powodu nie możemy operować na dowolnych liczbach, jesteśmy zmuszeni do ograniczenia się do liczb całkowitych z przedziału od 9007199254740991 do -9007199254740991. Dodatkowo ułamki dziesiętne nie są reprezentowane w sposób dokładny i działanie 0.1 + 0.2 = 0.30000000000000004. Z matematycznego punktu widzenia nie jest to wynik, którego byśmy się spodziewali. Dlatego musimy zachować ostrożność przy operacjach na ułamkach i stosować zaokrąglenia przy porównywaniu wyników z sobą. Kolejną ciekawostką jest też fakt istnienia zera dodatniego i zera ujemnego. Gdy podzielimy 2 / 0 otrzymamy nieskończoność, natomiast dla działania 2 / -0 otrzymamy minus nieskończoność.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Boolean</h3>
        <p class="article__paragraph">Typ ten pozwala na podejmowanie decyzji. Jest to typ logiczny, może przyjmować tylko dwie wartości: true (prawda) i false (fałsz).</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Undefined</h3>
        <p class="article__paragraph">Typ undefined zawiera tylko jedną wartość, wartość undefined. Wartość nie zdefiniowana zostaje automatycznie przypisana zmiennej, która została tylko zadeklarowana przy pomocy słowa kluczowego var lub let (powiemy na ten temat przy okazji omawiania zmiennych).</p>

        <p class="article__paragraph">Dodatkowo sprawdzając typ zmiennej, która nie została zadeklarowana również otrzymamy wartość undefined np. console.log(typeof(c)); zwraca undefined gdy zmienna c nie występuje w naszym kodzie.</p>

        <p class="article__paragraph">Wartość undefined zwraca również:</p>
        <ul class="article__unordered-list">
          <li class="unordered-list__item">funkcja, w której nie zastosowano polecenia return</li>
          <li class="unordered-list__item">właściwość obiektu, która nie jest zadeklarowana</li>
        </ul>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Null</h3>
        <p class="article__paragraph">Typ null zawiera tylko jedną wartość. Jest nią null. Wartość ta reprezentuje celowy brak danej wartości w obiekcie. Wynika z tego, że musimy ją przypisać do właściwości danego obiektu.</p>
        <p class="article__paragraph">Ważną rzeczą, o której trzeba wiedzieć to błąd jaki istnieje w JS od czasu powstania tego języka.</p>

        <pre class="article__code">
        <code>
    let a = null;
    console.log(typeof(a)); // zwraca typ object
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Symbol</h3>
        <p class="article__paragraph">Jest to nie powtarzalna wartość służąca do identyfikacji właściwości w obiekcie. Tworzymy go za pomocą funkcji Symbol(‚opis’). Opis służy wyłącznie do celów debugowania abyśmy my potrafili rozróżnić symbole od siebie. Możemy nadać dwóm symbolom takie same opisy. Nie sprawi to jednak, że oba symbole będą takie same i równe sobie. Za każdym razem tworząc symbol tworzymy nowy unikatowy symbol.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Podsumowanie</h3>
        <p class="article__paragraph">Omówione do tej pory typy to wartości typu prostego, co oznacza, że są niezmienne. Są to takie podstawowe klocki, z których budujemy bardziej złożone konstrukcje.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Object</h3>
        <p class="article__paragraph">Object natomiast jest wartością złożoną składającą się z par klucz: wartość. Gdzie kluczem może być string lub symbol. Natomiast właściwością mogą być wszystkie wyżej wymienione typy. Object dodatkowo zawiera w sobie podtypy takie jak: function (funkcja – obiekt, który ma możliwość wywołania), array (tablica – obiekt, który wykorzystuje liczby jako klucze oraz ma automatycznie uaktualnianą właściwość length, która wskazuje wielkość tablicy).</p>

        <p class="article__paragraph">Gdy myślimy o obiekcie możemy go sobie wyobrazić jako uproszczony model opisujący coś co znamy z rzeczywistości. Weźmy przykład człowieka. Każdy człowiek ma imię, wzrost, wagę, kolor oczu itp. Są to właściwości naszego obiektu. Dodatkowo każdy człowiek potrafi robić różne rzeczy, np. mówić, chodzić itp. Czynności wykonywane przez obiekt nazywamy metodami tego obiektu. Oto przykład obiektu o nazwie person.</p>

        <pre class="article__code">
        <code>
    const person = {
        name: 'Tomasz',
        height: 174,
        weight: 70,
        eyeColor: 'gray',

        sayHello() {
          return 'Hello';
        },
        walk() {
          return 'I go for a walk to a park';
        }
    }

    console.log(person.name); // Tomasz
    console.log(person.walk()); // 'I go for a walk to a park'

    console.log(typeof(person.name)); // string
    console.log(typeof(person.walk)); // function
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wartość specjalna NaN</h3>
        <p class="article__paragraph">Typ number zawiera wartość NaN (not a number). Oznacza wartość, która nie jest poprawną liczbą. Powstaje w wyniku operacji matematycznej, która się nie powiodła np: 2 * 'ja'. Mamy typ number mnożony przez typ string. Ponieważ JS nie ma pojęcia w jaki sposób przeprowadzić taką operację otrzymamy NaN.</p>

        <p class="article__paragraph">Dodatkowo wartość NaN nie jest równa innej wartości NaN. Dlatego żeby sprawdzić czy coś jest wartością NaN musimy użyć metody <strong class="bold">Number.isNaN()</strong>.</p>
      </section>


    </article>


    <!-- Article 05 -->


    <article class="article">

      <header id="placeholder" class="article__header">
        <div class="decor">05</div>
        <h2 class="article__title">Zmienne cz.1</h2>
      </header>

      <p class="article__paragraph">W kodzie JS istnieją trzy słowa kluczowe służące do deklarowania zmiennych. Są to słowa <strong class="bold">var, let, const</strong>. Dzisiaj przyjrzymy się różnicom jakie występują pomiędzy nimi oraz powiemy sobie czym jest zakres i wynoszenie.</p>

      <p class="article__paragraph">Należy pamiętać, że w JS występuje typowanie dynamiczne co oznacza, że to wartości przechowywane w zmiennych mają swoje typy. Same zmienne nie wymuszają typu wartości jakie mogą przechowywać i można w nich przechowywać wartości różnego typu.</p>

      <section class="article__section">
        <h3 class="article__section__title">var</h3>

        <p class="article__paragraph">Jest to najstarszy sposób deklarowania zmiennej. Poprzez zadeklarowanie zmiennej rozumiemy następującą linijkę kodu:</p>

        <pre class="article__code">
        <code>
    var myName;
        </code>
      </pre>

        <p class="article__paragraph">Właśnie utworzyliśmy zmienną o nazwie <strong class="bold">myName</strong>. W tym momencie przechowuje ona wartość undefined. Zmienne utworzone w ten sposób są dodawane do obiektu globalnego <strong class="bold">window</strong>. Przy pomocy polecenia:</p>

        <pre class="article__code">
        <code>
    console.log(window);
        </code>
      </pre>

        <p class="article__paragraph">Możemy wyświetlić jego wszystkie wstępnie zdefiniowane właściwości. Zobaczymy, że nasza zmienna została dodana i możemy ją odszukać na tej liście.</p>

        <p class="article__paragraph">Tutaj jako ciekawostkę napiszę, że na początku zadeklarowałem zmienną o nazwie <strong class="bold">name</strong> a następnie byłem zdziwiony, że jej wartość początkowa wynosiła “”, czyli była pustym ciągiem tekstowym (string). Jak możemy zobaczyć obiekt <strong class="bold">window</strong> posiada wstępnie zdefiniowaną właściwość o nazwie <strong class="bold">name</strong>. Zagadka rozwiązana, wszystko działa jak należy.</p>

        <strong class="bold">Zasady nadawania nazw zmiennym:</strong>
        <ol class="article__ordered-list">
          <li class="ordered-list__item">nazwa nie może zaczynać się od cyfry</li>
          <li class="ordered-list__item">nie może zawierać myślnika ani krpoki</li>
          <li class="ordered-list__item">nie wolno używać słów kluczowych jak np.: var, let, const</li>
          <li class="ordered-list__item">wielkość liter ma znaczenie, zmienna <strong class="bold">name</strong> nie równa się zmiennej <strong class="bold">Name</strong></li>
          <li class="ordered-list__item">gdy nazwa składa się z kilku słów zapisujemy je w notacji wielbłądziej (camelCase). Czyli kolejne wyrazy pisane są łącznie, rozpoczynając każdy następny wielką literą. np. <strong class="bold">myName</strong></li>
          <li class="ordered-list__item">nazwa powinna wskazywać na rodzaj informacji jaki jest przechowywany w zmiennej</li>
        </ol>

        <p class="article__paragraph">Wracając do naszego przykładu, jeśli chcę zainicjować zmienną myName i przypisać jej wartość, mogę to zrobić za pomocą znaku równości.</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">Mogę wykonać obie te czynności w tej samej linijce kodu. Należy jednak pamiętać, że interpreter JS, wykonuje te dwie czynności oddzielnie najpierw deklaruje zmienną a dopiero potem przypisuje jej wartość.</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    // ten kod zostanie wykonany jako:

    var myName;
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph">Możemy przypisać wartość do zmiennej bez jej deklaracji. Jest to jednak bardzo zły pomysł. W takim przypadku dochodzi bowiem do automatycznego utworzenia zmiennej globalnej w chwili wykonywania danej linii kodu przez interpreter.</p>
      </section>


      <section class="article__section">
        <h3 class="article__section__title">Zakres</h3>

        <p class="article__paragraph">Kolejnym pojęciem jakie musimy zrozumieć jest zakres zmiennej. Zakres oznacza zasięg w jakim jest widoczna nasza zmienna. W przypadku var jest to zakres lokalny funkcji, w której została zadeklarowana zmienna lub jest to zakres globalny dla zmiennych zadeklarowanych poza funkcją.</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';

    function getMyFullName() {
      var mySurname = 'Rybacki';
      console.log(myName);
      console.log(mySurname);
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // ReferenceError
    getMyFullName(); // Tomasz Rybacki
        </code>
      </pre>

        <p class="article__paragraph">Zakres lokalny funkcji oznacza, że zmienna jest widoczna tylko wewnątrz funkcji, w której została zadeklarowana. Natomiast zmienne z zakresu globalnego są widoczne w całym naszym skrypcie. Dlatego w powyższym przykładzie funkcja getMyFullName wyświetli zarówno moje imię jak i nazwisko.</p>

        <p class="article__paragraph">Jednak gdy spróbuję dostać się do zmiennej mySurname poza funkcją otrzymam błąd ReferenceError. Dzieje się tak ponieważ, reszta mojego skryptu nie widzi tej zmiennej i nie ma pojęcia o jej istnieniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Wynoszenie</h3>

        <p class="article__paragraph">Przed wykonaniem naszego kodu interpreter przeszukuje cały nasz kod w poszukiwaniu deklaracji zmiennych i funkcji. Odnalezione deklaracje są następnie wynoszone na początek naszego skryptu, dzięki temu są widoczne w całym naszym skrypcie.</p>

        <pre class="article__code">
        <code>
    console.log(myName); // undefined

    // nie otrzymamy w tym momencie błędu ReferenceError
    // ponieważ zmienna została wyniesiona na początek skryptu

    var myName = 'Tomasz';

    // zauważmy, że dopiero w tym momencie została przypisana wartość

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Powyższy kod zostanie wykonany przez interpreter w następujący sposób:</p>

        <pre class="article__code">
        <code>
    var myName;

    console.log(myName); // undefined

    myName = 'Tomasz';

    console.log(myName); // Tomasz
        </code>
      </pre>

        <p class="article__paragraph">Z tego też powodu powinniśmy deklarować wszystkie nasze zmienne na początku naszego skryptu (zakres globalny) lub funkcji (zakres lokalny). Dzięki temu nasz kod jest czytelniejszy, od razu widzimy, jakie zmienne mają jaki zakres.</p>

      </section>

      <section class="article__section">
        <h3 class="article__section__title">Dlaczego nie chcemy deklarować wszystkich naszych zmiennych globalnie ?</h3>

        <p class="article__paragraph">Nasza aplikacja lub strona internetowa może współpracować z wieloma bibliotekami napisanymi w JS przez kogoś innego. Wynika z tego, że ktoś inny mógł by nadać takie same nazwy swoim zmiennym jak zrobiliśmy to my w naszym skrypcie. Powstało by wtedy wiele zamieszania, a wyniki działania naszej aplikacji były by nieprzewidywalne. Dlatego staramy się unikać współdzielenia przestrzeni nazw i gdy tylko to możliwe ukrywamy nasze zmienne.</p>
      </section>
    </article>


    <!-- Article 06 -->

    <article class="article">

      <header id="Zmienne_cz.2" class="article__header">
        <div class="decor">06</div>
        <h2 class="article__title">Zmienne cz.2</h2>
      </header>

      <p class="article__paragraph">Kontynuujemy temat zmiennych. Dzisiaj przyjrzymy się zmiennym wprowadzonym przez ECMAScript 6. Są to słowa kluczowe <strong class="bold">let</strong> i <strong class="bold">const</strong>. Dodatkowo zobaczymy w jaki sposób wartości są przechowywane w zmiennych.</p>

      <section class="article__section">
        <h3 class="article__section__title">let</h3>

        <p class="article__paragraph">Za pomocą słowa <strong class="bold">let</strong> deklarujemy zmienną, której zakres jest ograniczony do bloku kodu. Blokiem kodu nazywamy wszystko co zawiera się w nawiasach klamrowych { }, możemy w ten sposób zgrupować ze sobą kilka wyrażeń.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    var mySurname = 'Rybacki';

    {
      let myName = 'Marcin';
      var mySurname = 'Kazanowski'

      console.log(myName); // Marcin
      console.log(mySurname); // Kazanowski
    }

    console.log(myName); // Tomasz
    console.log(mySurname); // Kazanowski
        </code>
      </pre>

        <p class="article__paragraph">let nie tworzy właściwości na obiekcie globalnym</p>

        <pre class="article__code">
        <code>
    var myName = 'Tomasz';
    let mySurname = 'Rybacki';

    console.log(window.myName); // Tomasz
    console.log(window.mySurname); // undefined
        </code>
      </pre>

        <p class="article__paragraph">nie można ponownie zadeklarować zmiennej o tej samej nazwie w danym zakresie</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myName = 'Marcin'; // SyntaxError
        </code>
      </pre>

        <p class="article__paragraph">nie ulega wynoszeniu – tak zwana tymczasowa martwa strefa (Temporal Dead Zone)</p>

        <pre class="article__code">
        <code>
    myName = 'Tomasz'; // ReferenceError
    console.log(typeof(myName)); // ReferenceError
    let myName;
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">const</h3>

        <p class="article__paragraph">Przy użyciu słowa kluczowego <strong class="bold">const</strong> deklarujemy zmienną, która jest stałą. Co oznacza, że nie można jej przypisać nowej wartości. Dodatkowo musimy przypisać jej wartość w chwili deklaracji.</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"> Poniższe próby zakończą się błędem</p>

        <pre class="article__code">
        <code>
    const myName = 'Tomasz';
    const myName = 'Marcin'; // SyntaxError

    const myName; // SyntaxError
    myName = 'Tomasz';
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">const</strong> tak samo jak <strong class="bold">let</strong> ma zakres bloku, nie tworzy właściwości na obiekcie globalnym, nie można ponownie zadeklarować zmiennej o tej samej nazwie w danym zakresie i nie ulega wynoszeniu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Przechowywanie wartości w zmiennych</h3>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieć w jaki sposób wartości są przechowywane w zmiennych. Otóż wartości typu prostego są przechowywane bezpośrednio w danej zmiennej. Możemy więc kopiować wartości jakie przechowują do innych zmiennych.</p>

        <pre class="article__code">
        <code>
    let a = 2;
    console.log(a); // 2

    let b = a;
    console.log(b); // 2

    b = b + 2;
    console.log(b); // 4
    console.log(a); // 2
        </code>
      </pre>

        <p class="article__paragraph"> Wyobraźmy sobie, że zmienna <strong class="bold">a</strong> jest pudełkiem, w którym znajduje się cyfra <strong class="bold">2</strong>. W momencie zadeklarowania zmiennej <strong class="bold">b</strong> i przypisania jej wartości <strong class="bold">a</strong> powstaje nowe pudełko z nową cyfrą <strong class="bold">2</strong>. W efekcie mamy dwa pudełka i dwie oddzielne cyfry <strong class="bold">2</strong>, które możemy niezależnie od siebie modyfikować.</p>

        <p class="article__paragraph">Natomiast wartości typu złożonego są zapisywane w zmiennych jako referencja do miejsca w pamięci, w której są przechowywane dane informacje. Możemy to sobie wyobrazić jako jedno pudełko, w którym znajduje się obiekt <strong class="bold">me</strong>. W chwili utworzenia obiektu <strong class="bold">myBrother</strong> nie następuje skopiowanie obiektu <strong class="bold">me</strong> i przypisanie go do nowej zmiennej. Powstaje natomiast nowa referencja (czyli taka strzałka wskazująca gdzie znajduje się obiekt <strong class="bold">me</strong>). Mamy więc dwie oddzielne strzałki, które wskazują te same pudełko. Modyfikując więc dowolną ze strzałek, tak naprawdę modyfikujemy ten sam pojemnik. Dlatego w poniższym przykładzie zmieniliśmy zarówno moje imię jak i imię mojego brata.</p>

        <pre class="article__code">
        <code>
    let me = {
      name: 'Tomasz',
      age: 28
    }

    let myBrother = me;

    myBrother.name = 'Daniel';

    console.log(myBrother.name); // Daniel
    console.log(me.name); // Daniel
        </code>
      </pre>

        <p class="article__paragraph">Gdy zadeklarujemy stałą, która przechowuje wartość typu złożonego jak np. obiekt. Możemy zmienić właściwości tego obiektu. Nie możemy jednak przypisać jej nowej wartości.</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28
    }

    person.name = 'Daniel';
    person.age = 25;

    console.log(person); // {name: Daniel, age: 25}

    person = 'Daniel'; // TypeError
        </code>
      </pre>
      </section>
    </article>


    <!-- Article 07 -->

    <article class="article">

      <header id="Operatory" class="article__header">
        <div class="decor">07</div>
        <h2 class="article__title">Operatory</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Operatory matematyczne</h3>

        <p class="article__paragraph">Są nam dobrze znane z lekcji matematyki. Są to:</p>

        <pre class="article__code">
        <code>
    // dodawanie (+)

    console.log(2 + 3); // 5

    // odejmowanie (-)

    console.log(5 - 4); // 1

    // mnożenie (*)

    console.log(2 * 3); // 6

    // dzielenie (/)

    console.log(8 / 2); // 4

    // reszta z dzielenia (%)

    console.log(6 % 5); // 1
        </code>
      </pre>

        <p class="article__paragraph">Nowością dla nas mogą być operatory inkrementacji (++) i dekrementacji (--). Czyli odpowiednio zwiększenia i zmniejszenia danej wartości o 1. Możemy je stosować za równo z lewej strony jak i prawej strony naszej zmiennej. Gdy występują z lewej to zmiana wartości nastąpi już w danej linijce kodu, gdy występują z prawej to zmiana wartości nastąpi w następnej linijce kodu.</p>

        <pre class="article__code">
        <code>
    // inkrementacja (++) - czyli zwiększenie wartości o 1

    let someNumber = 2;

    console.log(someNumber++); // 2
    console.log(someNumber); // 3

    someNumber = 2;

    console.log(++someNumber); // 3
    console.log(someNumber); // 3

    // dekrementacja (--) - czyli zmniejszenie wartości o 1

    let otherNumber = 6;

    console.log(otherNumber--); // 6
    console.log(otherNumber); // 5

    otherNumber = 6;

    console.log(--otherNumber); // 5
    console.log(otherNumber); // 5
        </code>
      </pre>

        <p class="article__paragraph">Osobiście wolę ich nie stosować i używać operatorów przypisania <strong class="bold">someNumber += 1</strong> lub <strong class="bold">someNumber -=1</strong>, co według mnie jest o wiele bardziej czytelne.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory przypisania</h3>

        <p class="article__paragraph">Znamy już operator równa się (=) z poprzednich wpisów. Nie wiemy jednak, że ma on kilka wariantów, które pozwalają najpierw wykonać działanie a następnie przypisać wynik tego działania np. <strong class="bold">someNumber += 1</strong> jest równoznaczne z <strong class="bold">someNumber = someNumber + 1</strong></p>

        <pre class="article__code">
        <code>
    let number = 6;

    // przypisanie dodawania (+=)

    console.log(number += 2); // 8

    // przypisanie odejmowania (-=)

    console.log(number -= 2); // 6

    // przypisanie mnożenia

    console.log(number *= 2); // 12

    // przypisanie dzielenia (/=)

    console.log(number /= 2); // 6

    // przypisanie reszty z dzielenia

    console.log(number %= 2); // 0
        </code>
      </pre>
      </section>
      <section class="article__section">
        <h3 class="article__section__title">Operatory porównania</h3>

        <p class="article__paragraph">Służą do sprawdzenia czy obie strony równania są sobie równe czy różne.</p>

        <p class="article__paragraph"><strong class="bold">1 Porównanie luźne (==)</strong></p>

        <p class="article__paragraph">Zezwala na konwersję typów porównywanych wartości. Czyli gdy porównujemy ze sobą dwie wartości różnych typów jak np. '2' == 2 otrzymamy wartość <strong class="bold">true</strong>. Czyli obie wartości są sobie równe, ponieważ typ string został zamieniony na typ number i dopiero wówczas dokonano porównania 2 == 2, co jak wiemy jest prawdą.</p>

        <p class="article__paragraph"><strong class="bold">2 Porównanie ścisłe (===)</strong></p>

        <p class="article__paragraph">Nie zezwala na konwersję typów porównywanych wartości. Czyli '2' === 2 da nam w wyniku <strong class="bold">false</strong>. Dokładnie na temat konwersji typów powiemy w kolejnym wpisie. Pozostałe operatory porównania to:</p>

        <pre class="article__code">
        <code>
    // większy od (&gt;)

    console.log(4 &gt; 2); // true

    // mniejszy od (&lt;)

    console.log(1 &lt; 3); // true

    // większy równy od (&gt;=)

    console.log(2 &gt;= 2); // true

    // mniejszy równy od (&lt;=)

    console.log(6 &lt;= 9); // true

    // nie równy - porównanie luźne (!=)

    console.log(2 != 3); // true

    // nie równy - porównanie ścisłe (!==)

    console.log('3' !== 3); // true
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operatory logiczne</h3>

        <p class="article__paragraph">Gdy chcemy podjąć bardziej skomplikowaną decyzję stosujemy operatory logiczne, które pozwalają nam sprawdzić kilka warunków jednocześnie.</p>

        <p class="article__paragraph">Warto wiedzieć, że operator <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong> zwraca jedną ze sprawdzanych wartości, a ponieważ najczęściej jest stosowany w kontekście sprawdzania wartości boolowskich jest następnie konwertowany do wartości <strong class="bold">true</strong> lub <strong class="bold">false</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz';
    let myAge = 28;
    let isSleeping = true;

    // logiczne i (&amp;&amp;) - zwraca prawdę gdy oba warunki są spełnione

    console.log(myAge &gt;= 18 &amp;&amp; myName === 'Tomasz'); // true
    console.log(myAge &amp;&amp; myName); // Tomasz
    // logiczne lub (||) - zwraca prawdę gdy jeden z warunków jest spełniony

    console.log(myName === 'Tomasz' || myName === 'Marcin'); // true

    // negacja (!) - odwraca wartość z prawdy na fałsz lub na odwrót

    console.log(!isSleeping); // false
        </code>
      </pre>

        <p class="article__paragraph">Wyrażenia logiczne są sprawdzane od lewej do prawej strony. Staramy się pisać je w taki sposób żeby warunek, który ma większe prawdopodobieństwo oblać nasz test był umieszczony z lewej strony. Ponieważ dalsza część naszego wyrażenia nie jest wtedy sprawdzana, tylko od razu otrzymujemy nasz wynik np. dla <strong class="bold">warunek1 &amp;&amp; warunek2</strong> gdy <strong class="bold">warunek1</strong> zwróci <strong class="bold">false</strong>, całe nasze wyrażenie zwróci wartość <strong class="bold">false</strong> bez sprawdzania <strong class="bold">warunek2</strong>. Analogicznie dla <strong class="bold">warunek1 || warunek2</strong>, gdy <strong class="bold">warunek1</strong> zwraca <strong class="bold">true</strong>, całe wyrażenie zwraca wartość <strong class="bold">true</strong>.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Konkatenacja</h3>

        <p class="article__paragraph">Operator (+) ma dodatkowe działanie w postaci łączenia ze sobą łańcuchów znaków.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log('Mam na' + ' imię ' + myName + '.'); // Mam na imię Tomasz.
        </code>
      </pre>

        <p class="article__paragraph">Wraz z wprowadzeniem przez ES6 szablonów ciągów znaków, zamiast używać plusa do łączenia ze sobą łańcuchów znaków korzystamy ze znaku apostrofu (pod klawiszem Esc). Jest to o wiele bardziej czytelniejszy sposób na umieszczanie tekstu ze zmiennych w generowanych przez nas zdaniach. Zmienne umieszczamy w nawiasach klamrowych poprzedzonych znakiem dolara <strong class="bold">${}</strong>.</p>

        <pre class="article__code">
        <code>
    let myName = 'Tomasz'
    console.log(`Mam na imię ${myName}.`); // Mam na imię Tomasz.
        </code>
      </pre>
      </section>


    </article>


    <!-- Article 08 -->


    <article class="article">

      <header id="Konwersja_typów" class="article__header">
        <div class="decor">08</div>
        <h2 class="article__title">Konwersja typów</h2>
      </header>

      <section class="article__section">
        <h3 class="article__section__title">Czym jest konwersja typów ?</h3>

        <p class="article__paragraph">Jest to zamiana typu jednej wartości na inny typ. Kyle Simpson używa określenia <strong class="bold">jawnej konwersji typów</strong>, gdy w naszym kodzie widać, że konwersja przeprowadzana jest celowo. Oraz określenia <strong class="bold">niejawnej konwersji typów</strong>, gdy następuje ona jako efekt dodatkowy innej przeprowadzanej operacji.</p>

        <p class="article__paragraph">Nie będę dokładnie opisywał mechanizmu jej działania, żeby nie komplikować. W końcu z założenia kurs ten jest przeznaczony dla osób początkujących.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Jawna konwersja typów.</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczby (number) na ciąg znaków (string) lub na odwrót.</strong></p>

        <p class="article__paragraph">Najbardziej przejrzystym sposobem dokonania tej konwersji jest użycie wbudowanych funkcji <strong class="bold">String()</strong> i <strong class="bold">Number()</strong>:</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(Number(age)); // 28
    console.log(typeof(Number(age))); // number

    console.log(String(birthday)); // '1989'
    console.log(typeof(String(birthday))); // string
        </code>
      </pre>

        <p class="article__paragraph">Kolejnym jawnym sposobem na zamianę ciągu znaków na liczbę jest użycie operatora +</p>

        <pre class="article__code">
        <code>
    let age = '28';

    console.log(+age); // 28
    console.log(typeof(+age)); // number
        </code>
      </pre>

        <p class="article__paragraph"> <strong class="bold">- zamiana na typ boolean</strong></p>

        <p class="article__paragraph">W tym momencie musimy sobie powiedzieć na temat wartości prawdziwych (truthy) i fałszywych (falsy).</p>

        <p class="article__paragraph">Wartością fałszywą jest wszystko to co zostaje zamienione na wartość <strong class="bold">false</strong> podczas konwersji na typ boolean. Jest to krótka, ściśle określona lista wartości, którą łatwo zapamiętać.</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">undefined</li>
          <li class="ordered-list__item">null</li>
          <li class="ordered-list__item">0</li>
          <li class="ordered-list__item">NaN</li>
          <li class="ordered-list__item">'' pusty ciąg znaków</li>
        </ol>

        <p class="article__paragraph">Wartości prawdziwe możemy zapamiętać jeszcze prościej, są to wszystkie wartości, które nie znajdują się na powyższej liście.</p>

        <p class="article__paragraph">Tak samo jak wcześniej najbardziej czytelnym sposobem na konwersję jest użycie wbudowanej funkcji <strong class="bold">Boolean()</strong></p>

        <pre class="article__code">
        <code>
    let object = {};
    console.log(Boolean(object)); // true

    let array = [];
    console.log(Boolean(array)); // true

    let string = '0';
    console.log(Boolean(string)); // true

    let number = 6;
    console.log(Boolean(number)); // true


    let zero = 0;
    console.log(Boolean(zero)); // false

    let something;
    console.log(Boolean(something)); // false

    let empty = null;
    console.log(Boolean(empty)); // false

    let emptyString = '';
    console.log(Boolean(emptyString)); // false

    let invalidNumber = NaN;
    console.log(Boolean(invalidNumber)); // false
        </code>
      </pre>

        <p class="article__paragraph"> Kolejnym sposobem na konwersję jest użycie operatora podwójnej negacji !!</p>

        <pre class="article__code">
        <code>
    let age = '28';
    let birthday = 1989;

    console.log(!!age); // true
    console.log(typeof(!!age)); // boolean

    console.log(!!birthday); // true
    console.log(typeof(!!birthday)); // boolean
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana wartości złożonych (obiektów) na wartości proste</strong></p>

        <p class="article__paragraph">W tym przypadku sprawa się nieco komplikuje, ponieważ sami musimy określić w jaki sposób chcemy zamienić obiekt na liczbę lub ciąg znaków. Każdy obiekt dziedziczy metodę <strong class="bold">toString()</strong> i <strong class="bold">valueOf()</strong>, właśnie te dwie metody określają w jaki sposób zostanie dokonana konwersja na <strong class="bold">string</strong> i <strong class="bold">number</strong>.</p>

        <pre class="article__code">
        <code>
    // zostaną wykorzystane domyślne metody odziedziczone po prototypie

    const person = {
      name: 'Tomasz',
      age: 28
    };

    // funkcje wbudowane Number() i String() wywołują metody valueOf() i toString()

    console.log(Number(person)); // NaN

    console.log(String(person)); // [object Object]
    console.log(typeof(String(person))); // string

    // możemy sami wywołać metodę toString() bezpośrednio

    console.log(person.toString()); // [object Object]
        </code>
      </pre>

        <p class="article__paragraph">Przesłaniamy domyślne metody i sami decydujemy w jaki sposób ma nastąpić konwersja:</p>

        <pre class="article__code">
        <code>
    const person = {
      name: 'Tomasz',
      age: 28,

      valueOf() {
        return this.age;
      },

      toString() {
        return `{name: ${this.name}, age: ${this.age}}`;
      }
    };

    console.log(Number(person)); // 28

    console.log(String(person)); // {name: Tomasz, age: 28}
    console.log(person.toString()); // {name: Tomasz, age: 28}
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Niejawna konwersja typów</h3>

        <p class="article__paragraph"><strong class="bold">- zamiana liczb na ciągi znaków</strong></p>

        <p class="article__paragraph">Jeśli dowolny argument operatora + to wartość typu string, otrzymamy konkatenację łańcuchów znaków.</p>

        <pre class="article__code">
        <code>
    let birthday = 1989;

    console.log(birthday + ''); // 1989
    console.log(typeof(birthday + '')); // string
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- zamiana ciągów znaków na liczby</strong></p>

        <pre class="article__code">
        <code>
    let a = '1';
    let b = 3;

    console.log(a - b); // -2
    console.log(a * b); // 3
    console.log(a / b); // 0.3333333333333333
        </code>
      </pre>

        <p class="article__paragraph"><strong class="bold">- konwersja dowolnej wartości na typ boolean</strong></p>

        <p class="article__paragraph">Każda wartość użyta w kontekście poniższych wyrażeń zostanie zamieniona na typ boolean:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">wyrażenie testowe w instrukcji <strong class="bold">if</strong></li>
          <li class="ordered-list__item">wyrażenie testowe w nagłówku pętli <strong class="bold">for</strong></li>
          <li class="ordered-list__item">wyrażenie testowe w pętlach <strong class="bold">while</strong> i <strong class="bold">do while</strong></li>
          <li class="ordered-list__item">wyrażenie testowe w operatorze warunkowym</li>
          <li class="ordered-list__item">argument z lewej strony operatorów <strong class="bold">&amp;&amp;</strong> i <strong class="bold">||</strong></li>
        </ol>


        <p class="article__paragraph">Omówimy wszystkie te wyrażenia w kolejnych lekcjach, więc nie przejmuj się, że nie wiesz jeszcze co oznaczają.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Korzystanie z równości luźnej ==</h3>

        <p class="article__paragraph">Wartość NaN nigdy nie jest równa NaN. Możemy to sobie wytłumaczyć w następujący sposób.</p>

        <pre class="article__code">
        <code>
    console.log('a' * 2); // NaN
    console.log('b' * 2); // NaN
        </code>
      </pre>

        <p class="article__paragraph">Obie wartości nie są prawidłowymi liczbami, ale każda z nich powstała w inny sposób, dlatego nie są sobie równe. Żeby sprawdzić czy dana wartość jest NaN, korzystamy z wbudowanej funkcji <strong class="bold">Number.isNaN()</strong>. Ważne jest żeby nie pomylić z globalną funkcją <strong class="bold">isNaN()</strong>. Jest to starsza wersja tej funkcji, która wymusza konwersję na typ number przed dokonaniem sprawdzenia.</p>

        <pre class="article__code">
        <code>
    console.log(NaN == NaN); // false
    console.log(('a' * 2) == NaN); // false

    console.log(Number.isNaN(NaN)); // true
    console.log(Number.isNaN('a' * 2)); // true

    let a = 'NaN';

    console.log(Number.isNaN(a)); // false
    console.log(isNaN(a)); // true
        </code>
      </pre>

        <p class="article__paragraph">Równość luźna ma kilka przypadków, które bez znajomości mechanizmu przeprowadzanej konwersji dają nam zaskakujące rezultaty. Dlatego też gdy korzystamy z operatora ==, należy przestrzegać poniższych zasad:</p>

        <ol class="article__ordered-list">
          <li class="ordered-list__item">Jeśli po którejś ze stron występuje wartość <strong class="bold">true</strong> lub <strong class="bold">false</strong>, nigdy nie używaj operatora ==</li>
          <li class="ordered-list__item">Jeśli po którejś ze stron może wystąpić wartość <strong class="bold">[], ′′ lub 0</strong>, nie używaj operatora ==</li>
        </ol>

        <p class="article__paragraph">Oto lista szalonych wyników, których chcemy uniknąć w naszym kodzie:</p>

        <pre class="article__code">
        <code>
    console.log('0' == false); // true
    console.log(false == 0); // true
    console.log(false == ''); // true
    console.log(false == []); // true

    console.log('' == 0); // true
    console.log('' == []); // true
    console.log(0 == []); // true
        </code>
      </pre>

      </section>

    </article>


    <!-- Article 09 -->


    <article class="article">

      <header id="Instrukcje_warunkowe" class="article__header">
        <div class="decor">09</div>
        <h2 class="article__title">Instrukcje warunkowe</h2>
      </header>

      <p class="article__paragraph">Do podejmowania decyzji w kodzie JS służą instrukcje warunkowe <strong class="bold">if … else, switch</strong> oraz operator warunkowy.</p>

      <section class="article__section">
        <h3 class="article__section__title">if … else</h3>

        <p class="article__paragraph">Nasz warunek jest zamieniany na typ boolean. W zależności od otrzymanego wyniku, wykonamy dany fragment kodu.</p>

        <pre class="article__code">
        <code>
    if (warunek) {
      // jeśli prawda wykonaj ten blok kodu
    } else {
      // jeśli fałsz wykonaj ten blok kodu
    }
        </code>
      </pre>

        <p class="article__paragraph">Możemy w ten sposób sprawdzać czy dana wartość istnieje lub czy spełnia dany warunek np.</p>

        <pre class="article__code">
        <code>
    // sprawdzamy czy obiekt user posiada właściwość myName
    const user = {
      name: 'Tomasz',
      age: 29,
      country: 'Poland'
    };
    if (user.myName) {
      console.log(`Właściwość myName została odnaleziona, jej wartość wynosi ${user.myName}`);
    } else {
      console.log('Właściwość myName nie została odnaleziona w obiekcie user.');
    }
    /*
    Nasz wynik:
    Właściwość myName nie została odnaleziona w obiekcie user.
    */
    // sprawdzamy czy użytkownik może kupić legalnie piwo w Polsce
    if (user.age &gt;= 18 &amp;&amp; user.country === 'Poland') {
      console.log('Możesz legalnie kupić piwo będąc w Polsce.');
    } else {
      console.log('W Polsce, nie sprzedajemy alkoholu nieletnim!');
    }
    /*
    Nasz wynik:
    Możesz legalnie kupić piwo będąc w Polsce
    */
        </code>
      </pre>

        <p class="article__paragraph">Jeśli chcemy wykonać tylko jedną linijkę kodu możemy pominąć nawiasy klamrowe. Nie jest to zalecana praktyka, ale czasami bywa przydatna i warto o niej wiedzieć.</p>

        <pre class="article__code">
        <code>
    if (user.name === 'Tomasz') console.log('Cześć Tomasz!'); // Cześć Tomasz!
    if (user.age &gt;= 18) console.log('Jesteś pełnoletni.'); // Jesteś pełnoletni.
        </code>
      </pre>

        <p class="article__paragraph">Dodatkowo możemy zagnieżdżać warunki jeden w drugim i sprawdzać kilka warunków po sobie</p>

        <pre class="article__code">
        <code>
    if (user.country === 'Poland') {
      if (user.name === 'Janek') {
        if (user.age &gt;= 18) {
          console.log('Użytkownik przeszedł test prawdziwego Polaka.');
        }
      }
    } else if (user.country === 'Germany') {
      if (user.name === 'Hans') {
        if (user.age &gt;= 18) {
          console.log('Użytkownik przeszedł test prawdziwego Niemca.');
        }
      }
    } else {
      console.log('Użytkownik nie jest ani prawdziwym Polakiem ani prawdziwym Niemcem.');
    }
        </code>
      </pre>

        <p class="article__paragraph">Jak możemy zobaczyć w powyższym przykładzie jest to mało czytelny sposób prezentowania logiki naszego kodu. Dodatkowo łatwo w nim popełnić błąd. Dlatego korzystajmy z operatorów logicznych, żeby nie stosować zbyt wielu poziomów zagnieżdżenia kodu.</p>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">switch</h3>

        <p class="article__paragraph">Gdy chcemy wybrać co ma się stać na podstawie kilku możliwych odpowiedzi, korzystamy ze switcha. Jego działanie polega na sprawdzeniu każdej zdefiniowanej odpowiedzi do naszego warunku. Następnie wykonywany jest kod, który przeszedł nasz warunek aż do słowa kluczowego <strong class="bold">break</strong>. Służy ono do przerwania działania wykonywanego kodu i wyjście z bloku kodu <strong class="bold">switch</strong>. Musimy je dodać po każdej możliwej odpowiedzi, w przeciwnym razie zostanie wykonany cały pozostały kod. Na końcu instrukcji <strong class="bold">switch</strong> zawsze podajemy przypadek domyślny (<strong class="bold">default</strong>), który ma zostać wykonany w przypadku braku dopasowania żadnej z powyższych odpowiedzi.</p>

        <pre class="article__code">
        <code>
    switch (warunek) {
      case odpowiedź1:
        // wykonaj ten kod gdy odpowiedż1 jest poprawna
        break;
      case odpowiedź2:
        // wykonaj ten kod gdy odpowiedż2 jest poprawna
        break;
      case odpowiedź3:
        // wykonaj ten kod gdy odpowiedż3 jest poprawna
        break;
      default:
        // gdy żadna z powyższych odpowiedzi nie jest właściwa, wykonaj ten kod
    }
        </code>
      </pre>

        <strong class="bold">Przykład</strong>

        <pre class="article__code">
        <code>
    // Jaka jest stolica państwa, w którym mieszka nasz użytkownik ?
    switch (user.country) {
      case 'Poland':
        console.log('Stolicą państwa użytkownika jest Warszawa.');
        break;
      case 'Germany':
        console.log('Stolicą państwa użytkownika jest Berlin.');
        break;
      case 'Italy':
        console.log('Stolicą państwa użytkownika jest Rzym.');
        break;
      default:
        console.log('Użytkownik mieszka poza Europą.');
    }
        </code>
      </pre>
      </section>

      <section class="article__section">
        <h3 class="article__section__title">Operator warunkowy</h3>

        <p class="article__paragraph">Gdy mamy tylko dwie możliwości do wyboru, możemy skrócić nasz kod, przez zastosowanie operatora warunkowego (nazywanego też operatorem trójkowym).</p>

        <pre class="article__code">
        <code>
    (warunek) ? (wykonaj gdy prawda) : (wykonaj gdy fałsz)
        </code>
      </pre>
      </section>

      <strong class="bold">Przykład</strong>

      <pre class="article__code">
        <code>
    let a = 8;
    let b = 5;
    const biggerNumber = (a &gt;= b) ? a : b;
    console.log(biggerNumber); // 8
        </code>
      </pre>

    </article>




    <footer class="documentation__footer">
      <span class="footer__txt">designed &amp; coded with <span class="footer__icon">&#10084;</span> by <span class="footer__bold">&copy; Tomasz Rybacki</span> in 2018</span>
    </footer>
    <!-- blank -->
  </main>


  <script src="scripts/code.js"></script>
</body>

</html>
